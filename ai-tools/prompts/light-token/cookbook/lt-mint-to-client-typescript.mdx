~~~~text
---
argument-hint: <project_path>
description: Mint tokens to light token accounts in TypeScript
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Mint tokens to light token accounts (TypeScript)

References:
- Cookbook Guide: https://zkcompression.com/light-token/cookbook/mint-to
- SDK Reference: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Function | Purpose |
|-----------|----------|---------|
| Connect | createRpc() | Connect to ZK Compression RPC endpoint |
| Mint Tokens (Action) | mintToInterface() | High-level action that mints tokens and returns signature |
| Mint Tokens (Instruction) | createMintToInterfaceInstruction() | Build instruction for manual transaction construction |
| Get Mint | getMintInterface() | Fetch mint account data including merkle context |
| Get ATA | getAssociatedTokenAddressInterface() | Derive token account address from mint and owner |
| Fetch Proof | getValidityProofV2() | Get proof that mint exists in state tree |
| Send Transaction | sendAndConfirmTransaction() | Submit transaction to network |

### Phase 1: Index project

```bash
grep -r "createRpc\|@lightprotocol/compressed-token\|@solana/web3.js" src/
```

### Phase 2: Add dependencies

```bash
npm install --save \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @solana/web3.js
```

### Phase 3: Implement mint-to operation

See Code Reference below for TypeScript implementation.

**Two Approaches:**

1. **Action (Recommended)**: Use `mintToInterface()` for simple, automatic token minting
   - Automatically handles validity proof, merkle context, and transaction construction
   - Returns transaction signature
   - Example: Action code below

2. **Instruction (Advanced)**: Use `createMintToInterfaceInstruction()` for manual transaction control
   - Gives full control over transaction construction
   - Requires manual validity proof fetching and mint data retrieval
   - Useful for batching multiple instructions
   - Example: Instruction code below

#### Action Approach

1. **RPC Setup**: Connect to ZK Compression RPC endpoint (Helius, Triton, or localnet)
   - Use `createRpc()` with mainnet, devnet, or local URLs
   - For devnet: `https://devnet.helius-rpc.com?api-key=${API_KEY}`
   - For localnet: `createRpc()` with no arguments

2. **Create Mint**: Create a mint account if needed
   - Use `createMintInterface(rpc, payer, mintAuthority, freezeAuthority, decimals)`
   - Returns `{ mint, transactionSignature }`

3. **Create Token Account**: Create destination token account if needed
   - Use `createAtaInterface(rpc, payer, mint, owner)` for light token accounts
   - For regular SPL: Use `createAssociatedTokenAccount()` from `@solana/spl-token`

4. **Get Destination Address**: Derive token account address
   - Use `getAssociatedTokenAddressInterface(mint, owner)` for unified interface
   - Works with SPL, Token-2022, and Light Token programs

5. **Mint Tokens**: Call `mintToInterface()` with configuration
   - Parameters: `(rpc, payer, mint, destination, authority, amount)`
   - `amount` is in smallest unit (e.g., 1_000_000_000 for 1 token with 9 decimals)
   - Returns transaction signature
   - Automatically handles all proof fetching and validity verification

#### Instruction Approach

1. **RPC Setup**: Same as Action approach

2. **Create Mint and Token Account**: Same as Action approach (steps 2-4)

3. **Fetch Mint Data**: Get mint account with merkle context
   - Use `getMintInterface(rpc, mint)` to fetch mint data
   - Returns mint object with optional `merkleContext` for light-mints
   - Merkle context includes hash, leafIndex, treeInfo, proveByIndex

4. **Fetch Validity Proof**: Get proof that mint exists in state tree (light-mints only)
   - Check if `mintInterface.merkleContext` exists
   - Use `rpc.getValidityProofV2([{hash, leafIndex, treeInfo, proveByIndex}], [], DerivationMode.compressible)`
   - Pass mint merkle context as hash array, empty array for addresses
   - Returns proof object for instruction

5. **Build Instruction**: Create mint-to instruction with all parameters
   - Call `createMintToInterfaceInstruction(mintInterface, destination, mintAuthority, payer, amount, validityProof?)`
   - `validityProof` is optional (only required for light-mints)

6. **Send Transaction**: Build transaction and submit to network
   - Create `Transaction()` and add compute budget + instruction
   - Sign with payer keypair (and mint authority if different)
   - Use `sendAndConfirmTransaction(rpc, tx, signers)`

### Phase 4: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

## Code Reference

### Action Approach (Recommended)

```typescript
import "dotenv/config";
import { Keypair } from "@solana/web3.js";
import { createRpc } from "@lightprotocol/stateless.js";
import {
    createMintInterface,
    createAtaInterface,
    mintToInterface,
    getAssociatedTokenAddressInterface,
} from "@lightprotocol/compressed-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
// localnet:
// const RPC_URL = undefined;
const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    // devnet:
    const rpc = createRpc(RPC_URL);
    // localnet:
    // const rpc = createRpc();

    const { mint } = await createMintInterface(rpc, payer, payer, null, 9);

    const recipient = Keypair.generate();
    await createAtaInterface(rpc, payer, mint, recipient.publicKey);

    const destination = getAssociatedTokenAddressInterface(mint, recipient.publicKey);
    const tx = await mintToInterface(rpc, payer, mint, destination, payer, 1_000_000_000);

    console.log("Tx:", tx);
})();
```

### Instruction Approach (Advanced)

```typescript
import "dotenv/config";
import { Keypair, ComputeBudgetProgram, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { createRpc, bn, DerivationMode } from "@lightprotocol/stateless.js";
import {
    createMintInterface,
    createAtaInterface,
    createMintToInterfaceInstruction,
    getMintInterface,
    getAssociatedTokenAddressInterface,
} from "@lightprotocol/compressed-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
const rpc = createRpc(RPC_URL);
// localnet:
// const rpc = createRpc();

const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {

    const { mint } = await createMintInterface(rpc, payer, payer, null, 9);

    const recipient = Keypair.generate();
    await createAtaInterface(rpc, payer, mint, recipient.publicKey);
    const destination = getAssociatedTokenAddressInterface(
        mint,
        recipient.publicKey
    );

    const mintInterface = await getMintInterface(rpc, mint);

    let validityProof;
    if (mintInterface.merkleContext) {
        validityProof = await rpc.getValidityProofV2(
            [
                {
                    hash: bn(mintInterface.merkleContext.hash),
                    leafIndex: mintInterface.merkleContext.leafIndex,
                    treeInfo: mintInterface.merkleContext.treeInfo,
                    proveByIndex: mintInterface.merkleContext.proveByIndex,
                },
            ],
            [],
            DerivationMode.compressible
        );
    }

    const ix = createMintToInterfaceInstruction(
        mintInterface,
        destination,
        payer.publicKey,
        payer.publicKey,
        1_000_000_000,
        validityProof
    );

    const tx = new Transaction().add(
        ComputeBudgetProgram.setComputeUnitLimit({ units: 500_000 }),
        ix
    );
    const signature = await sendAndConfirmTransaction(rpc, tx, [payer]);

    console.log("Tx:", signature);
})();
```

### Key Differences

| Aspect | Action Approach | Instruction Approach |
|--------|----------------|---------------------|
| Complexity | Simple, one function call | More setup required |
| Control | Automatic | Full manual control |
| Use Case | Most common scenarios | Batching, custom flows |
| Mint Data | Auto-fetched | Must fetch with getMintInterface() |
| Validity Proof | Auto-fetched | Must fetch manually for light-mints |
| Transaction | Auto-built and sent | Must build and send |

### Token Amount Configuration

Both approaches use smallest unit for amount:

```typescript
// For a token with 9 decimals:
const amount = 1_000_000_000; // Mints 1.0 tokens

// For a token with 6 decimals:
const amount = 1_000_000; // Mints 1.0 tokens
```

### Important Notes

1. **Mint Authority**: Only the mint authority can mint new tokens. For light-mints, authority must be a `Signer`

2. **Unified Interface**: `mintToInterface()` works with SPL, Token-2022, and Light Token programs based on mint type

3. **Validity Proof**: Light-mints require validity proof (merkle context). SPL/T22 mints do not

4. **Token Accounts**: Destination must be an existing token account of the correct type:
   - Light-mints → light token accounts (created with `createAtaInterface()`)
   - SPL/T22 mints → SPL/T22 token accounts (created with `createAssociatedTokenAccount()`)

5. **Network Selection**:
   - Devnet: Use Helius RPC with API key
   - Localnet: Use `createRpc()` with no arguments (requires `light test-validator`)

6. **Multiple Recipients**: For minting to multiple accounts, call `mintToInterface()` multiple times or batch instructions with the Instruction approach

~~~~
