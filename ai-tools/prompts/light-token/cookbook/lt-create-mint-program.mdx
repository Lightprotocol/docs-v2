---
argument-hint: <project_path>
description: Create light-token mint with metadata using Anchor framework
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Create light-token mint with metadata

Create a Solana program using Anchor that creates a light-token mint with token metadata.

References:
- Guide: https://zkcompression.com/light-token/cookbook/create-mint
- SDK Reference: https://docs.rs/light-token/latest/light_token/
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | SPL Token Mint | Light-Token Mint |
| --------- | -------------- | ---------------- |
| Storage | On-chain account (rent-exempt) | On-chain PDA + compressed address in tree |
| Rent Cost | User pays rent-exemption | Light token program sponsors rent |
| Creation | `create_mint()` | CPI to Light Token Program |
| Metadata | Token Metadata Program | Built-in token metadata extension |
| Authority | Mint authority can be PublicKey | Mint authority must be Signer for light-mints |
| Identifier | Mint address (PDA) | Mint PDA + compression address |

### Phase 1: Index project

```bash
find . -name "Cargo.toml" -o -name "lib.rs" -o -name "Anchor.toml"
```

### Phase 2: Add dependencies

Add to `programs/[name]/Cargo.toml`:

```toml
[dependencies]
light-token-sdk = "0.2.0"
light-token-interface = "0.7.0"
anchor_lang = "0.31.1"
```

### Phase 3: Implement program

See Code Reference below. Implementation follows these steps:

1. **Configure Token Metadata**: Set name, symbol, URI, update_authority, and optional additional_metadata
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/create_cmint.rs#L222-L233
2. **Configure Mint Parameters**: Set decimals, mint_authority, freeze_authority, compression_address, validity proof fields
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/create_cmint.rs#L214-L234
3. **System Accounts**: Include Light System Program accounts and state/address trees in `SystemAccountInfos`
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/create_cmint.rs#L530-L536
4. **Build Account Infos**: Create `CreateCMintCpi` with required accounts (mint_seed, authority, payer, trees)
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/create_cmint.rs#L541-L551
5. **CPI to Light Token Program**: Use `.invoke()` or `.invoke_signed()` based on signer type
   - invoke: When mint_seed is external keypair
   - invoke_signed: When mint_seed is PDA (requires seeds)
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/create_cmint.rs#L552

### Phase 4: Test

Build and test the program:

```bash
anchor build && anchor test
```

On failure, debug and retry. Assign always to subagents with Task tool.

## Code Reference

### Token Metadata Configuration

```rust
use light_token_interface::{
    instructions::extensions::{
        token_metadata::TokenMetadataInstructionData,
        ExtensionInstructionData,
    },
    state::AdditionalMetadata,
};

let token_metadata = ExtensionInstructionData::TokenMetadata(
    TokenMetadataInstructionData {
        update_authority: Some(authority.to_bytes().into()),
        name: b"My Token".to_vec(),
        symbol: b"MTK".to_vec(),
        uri: b"https://example.com/metadata.json".to_vec(),
        additional_metadata: Some(vec![
            AdditionalMetadata {
                key: b"category".to_vec(),
                value: b"utility".to_vec(),
            },
        ]),
    },
);
```

**Important**: Standard fields (`name`, `symbol`, `uri`) can be updated by `update_authority`. For `additional_metadata`, only existing keys can be modified or removed. New keys cannot be added after creation.

### Mint Configuration

```rust
use light_token_sdk::token::CreateCMintParams;

let params = CreateCMintParams {
    decimals: data.decimals,
    address_merkle_tree_root_index: data.address_merkle_tree_root_index,
    mint_authority: data.mint_authority,
    proof: data.proof,
    compression_address: data.compression_address,
    mint: data.mint,
    freeze_authority: data.freeze_authority,
    extensions: Some(vec![token_metadata]),
};
```

**Note**: The client passes a validity proof that proves the light-mint address does not exist in the address tree. The `compression_address` and `address_merkle_tree_root_index` fields are used for proof verification.

### System Accounts

```rust
use light_token_sdk::token::SystemAccountInfos;

let system_accounts = SystemAccountInfos {
    light_system_program: light_system_program.clone(),
    cpi_authority_pda: cpi_authority_pda.clone(),
    registered_program_pda: registered_program_pda.clone(),
    account_compression_authority: account_compression_authority.clone(),
    account_compression_program: account_compression_program.clone(),
    system_program: system_program.clone(),
};
```

### CPI Variants

#### invoke (External Keypair Signer)

```rust
use light_token_sdk::token::CreateCMintCpi;

CreateCMintCpi {
    mint_seed: mint_seed.clone(),
    authority: authority.clone(),
    payer: payer.clone(),
    address_tree: address_tree.clone(),
    output_queue: output_queue.clone(),
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    params,
}
.invoke()?;
```

#### invoke_signed (PDA Mint Seed)

```rust
use light_token_sdk::token::CreateCMintCpi;

let account_infos = CreateCMintCpi {
    mint_seed: mint_seed.clone(),
    authority: authority.clone(),
    payer: payer.clone(),
    address_tree: address_tree.clone(),
    output_queue: output_queue.clone(),
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    params,
};

let signer_seeds: &[&[u8]] = &[MINT_SIGNER_SEED, &[bump]];
account_infos.invoke_signed(&[signer_seeds])?;
```

#### invoke_signed (Two PDA Signers)

```rust
use light_token_sdk::token::CreateCMintCpi;

let account_infos = CreateCMintCpi {
    mint_seed: mint_seed.clone(),
    authority: authority.clone(),
    payer: payer.clone(),
    address_tree: address_tree.clone(),
    output_queue: output_queue.clone(),
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    params,
};

let mint_seed_seeds: &[&[u8]] = &[MINT_SIGNER_SEED, &[mint_seed_bump]];
let authority_seeds: &[&[u8]] = &[MINT_AUTHORITY_SEED, &[authority_bump]];
account_infos.invoke_signed(&[mint_seed_seeds, authority_seeds])?;
```

### Full Anchor Program Example

```rust
use borsh::{BorshDeserialize, BorshSerialize};
use light_token_sdk::{
    token::{
        CreateCMintCpi, CreateCMintParams, ExtensionInstructionData, SystemAccountInfos,
    },
    CompressedProof,
};
use solana_program::{account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey};

use crate::ID;

/// PDA seed for mint signer in invoke_signed variant
pub const MINT_SIGNER_SEED: &[u8] = b"mint_signer";

/// Instruction data for create compressed mint
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CreateCmintData {
    pub decimals: u8,
    pub address_merkle_tree_root_index: u16,
    pub mint_authority: Pubkey,
    pub proof: CompressedProof,
    pub compression_address: [u8; 32],
    pub mint: Pubkey,
    pub freeze_authority: Option<Pubkey>,
    pub extensions: Option<Vec<ExtensionInstructionData>>,
}

/// Handler for creating a compressed mint (invoke)
///
/// Uses the CreateCMintCpi builder pattern. This demonstrates how to:
/// 1. Build the CreateCMintParams struct from instruction data
/// 2. Build the CreateCMintCpi with accounts
/// 3. Call invoke() which handles instruction building and CPI
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: light_system_program
/// - accounts[2]: mint_seed (signer)
/// - accounts[3]: payer (signer, also authority)
/// - accounts[4]: payer again (fee_payer in SDK)
/// - accounts[5]: cpi_authority_pda
/// - accounts[6]: registered_program_pda
/// - accounts[7]: account_compression_authority
/// - accounts[8]: account_compression_program
/// - accounts[9]: system_program
/// - accounts[10]: output_queue
/// - accounts[11]: address_tree
/// - accounts[12] (optional): cpi_context_account
pub fn process_create_cmint(
    accounts: &[AccountInfo],
    data: CreateCmintData,
) -> Result<(), ProgramError> {
    if accounts.len() < 12 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Build the params
    let params = CreateCMintParams {
        decimals: data.decimals,
        address_merkle_tree_root_index: data.address_merkle_tree_root_index,
        mint_authority: data.mint_authority,
        proof: data.proof,
        compression_address: data.compression_address,
        mint: data.mint,
        freeze_authority: data.freeze_authority,
        extensions: data.extensions,
    };

    // Build system accounts struct
    let system_accounts = SystemAccountInfos {
        light_system_program: accounts[1].clone(),
        cpi_authority_pda: accounts[5].clone(),
        registered_program_pda: accounts[6].clone(),
        account_compression_authority: accounts[7].clone(),
        account_compression_program: accounts[8].clone(),
        system_program: accounts[9].clone(),
    };

    // Build the account infos struct
    // In this case, payer == authority (accounts[3])
    CreateCMintCpi {
        mint_seed: accounts[2].clone(),
        authority: accounts[3].clone(),
        payer: accounts[3].clone(),
        address_tree: accounts[11].clone(),
        output_queue: accounts[10].clone(),
        system_accounts,
        cpi_context: None,
        cpi_context_account: None,
        params,
    }
    .invoke()?;

    Ok(())
}

/// Handler for creating a compressed mint with PDA mint seed (invoke_signed)
///
/// Uses the CreateCMintCpi builder pattern with invoke_signed.
/// The mint_seed is a PDA derived from this program.
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: light_system_program
/// - accounts[2]: mint_seed (PDA, not signer - program signs)
/// - accounts[3]: payer (signer, also authority)
/// - accounts[4]: payer again (fee_payer in SDK)
/// - accounts[5]: cpi_authority_pda
/// - accounts[6]: registered_program_pda
/// - accounts[7]: account_compression_authority
/// - accounts[8]: account_compression_program
/// - accounts[9]: system_program
/// - accounts[10]: output_queue
/// - accounts[11]: address_tree
/// - accounts[12] (optional): cpi_context_account
pub fn process_create_cmint_invoke_signed(
    accounts: &[AccountInfo],
    data: CreateCmintData,
) -> Result<(), ProgramError> {
    if accounts.len() < 12 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the mint seed
    let (pda, bump) = Pubkey::find_program_address(&[MINT_SIGNER_SEED], &ID);

    // Verify the mint_seed account is the PDA we expect
    if &pda != accounts[2].key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Build the params
    let params = CreateCMintParams {
        decimals: data.decimals,
        address_merkle_tree_root_index: data.address_merkle_tree_root_index,
        mint_authority: data.mint_authority,
        proof: data.proof,
        compression_address: data.compression_address,
        mint: data.mint,
        freeze_authority: data.freeze_authority,
        extensions: data.extensions,
    };

    // Build system accounts struct
    let system_accounts = SystemAccountInfos {
        light_system_program: accounts[1].clone(),
        cpi_authority_pda: accounts[5].clone(),
        registered_program_pda: accounts[6].clone(),
        account_compression_authority: accounts[7].clone(),
        account_compression_program: accounts[8].clone(),
        system_program: accounts[9].clone(),
    };

    // Build the account infos struct
    // In this case, payer == authority (accounts[3])
    let account_infos = CreateCMintCpi {
        mint_seed: accounts[2].clone(),
        authority: accounts[3].clone(),
        payer: accounts[3].clone(),
        address_tree: accounts[11].clone(),
        output_queue: accounts[10].clone(),
        system_accounts,
        cpi_context: None,
        cpi_context_account: None,
        params,
    };

    // Invoke with PDA signing
    let signer_seeds: &[&[u8]] = &[MINT_SIGNER_SEED, &[bump]];
    account_infos.invoke_signed(&[signer_seeds])?;

    Ok(())
}

/// Handler for creating a compressed mint with PDA mint seed AND PDA authority (invoke_signed)
///
/// Uses the SDK's CreateCMintCpi with separate authority and payer accounts.
/// Both mint_seed and authority are PDAs signed by this program.
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: light_system_program
/// - accounts[2]: mint_seed (PDA from MINT_SIGNER_SEED, not signer - program signs)
/// - accounts[3]: authority (PDA from MINT_AUTHORITY_SEED, not signer - program signs)
/// - accounts[4]: fee_payer (signer)
/// - accounts[5]: cpi_authority_pda
/// - accounts[6]: registered_program_pda
/// - accounts[7]: account_compression_authority
/// - accounts[8]: account_compression_program
/// - accounts[9]: system_program
/// - accounts[10]: output_queue
/// - accounts[11]: address_tree
/// - accounts[12] (optional): cpi_context_account
pub fn process_create_cmint_with_pda_authority(
    accounts: &[AccountInfo],
    data: CreateCmintData,
) -> Result<(), ProgramError> {
    use crate::mint_to::MINT_AUTHORITY_SEED;

    if accounts.len() < 12 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the mint seed
    let (mint_seed_pda, mint_seed_bump) =
        Pubkey::find_program_address(&[MINT_SIGNER_SEED], &ID);

    // Derive the PDA for the authority
    let (authority_pda, authority_bump) = Pubkey::find_program_address(&[MINT_AUTHORITY_SEED], &ID);

    // Verify the mint_seed account is the PDA we expect
    if &mint_seed_pda != accounts[2].key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Verify the authority account is the PDA we expect
    if &authority_pda != accounts[3].key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Build the params - authority is the PDA
    let params = CreateCMintParams {
        decimals: data.decimals,
        address_merkle_tree_root_index: data.address_merkle_tree_root_index,
        mint_authority: authority_pda, // Use the derived PDA as authority
        proof: data.proof,
        compression_address: data.compression_address,
        mint: data.mint,
        freeze_authority: data.freeze_authority,
        extensions: data.extensions,
    };

    // Build system accounts struct
    let system_accounts = SystemAccountInfos {
        light_system_program: accounts[1].clone(),
        cpi_authority_pda: accounts[5].clone(),
        registered_program_pda: accounts[6].clone(),
        account_compression_authority: accounts[7].clone(),
        account_compression_program: accounts[8].clone(),
        system_program: accounts[9].clone(),
    };

    // Build the account infos struct using SDK
    let account_infos = CreateCMintCpi {
        mint_seed: accounts[2].clone(),
        authority: accounts[3].clone(),
        payer: accounts[4].clone(),
        address_tree: accounts[11].clone(),
        output_queue: accounts[10].clone(),
        system_accounts,
        cpi_context: None,
        cpi_context_account: None,
        params,
    };

    // Invoke with both PDAs signing
    let mint_seed_seeds: &[&[u8]] = &[MINT_SIGNER_SEED, &[mint_seed_bump]];
    let authority_seeds: &[&[u8]] = &[MINT_AUTHORITY_SEED, &[authority_bump]];
    account_infos.invoke_signed(&[mint_seed_seeds, authority_seeds])?;

    Ok(())
}
```

## Key Concepts

### Light-Token Mint vs SPL Mint

**SPL Token Mint:**
- Stored directly on-chain in mint account
- Requires rent payment from user
- Metadata handled by separate Token Metadata Program
- Mint authority can be PublicKey or Signer

**Light-Token Mint:**
- Mint PDA stored on-chain, compression address stored in address tree
- Light token program sponsors rent-exemption cost
- Built-in token metadata extension
- Mint authority must be Signer for light-mints
- No rent cost for developers or users

### Core Components

1. **Token Metadata Extension**: Built-in metadata support
   - Standard fields: `name`, `symbol`, `uri`, `update_authority`
   - `additional_metadata`: Key-value pairs set at creation
   - Standard fields updatable by `update_authority`
   - Additional metadata keys cannot be added after creation

2. **CreateCMintParams**: Mint configuration
   - `decimals`: Token decimal places (0-9)
   - `mint_authority`: Authority that can mint tokens (must be Signer)
   - `freeze_authority`: Optional authority to freeze token accounts
   - `extensions`: Token metadata and other extensions
   - `compression_address`: Derived address in address tree
   - `proof`: Validity proof from RPC proving address doesn't exist

3. **SystemAccountInfos**: Light System Program accounts
   - `light_system_program`: Main compression program
   - `cpi_authority_pda`: CPI authorization PDA
   - `registered_program_pda`: Program registration account
   - `account_compression_authority`: Compression authority
   - `account_compression_program`: Account compression program
   - `system_program`: Solana system program

4. **CreateCMintCpi**: Builder pattern for CPI
   - `mint_seed`: Keypair or PDA for mint derivation
   - `authority`: Mint authority (must be Signer)
   - `payer`: Fee payer account
   - `address_tree`: Address tree for compression address
   - `output_queue`: State tree output queue
   - `.invoke()`: For external keypair signers
   - `.invoke_signed()`: For PDA signers

5. **Validity Proof**: Zero-knowledge proof
   - Proves the derived mint address doesn't exist in address tree
   - Fetched with `getValidityProof()` RPC method
   - Verified by Light System Program during mint creation

### Mint Derivation

1. **Compression Address**: Derives address in address tree
   ```rust
   let compression_address = light_token_sdk::token::derive_cmint_compressed_address(
       &mint_signer.pubkey(),
       &address_tree.tree,
   );
   ```

2. **Mint PDA**: On-chain account storing mint data
   ```rust
   let mint_pda = light_token_sdk::token::find_cmint_address(&mint_signer.pubkey()).0;
   ```

### Security

- **Authority validation**: Mint authority must be valid Signer
- **Proof verification**: Light System Program validates ZK proof
- **PDA verification**: When using PDAs, verify derived address matches expected
- **Tree validation**: Ensure address tree is correct for your application

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `ProgramError::InvalidSeeds` | PDA derivation mismatch | Verify PDA seeds match expected derivation |
| `ProgramError::NotEnoughAccountKeys` | Missing required accounts | Check all 12+ accounts are provided |
| `ProgramError::InvalidAccountData` | Invalid proof or tree | Verify validity proof and address tree are correct |
| Authority not Signer | Light-mint requires Signer authority | Ensure mint_authority is marked as Signer |
| Metadata update failure | Attempting to add new keys | Only existing additional_metadata keys can be modified |
