~~~~text
---
argument-hint: <project_path>
description: Mint tokens to light token accounts in Rust
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Mint tokens to light token accounts (Rust)

References:
- Cookbook Guide: https://zkcompression.com/light-token/cookbook/mint-to
- SDK Reference: https://docs.rs/light-token-sdk/latest/light_token_sdk/
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Type/Function | Purpose |
|-----------|---------------|---------|
| Connect | LightClient::new_with_retry() | Connect to ZK Compression RPC endpoint |
| Get Account | get_compressed_account() | Fetch compressed mint account data |
| Get Validity Proof | get_validity_proof() | Get proof that mint exists |
| Deserialize Mint | CompressedMint::deserialize() | Parse mint account data |
| Build Context | CompressedMintWithContext | Package mint data with proof |
| Build Params | MintToParams::new() | Configure minting parameters |
| Build Instruction | MintTo::new().instruction() | Build instruction with all accounts |
| Send Transaction | create_and_send_transaction() | Submit transaction to network |

### Phase 1: Index project

```bash
grep -r "light_token_sdk\|light_client\|solana_sdk" src/
```

### Phase 2: Add dependencies

```toml
[dependencies]
light-client = "0.13.0"
light-token-sdk = "0.1.0"
light-token-interface = "0.1.0"
solana-sdk = "2.1.6"
borsh = "1.5"
tokio = { version = "1.41", features = ["full"] }
dotenvy = "0.15"
serde_json = "1.0"
bs58 = "0.5"
```

### Phase 3: Implement token minting

See Code Reference below for Rust implementation.

1. **RPC Setup**: Connect to ZK Compression RPC endpoint (Helius, Triton, or localnet)
   - Use `LightClientConfig::devnet()` or `LightClientConfig::mainnet()` with RPC URL and API key
   - Use `LightClient::new_with_retry()` to initialize client
   - For localnet: Configure with localhost URL

2. **Create Mint and Token Account** (Prerequisites):
   - Create compressed mint with `CreateCMint::new()`
   - Create token account with `CreateTokenAccount::new()`
   - Send transactions to network
   - Store mint PDA and compression address

3. **Fetch Compressed Mint**: Get mint account data and metadata
   - Use `rpc.get_compressed_account(compression_address, None)` to fetch account
   - Extract `tree_info` (tree and queue pubkeys)
   - Extract `leaf_index` for proof
   - Extract `hash` for validity proof

4. **Get Validity Proof**: Prove mint exists in state tree
   - Use `rpc.get_validity_proof(vec![compressed_mint_hash], vec![], None)`
   - Pass mint account hash in first argument
   - Returns proof and root index for instruction

5. **Deserialize Mint Data**: Parse compressed mint account
   - Use `CompressedMint::deserialize(&mut data.as_slice())`
   - Extract mint configuration (decimals, authorities)
   - Needed for `CompressedMintWithContext`

6. **Build CompressedMintWithContext**: Package mint with proof metadata
   - Set `address` to compression address
   - Set `leaf_index` from compressed account
   - Set `prove_by_index` to false
   - Set `root_index` from validity proof result
   - Convert `CompressedMint` to required type with `try_into()`

7. **Get Output Queue**: Fetch active state tree for minting
   - Use `rpc.get_latest_active_state_trees()` to fetch trees
   - Use `get_random_state_tree_info()` to select tree
   - Extract output queue pubkey with `get_output_pubkey()`
   - Fallback to `get_queue_info()` if state trees unavailable

8. **Build MintToParams**: Configure minting parameters
   - Call `MintToParams::new(compressed_mint_with_context, amount, mint_authority, proof)`
   - `amount` includes decimals (e.g., 1_000_000_000 for 1 token with 9 decimals)
   - `mint_authority` must match mint's mint authority
   - `proof` from validity proof result

9. **Build Instruction**: Create instruction with all accounts
   - Call `MintTo::new(params, payer, state_tree, input_queue, output_queue, token_accounts)`
   - `state_tree` from compressed mint's tree_info
   - `input_queue` from compressed mint's tree_info
   - `output_queue` from state tree selection
   - `token_accounts` is vec of destination token account pubkeys
   - Call `.instruction()` to build

10. **Send Transaction**: Sign and submit to network
    - Optionally add compute budget instruction
    - Use `rpc.create_and_send_transaction(&[instructions], &payer, &[&payer])`
    - Returns transaction signature on success
    - Verify with `rpc.get_account()` to check token balance

### Phase 4: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

## Code Reference

### Complete Mint To Example

```rust
use borsh::BorshDeserialize;
use light_client::indexer::{AddressWithTree, Indexer};
use light_client::rpc::{LightClient, LightClientConfig, Rpc};
use light_token_sdk::token::{
    CreateCMint, CreateCMintParams, CreateTokenAccount, MintTo, MintToParams,
};
use light_token_interface::instructions::extensions::token_metadata::TokenMetadataInstructionData;
use solana_sdk::compute_budget::ComputeBudgetInstruction;
use light_token_interface::instructions::extensions::ExtensionInstructionData;
use light_token_interface::instructions::mint_action::CompressedMintWithContext;
use light_token_interface::state::{AdditionalMetadata, Token, CompressedMint};
use serde_json;
use solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer};
use std::convert::TryFrom;
use std::env;
use std::fs;

#[tokio::test(flavor = "multi_thread")]
async fn test_mint_to_token() {
    dotenvy::dotenv().ok();

    let keypair_path = env::var("KEYPAIR_PATH")
        .unwrap_or_else(|_| format!("{}/.config/solana/id.json", env::var("HOME").unwrap()));
    let payer = load_keypair(&keypair_path).expect("Failed to load keypair");
    let mint_authority = payer.pubkey();

    let api_key = env::var("api_key") // Set api_key in your .env
        .expect("api_key environment variable must be set");

    let config = LightClientConfig::devnet(
        Some("https://devnet.helius-rpc.com".to_string()),
        Some(api_key),
    );
    let mut rpc = LightClient::new_with_retry(config, None)
        .await
        .expect("Failed to initialize LightClient");

    // Step 1: Create compressed mint with metadata
    let (mint, compression_address) = create_compressed_mint(&mut rpc, &payer, 9).await;

    // Step 2: Create token account
    let token_account = Keypair::new();
    let owner = payer.pubkey();
    let create_account_ix =
        CreateTokenAccount::new(payer.pubkey(), token_account.pubkey(), mint, owner)
            .instruction()
            .unwrap();

    rpc.create_and_send_transaction(
        &[create_account_ix],
        &payer.pubkey(),
        &[&payer, &token_account],
    )
    .await
    .unwrap();

    // Step 3: Get compressed mint account to build CompressedMintWithContext
    let compressed_mint_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value
        .expect("Compressed mint should exist");

    // Step 4: Get validity proof for the mint operation
    let rpc_result = rpc
        .get_validity_proof(vec![compressed_mint_account.hash], vec![], None)
        .await
        .unwrap()
        .value;

    // Step 5: Deserialize compressed mint data
    let compressed_mint = CompressedMint::deserialize(
        &mut compressed_mint_account.data.unwrap().data.as_slice(),
    )
    .unwrap();

    // Step 6: Build CompressedMintWithContext
    let compressed_mint_with_context = CompressedMintWithContext {
        address: compression_address,
        leaf_index: compressed_mint_account.leaf_index,
        prove_by_index: false,
        root_index: rpc_result.accounts[0]
            .root_index
            .root_index()
            .unwrap_or_default(),
        mint: compressed_mint.try_into().unwrap(),
    };

    let amount = 1_000_000_000u64; // 1 token with 9 decimals

    // Step 7: Get active output queue for devnet
    let _ = rpc.get_latest_active_state_trees().await;
    let output_queue = match rpc
        .get_random_state_tree_info()
        .ok()
        .or_else(|| rpc.get_random_state_tree_info_v1().ok())
    {
        Some(info) => info
            .get_output_pubkey()
            .expect("Invalid state tree type for output"),
        None => {
            let queues = rpc
                .indexer_mut()
                .expect("IndexerNotInitialized")
                .get_queue_info(None)
                .await
                .expect("Failed to fetch queue info")
                .value
                .queues;
            queues
                .get(0)
                .map(|q| q.queue)
                .expect("NoStateTreesAvailable: no active state trees returned")
        }
    };

    // Step 8: Build mint params
    let params = MintToParams::new(
        compressed_mint_with_context,
        amount,
        mint_authority,
        rpc_result.proof,
    );

    // Step 9: Build instruction using SDK builder
    let instruction = MintTo::new(
        params,
        payer.pubkey(),
        compressed_mint_account.tree_info.tree,
        compressed_mint_account.tree_info.queue,
        output_queue,
        vec![token_account.pubkey()],
    )
    .instruction()
    .unwrap();

    // Step 10: Send transaction
    let compute_unit_ix = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    rpc.create_and_send_transaction(&[compute_unit_ix, instruction], &payer.pubkey(), &[&payer])
        .await
        .unwrap();

    // Step 11: Verify tokens were minted
    let token_account_data = rpc
        .get_account(token_account.pubkey())
        .await
        .unwrap()
        .unwrap();

    let token_state = Token::deserialize(&mut &token_account_data.data[..]).unwrap();
    assert_eq!(token_state.amount, amount, "Token amount should match");
    assert_eq!(token_state.mint, mint.to_bytes(), "Mint should match");
    assert_eq!(token_state.owner, owner.to_bytes(), "Owner should match");

    println!("\n=== Minted Tokens ===");
    println!("Token Account: {}", token_account.pubkey());
    println!("Amount: {} (raw: {})", amount as f64 / 1_000_000_000.0, amount);
    println!("Mint: {}", mint);
}

pub async fn create_compressed_mint<R: Rpc + Indexer>(
    rpc: &mut R,
    payer: &Keypair,
    decimals: u8,
) -> (Pubkey, [u8; 32]) {
    let mint_signer = Keypair::new();
    let address_tree = rpc.get_address_tree_v2();

    // Fetch active state trees for devnet
    let _ = rpc.get_latest_active_state_trees().await;
    let output_pubkey = match rpc
        .get_random_state_tree_info()
        .ok()
        .or_else(|| rpc.get_random_state_tree_info_v1().ok())
    {
        Some(info) => info
            .get_output_pubkey()
            .expect("Invalid state tree type for output"),
        None => {
            let queues = rpc
                .indexer_mut()
                .expect("IndexerNotInitialized")
                .get_queue_info(None)
                .await
                .expect("Failed to fetch queue info")
                .value
                .queues;
            queues
                .get(0)
                .map(|q| q.queue)
                .expect("NoStateTreesAvailable: no active state trees returned")
        }
    };

    // Derive compression address
    let compression_address = light_token_sdk::token::derive_cmint_compressed_address(
        &mint_signer.pubkey(),
        &address_tree.tree,
    );

    let mint_pda = light_token_sdk::token::find_cmint_address(&mint_signer.pubkey()).0;

    // Get validity proof for the address
    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    // Build params with token metadata
    let params = CreateCMintParams {
        decimals,
        address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
        mint_authority: payer.pubkey(),
        proof: rpc_result.proof.0.unwrap(),
        compression_address,
        mint: mint_pda,
        freeze_authority: None,
        extensions: Some(vec![ExtensionInstructionData::TokenMetadata(
            TokenMetadataInstructionData {
                update_authority: Some(payer.pubkey().to_bytes().into()),
                name: b"Example Token".to_vec(),
                symbol: b"EXT".to_vec(),
                uri: b"https://example.com/metadata.json".to_vec(),
                additional_metadata: Some(vec![AdditionalMetadata {
                    key: b"type".to_vec(),
                    value: b"compressed".to_vec(),
                }]),
            },
        )]),
    };

    // Create instruction
    let create_cmint = CreateCMint::new(
        params,
        mint_signer.pubkey(),
        payer.pubkey(),
        address_tree.tree,
        output_pubkey,
    );
    let instruction = create_cmint.instruction().unwrap();

    // Send transaction
    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[payer, &mint_signer])
        .await
        .unwrap();

    (mint_pda, compression_address)
}

fn load_keypair(path: &str) -> Result<Keypair, Box<dyn std::error::Error>> {
    let path = if path.starts_with("~") {
        path.replace("~", &env::var("HOME").unwrap_or_default())
    } else {
        path.to_string()
    };
    let file = fs::read_to_string(&path)?;
    let bytes: Vec<u8> = serde_json::from_str(&file)?;
    Ok(Keypair::try_from(&bytes[..])?)
}
```

### MintTo Builder Pattern

The MintTo builder constructs the instruction with all required accounts:

```rust
use light_token_sdk::token::{MintTo, MintToParams};

let params = MintToParams::new(
    compressed_mint_with_context,  // Mint with proof metadata
    amount,                         // Amount including decimals
    mint_authority,                 // Must match mint's mint_authority
    validity_proof,                 // Proof from get_validity_proof
);

let instruction = MintTo::new(
    params,                         // Minting parameters
    payer.pubkey(),                 // Fee payer
    state_tree,                     // From compressed_mint_account.tree_info.tree
    input_queue,                    // From compressed_mint_account.tree_info.queue
    output_queue,                   // From active state tree selection
    vec![token_account.pubkey()],   // Destination token accounts
)
.instruction()?;
```

### CompressedMintWithContext

Package compressed mint data with proof metadata:

```rust
use light_token_interface::instructions::mint_action::CompressedMintWithContext;
use light_token_interface::state::CompressedMint;

let compressed_mint_with_context = CompressedMintWithContext {
    address: compression_address,           // 32-byte compression address
    leaf_index: compressed_mint_account.leaf_index,  // Position in tree
    prove_by_index: false,                  // Use hash-based proof
    root_index: rpc_result.accounts[0]      // Root index from proof
        .root_index
        .root_index()
        .unwrap_or_default(),
    mint: compressed_mint.try_into().unwrap(),  // Convert CompressedMint
};
```

### Validity Proof for Mint

Prove the mint exists in the state tree:

```rust
// Get compressed mint account
let compressed_mint_account = rpc
    .get_compressed_account(compression_address, None)
    .await?
    .value
    .expect("Compressed mint should exist");

// Get validity proof
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_mint_account.hash],  // Mint account hash
        vec![],                               // No addresses
        None,
    )
    .await?
    .value;

// Use proof in params
let params = MintToParams::new(
    compressed_mint_with_context,
    amount,
    mint_authority,
    rpc_result.proof,  // Validity proof
);
```

### Important Notes

1. **Compressed Mint**: Light mints are compressed accounts stored in state trees. Every mint operation requires a validity proof to verify the mint exists.

2. **CompressedMintWithContext**: Packages mint data, leaf position, root index, and proof type. Required for MintToParams.

3. **Amount with Decimals**: Amount must include decimals (e.g., 1_000_000_000 for 1 token with 9 decimals).

4. **Mint Authority**: Only the mint authority can mint tokens. Authority must sign the transaction or be a PDA with invoke_signed.

5. **State Trees**: Minting requires two trees - the input tree (where mint lives) and output tree (for state updates). Use active trees from RPC.

6. **Queue Selection**: Output queue comes from active state tree selection. Code shows fallback logic for v2 and v1 tree formats.

7. **Compute Budget**: Minting may require higher compute units. Use ComputeBudgetInstruction if needed.

8. **Batch Minting**: Pass multiple token account pubkeys in the vec to mint to multiple accounts in one transaction.

9. **Token Account Type**: Destination must be a light token account (on-chain account), not compressed token account.

10. **Verification**: After minting, fetch token account with `get_account()` and deserialize to verify balance.

### Environment Setup

Create a `.env` file with your configuration:

```bash
# API key for Helius RPC (devnet or mainnet)
api_key=your_api_key_here

# Optional: Custom keypair path
KEYPAIR_PATH=~/.config/solana/id.json
```

### Testing

Run the example with:

```bash
cargo test test_mint_to_token -- --nocapture
```

Or create a binary example in `examples/mint_to.rs`:

```rust
#[tokio::main]
async fn main() {
    // Copy the test code here but remove #[tokio::test] attribute
}
```

Then run:

```bash
cargo run --example mint_to
```

~~~~
