~~~~text
---
argument-hint: <project_path>
description: Load token balances to light ATA (Program CPI - Not Supported)
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Load token balances to light ATA (Program CPI)

Loading token balances to a light ATA is not supported via program CPI.

The `load_ata()` operation requires querying compressed token accounts and fetching validity proofs from the RPC indexer. These operations cannot be performed from within a Solana program because:

1. **RPC Queries Required**: Must query `get_compressed_token_accounts_by_owner()` to find accounts to load
2. **Proof Generation**: Must fetch validity proofs via RPC before building instructions
3. **Account Discovery**: Cannot dynamically discover compressed accounts on-chain
4. **Multi-Step Process**: Requires client-side coordination of query, proof, and transaction

Load ATA is only available through client SDKs:
1. **TypeScript Client SDK** - Use `@lightprotocol/compressed-token` with `loadAta()` action
2. **Rust Client SDK** - Use `light-client` with `Decompress` instruction builder

References:
- Cookbook Guide: https://zkcompression.com/light-token/cookbook/load-ata
- TypeScript SDK: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- Rust SDK: https://docs.rs/light-token/latest/light_token/

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Why Program CPI is Not Supported

### Load ATA Operation Overview

The `load_ata()` operation consolidates token balances from multiple sources into a single light Associated Token Account (ATA):

1. **Compressed tokens (cold storage)**: Decompresses to light ATA hot balance
2. **SPL token balance** (optional): Wraps to light ATA
3. **Token-2022 balance** (optional): Wraps to light ATA

### Client-Side Requirements

Load ATA requires operations that programs cannot perform:

| Requirement | Why Programs Cannot Do This |
|-------------|----------------------------|
| Query compressed accounts | Programs cannot call RPC methods |
| Fetch validity proofs | Proof generation happens off-chain via indexer |
| Discover account hashes | Compressed account discovery requires RPC queries |
| Build dynamic instruction sets | Account list varies per user, cannot be known at program execution |

### What Programs CAN Do

While load ATA is not available, programs can perform individual operations:

1. **Decompress** - Use `DecompressCpi` from `light-token-sdk`
   - Requires client to provide compressed accounts and proof
   - Client must query accounts and generate proof beforehand

2. **Wrap** - Use `WrapCpi` from `light-token-sdk`
   - Wraps SPL tokens to light tokens
   - Client specifies source and destination accounts

3. **Create ATA** - Use `CreateAssociatedTokenAccountCpi`
   - Creates light ATA if it doesn't exist
   - Client specifies mint and owner

## Client-Side Solutions

### Option 1: TypeScript Client SDK (Recommended)

Use the TypeScript SDK for web/Node.js applications:

**Prompt Path**:
`/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-load-ata-client-typescript.mdx`

**Quick Example**:

```typescript
import { createRpc } from "@lightprotocol/stateless.js";
import {
    loadAta,
    getAssociatedTokenAddressInterface,
} from "@lightprotocol/compressed-token";

const rpc = createRpc("https://devnet.helius-rpc.com?api-key=YOUR_KEY");
const lightAta = getAssociatedTokenAddressInterface(mint, owner);

// Automatically queries accounts, fetches proofs, and loads tokens
const signature = await loadAta(rpc, lightAta, payer, mint);
console.log("Loaded tokens:", signature);
```

**Features**:
- High-level `loadAta()` action - handles all complexity
- Low-level `createLoadAtaInstructions()` - for manual control
- Automatic account discovery and proof fetching
- Idempotent - safe to call multiple times

### Option 2: Rust Client SDK

Use the Rust SDK for CLI tools or backend services:

**Prompt Path**:
`/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-load-ata-client-rust.mdx`

**Quick Example**:

```rust
use light_client::rpc::{LightClient, Rpc};
use light_client::indexer::Indexer;
use light_token_client::actions::Decompress;

// Query compressed accounts
let accounts = rpc
    .get_compressed_token_accounts_by_owner(&owner)
    .await?
    .value
    .items
    .into_iter()
    .filter(|acc| acc.parsed.mint == mint)
    .collect();

// Fetch validity proof
let proof = rpc.get_validity_proof(hashes, vec![], None).await?;

// Build and send decompress instruction
let ix = Decompress::new(
    payer.pubkey(),
    accounts,
    light_ata,
    total_amount,
    proof.proof.0.unwrap(),
    proof.root_indices,
).instruction()?;
```

**Features**:
- Full control over each step
- Efficient for batch operations
- Direct integration with Rust programs (off-chain)

## Alternative: Hybrid Approach

If you need to trigger load operations from a program, use this pattern:

```
Client → Custom Program → Emit Event → Off-chain Service → Load ATA
```

**Architecture**:

1. **Custom Program**: Emit a custom event when load is needed
2. **Off-chain Service**: Listen for events and call client SDK
3. **Client SDK**: Execute `loadAta()` when event detected

**Example Event**:

```rust
#[event]
pub struct LoadAtaRequest {
    pub owner: Pubkey,
    pub mint: Pubkey,
    pub timestamp: i64,
}
```

**Benefits**:
- Decouple on-chain logic from RPC queries
- Program can signal intent without blocking
- Off-chain service handles complexity

## Understanding Token States

Load ATA moves tokens between different states:

### Cold Storage (Compressed)

**Characteristics**:
- Stored in Merkle trees (state trees)
- Zero rent cost - completely free
- Requires ZK proofs for operations
- Cannot be used in standard SPL transfers

**When to Use**:
- Long-term storage
- Infrequently accessed balances
- Maximum cost efficiency

### Hot Balance (Light ATA)

**Characteristics**:
- Standard token account format
- Small rent cost (~0.002 SOL)
- No proofs needed for transfers
- Fast, immediate operations

**When to Use**:
- Active trading/transfers
- User-facing balances
- Immediate accessibility needed

### Load ATA Operation

Moves tokens from cold (compressed) to hot (light ATA):

```
Before Load:
├─ Compressed Token Accounts (cold): 1000 tokens
└─ Light ATA (hot): 0 tokens

After Load:
├─ Compressed Token Accounts (cold): 0 tokens
└─ Light ATA (hot): 1000 tokens
```

## Common Use Cases

### 1. After Minting

```
Mint → Cold Storage → Load ATA → Hot Balance → Transfers
```

Tokens are minted directly to cold storage (rent-free), then loaded to hot balance when needed.

### 2. Unified Balance View

```
Cold Storage (500)  ──┐
SPL Balance (300)   ──┼─→ Load ATA → Light ATA (1000)
Token-2022 (200)    ──┘
```

Consolidates all token sources into a single light ATA for unified view.

### 3. Before Trading

```
User has tokens in cold storage
↓
Load to hot balance (one-time operation)
↓
Enable fast transfers without proofs
```

## Workaround for Programs

If you must interact with compressed tokens from a program:

### Step 1: Client Prepares Accounts

Off-chain client:
1. Queries compressed token accounts
2. Fetches validity proof
3. Passes accounts and proof to program

### Step 2: Program Uses Decompress CPI

```rust
use light_token_sdk::token::{DecompressCpi, DecompressParams};

// Client provides these as instruction data
let compressed_accounts = ctx.accounts.compressed_accounts;
let proof = ctx.accounts.proof;

// Program performs decompress via CPI
DecompressCpi {
    authority: ctx.accounts.authority.clone(),
    destination: ctx.accounts.light_ata.clone(),
    token_program: ctx.accounts.token_program.clone(),
    // ... other accounts
    params: DecompressParams {
        amount,
        proof,
        root_indices,
        compressed_accounts,
    },
}.invoke()?;
```

**Limitations**:
- Client must provide all data upfront
- Cannot dynamically query accounts from program
- More complex client-side setup

## Quick Reference

| Operation | TypeScript | Rust | Program CPI |
|-----------|-----------|------|-------------|
| Load ATA (All-in-One) | `loadAta()` | Manual composition | ❌ Not available |
| Load ATA (Instructions) | `createLoadAtaInstructions()` | Manual composition | ❌ Not available |
| Query Compressed Accounts | `rpc.getCompressedTokenAccountsByOwner()` | `rpc.get_compressed_token_accounts_by_owner()` | ❌ Cannot query |
| Fetch Proof | Auto (in action) | `rpc.get_validity_proof()` | ❌ Cannot fetch |
| Decompress | Auto (in action) | `Decompress::new()` | ✅ `DecompressCpi` |
| Wrap SPL | Auto (with `wrap=true`) | `Wrap::new()` | ✅ `WrapCpi` |
| Create ATA | Auto (if needed) | `CreateAssociatedTokenAccount::new()` | ✅ `CreateAssociatedTokenAccountCpi` |

## Next Steps

1. **Use TypeScript SDK** if building web/Node.js applications
   - See: `/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-load-ata-client-typescript.mdx`

2. **Use Rust SDK** if building CLI tools or backend services
   - See: `/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-load-ata-client-rust.mdx`

3. **Use Hybrid Approach** if you need program integration
   - Emit events from program
   - Handle load operations off-chain

## Related Operations

Available via Program CPI:
- **Decompress**: `/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-decompress-program.mdx`
- **Wrap**: `/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-wrap-unwrap-program.mdx`
- **Create ATA**: `/home/tilo/Workspace/ai-tools/prompts/light-token/cookbook/lt-create-ata-program.mdx`

Available via Client SDK only:
- **Load ATA**: This operation (client-side only)

## Understanding the Limitation

Programs operate in a **stateless execution environment**:

1. **No persistent state** between instructions
2. **No network access** to query external data
3. **No dynamic account discovery** - all accounts must be provided upfront
4. **No proof generation** - proofs are created off-chain

Load ATA requires **dynamic discovery and coordination**:

1. Query which compressed accounts exist (RPC call)
2. Calculate total balance across accounts (off-chain computation)
3. Fetch validity proofs (indexer query)
4. Build transaction with dynamic account list

This is fundamentally a **client-side orchestration** task, not an on-chain operation.

## Error Messages

If you attempt to call load ATA from a program:

```
Error: Function 'loadAta' is not available in program context
```
→ Use client SDK instead

```
Error: Cannot query RPC from program
```
→ Programs cannot make external RPC calls

```
Error: Compressed accounts must be provided as instruction data
```
→ Client must query and pass accounts to program

## Summary

**Load ATA is a client-side operation** that:

1. Queries compressed token accounts via RPC
2. Fetches validity proofs from indexer
3. Builds decompress instructions dynamically
4. Optionally wraps SPL/Token-2022 balances

**Use client SDKs**:
- TypeScript: `loadAta()` action or `createLoadAtaInstructions()`
- Rust: Compose `Decompress` and `Wrap` instructions manually

**Programs can**:
- Use `DecompressCpi` if client provides accounts and proofs
- Use `WrapCpi` to wrap SPL tokens
- Emit events to trigger off-chain load operations

For implementation guidance, see the client-side prompts listed above.

~~~~
