~~~~text
---
argument-hint: <project_path>
description: Create light-token mint with Token-2022 extensions in TypeScript
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Create light-token mint with Token-2022 extensions (TypeScript)

References:
- Cookbook Guide: https://zkcompression.com/light-token/cookbook/create-mint
- Extensions Table: https://zkcompression.com/light-token/cookbook/extensions
- SDK Reference: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

### Supported Extensions

| Extension | Light-Token | Note |
|-----------|-------------|------|
| MetadataPointer | ✓ | Supported via createTokenMetadata() |
| TokenMetadata | ✓ | Supported via createTokenMetadata() |
| InterestBearingConfig | ✓ | Supported |
| GroupPointer | ✓ | Supported |
| GroupMemberPointer | ✓ | Supported |
| TokenGroup | ✓ | Supported |
| TokenGroupMember | ✓ | Supported |
| MintCloseAuthority | ✓ | Supported |
| TransferFeeConfig | ✓ | Fees must be zero |
| DefaultAccountState | ✓ | Any state allowed |
| PermanentDelegate | ✓ | Supported |
| TransferHook | ✓ | program_id must be nil |
| Pausable | ✓ | Supported |
| ConfidentialTransferMint | ✓ | Initialized but not enabled |
| ConfidentialTransferFeeConfig | ✓ | Fees must be zero |
| ConfidentialMintBurn | ✓ | Initialized but not enabled |

### Primary Extension: TokenMetadata

The TokenMetadata extension is configured via `createTokenMetadata()`:

```typescript
import { createTokenMetadata } from "@lightprotocol/compressed-token";

const metadata = createTokenMetadata(
    "Token Name",     // name (required)
    "SYMBOL",         // symbol (required)
    "https://example.com/metadata.json"  // uri (required)
);
```

### Phase 1: Index project

```bash
grep -r "createRpc\|@lightprotocol/compressed-token\|@solana/web3.js" src/
```

### Phase 2: Add dependencies

```bash
npm install --save \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @solana/web3.js
```

### Phase 3: Implement mint creation with TokenMetadata extension

TokenMetadata is the primary extension currently used with light-token mints. Other extensions from the table above are supported but require custom configuration.

**Two Approaches:**

1. **Action (Recommended)**: Use `createMintInterface()` for simple, automatic mint creation
   - Automatically handles validity proof, address derivation, and transaction construction
   - Returns mint address and transaction signature
   - Example: Action code below

2. **Instruction (Advanced)**: Use `createMintInstruction()` for manual transaction control
   - Gives full control over transaction construction
   - Requires manual validity proof fetching and address derivation
   - Useful for batching multiple instructions
   - Example: Instruction code below

#### Action Approach

1. **RPC Setup**: Connect to ZK Compression RPC endpoint (Helius, Triton, or localnet)
   - Use `createRpc()` with mainnet, devnet, or local URLs
   - For devnet: `https://devnet.helius-rpc.com?api-key=${API_KEY}`
   - For localnet: `createRpc()` with no arguments

2. **Create Token Metadata**: Configure token name, symbol, and URI
   - Use `createTokenMetadata(name, symbol, uri)` helper
   - Example: `createTokenMetadata("Example Token", "EXT", "https://example.com/metadata.json")`

3. **Create Mint**: Call `createMintInterface()` with configuration
   - Parameters: `(rpc, payer, mintAuthority, freezeAuthority, decimals, keypair?, addressTree?, stateTree?, tokenMetadata?)`
   - `mintAuthority` must be a `Signer` for light-mints (not just `PublicKey`)
   - Returns `{ mint, transactionSignature }`
   - Automatically handles all proof fetching and address derivation

#### Instruction Approach

1. **RPC Setup**: Same as Action approach

2. **Generate Mint Signer**: Create a new keypair for the mint
   - Use `Keypair.generate()` to create mint signer
   - This keypair signs the mint creation transaction

3. **Get Tree Info**: Fetch address and state tree information
   - Use `getBatchAddressTreeInfo()` for address tree
   - Use `selectStateTreeInfo(await rpc.getStateTreeInfos())` for state tree

4. **Derive Mint Address**: Calculate mint PDA from mint signer
   - Use `findMintAddress(mintSigner.publicKey)` helper
   - PDA derived from `["compressed_mint", mintSigner.toBuffer()]`

5. **Fetch Validity Proof**: Get proof that mint address does not exist yet
   - Use `rpc.getValidityProofV2([], [{ address, treeInfo }])`
   - Pass empty array for hashes and mint address for addresses
   - Returns proof object for instruction

6. **Build Instruction**: Create mint instruction with all parameters
   - Call `createMintInstruction(mintSigner, decimals, mintAuthority, freezeAuthority, payer, validityProof, addressTreeInfo, stateTreeInfo, tokenMetadata)`
   - Include token metadata from `createTokenMetadata()`

7. **Send Transaction**: Build transaction and submit to network
   - Create `Transaction()` and add compute budget + instruction
   - Sign with payer and mintSigner keypairs
   - Use `sendAndConfirmTransaction(rpc, tx, signers)`

### Phase 4: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

## Code Reference

### Action Approach (Recommended)

```typescript
import "dotenv/config";
import { Keypair } from "@solana/web3.js";
import { createRpc } from "@lightprotocol/stateless.js";
import { createMintInterface, createTokenMetadata } from "@lightprotocol/compressed-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
// localnet:
// const RPC_URL = undefined;
const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    // devnet:
    const rpc = createRpc(RPC_URL);
    // localnet:
    // const rpc = createRpc();

    // Create mint with TokenMetadata extension
    const { mint, transactionSignature } = await createMintInterface(
        rpc,
        payer,
        payer,
        null,
        9,
        undefined,
        undefined,
        undefined,
        createTokenMetadata("Example Token", "EXT", "https://example.com/metadata.json")
    );

    console.log("Mint:", mint.toBase58());
    console.log("Tx:", transactionSignature);
})();
```

### Instruction Approach (Advanced)

```typescript
import "dotenv/config";
import {
    Keypair,
    ComputeBudgetProgram,
    PublicKey,
    Transaction,
    sendAndConfirmTransaction,
} from "@solana/web3.js";
import {
    createRpc,
    getBatchAddressTreeInfo,
    selectStateTreeInfo,
    CTOKEN_PROGRAM_ID,
} from "@lightprotocol/stateless.js";
import {
    createMintInstruction,
    createTokenMetadata,
} from "@lightprotocol/compressed-token";
import { homedir } from "os";
import { readFileSync } from "fs";

const COMPRESSED_MINT_SEED = Buffer.from("compressed_mint");

function findMintAddress(mintSigner: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
        [COMPRESSED_MINT_SEED, mintSigner.toBuffer()],
        CTOKEN_PROGRAM_ID
    );
}

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
const rpc = createRpc(RPC_URL);
// localnet:
// const rpc = createRpc();

const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    const mintSigner = Keypair.generate();
    const addressTreeInfo = getBatchAddressTreeInfo();
    const stateTreeInfo = selectStateTreeInfo(await rpc.getStateTreeInfos());
    const [mintPda] = findMintAddress(mintSigner.publicKey);

    const validityProof = await rpc.getValidityProofV2(
        [],
        [{ address: mintPda.toBytes(), treeInfo: addressTreeInfo }]
    );

    // Create instruction with TokenMetadata extension
    const ix = createMintInstruction(
        mintSigner.publicKey,
        9,
        payer.publicKey,
        null,
        payer.publicKey,
        validityProof,
        addressTreeInfo,
        stateTreeInfo,
        createTokenMetadata(
            "Example Token",
            "EXT",
            "https://example.com/metadata.json"
        )
    );

    const tx = new Transaction().add(
        ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }),
        ix
    );
    const signature = await sendAndConfirmTransaction(rpc, tx, [
        payer,
        mintSigner,
    ]);

    console.log("Mint:", mintPda.toBase58());
    console.log("Tx:", signature);
})();
```

### Key Differences

| Aspect | Action Approach | Instruction Approach |
|--------|----------------|---------------------|
| Complexity | Simple, one function call | More setup required |
| Control | Automatic | Full manual control |
| Use Case | Most common scenarios | Batching, custom flows |
| Mint Signer | Auto-generated | Must provide |
| Validity Proof | Auto-fetched | Must fetch manually |
| Tree Selection | Automatic | Must select manually |
| Transaction | Auto-built and sent | Must build and send |

### Token Metadata Configuration

Both approaches use `createTokenMetadata()`:

```typescript
import { createTokenMetadata } from "@lightprotocol/compressed-token";

const metadata = createTokenMetadata(
    "Example Token",     // name (required)
    "EXT",              // symbol (required)
    "https://example.com/metadata.json"  // uri (required)
);
```

Additional metadata fields can be added after mint creation using the update authority.

### Important Notes

1. **Mint Authority**: For light-mints, `mintAuthority` must be a `Signer`, not just a `PublicKey` (unlike SPL/T22)

2. **Rent Exemption**: Light mints are on-chain accounts like SPL mints, but the light token program sponsors the rent-exemption cost

3. **Unified Interface**: `createMintInterface()` works with SPL, Token-2022, and Light Token programs based on the `programId` parameter

4. **Network Selection**:
   - Devnet: Use Helius RPC with API key
   - Localnet: Use `createRpc()` with no arguments (requires `light test-validator`)

5. **Metadata Immutability**: Standard fields (`name`, `symbol`, `uri`) can be updated by `update_authority`. Additional metadata keys cannot be added after creation, only modified or removed.

6. **Extension Support**: While multiple extensions are supported (see Quick Reference table), TokenMetadata is the primary extension with complete SDK support. Other extensions require custom configuration.

~~~~
