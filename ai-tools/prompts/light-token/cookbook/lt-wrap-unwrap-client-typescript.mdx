~~~~text
---
argument-hint: <project_path>
description: Wrap SPL/Token-22 tokens to light-token ATA and unwrap back to SPL in TypeScript
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Wrap and Unwrap SPL/Token-22 Tokens (TypeScript)

References:
- Cookbook Guide: https://zkcompression.com/light-token/cookbook/wrap-unwrap
- SDK Reference: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Function | Purpose |
|-----------|----------|---------|
| Connect | createRpc() | Connect to ZK Compression RPC endpoint |
| Wrap (Action) | wrap() | Move tokens from SPL/T22 account to light-token ATA |
| Wrap (Instruction) | createWrapInstruction() | Build wrap instruction for manual transaction |
| Unwrap (Action) | unwrap() | Move tokens from light-token ATA to SPL/T22 account |
| Unwrap (Instruction) | createUnwrapInstruction() | Build unwrap instruction for manual transaction |
| Get ATA Address | getAssociatedTokenAddressInterface() | Derive light-token ATA address |
| Create ATA | createAtaInterfaceIdempotent() | Create light-token ATA if it doesn't exist |
| Get SPL Interface | getSplInterfaceInfos() | Fetch SPL interface info for wrap/unwrap |
| Load ATA | loadAta() | Load compressed tokens to hot balance (for unwrap) |
| Send Transaction | sendAndConfirmTransaction() | Submit transaction to network |

### Phase 1: Index project

```bash
grep -r "createRpc\|@lightprotocol/compressed-token\|@solana/web3.js" src/
```

### Phase 2: Add dependencies

```bash
npm install --save \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @solana/web3.js \
    @solana/spl-token
```

### Phase 3: Implement wrap and unwrap

See Code Reference below for TypeScript implementation.

**Two Approaches:**

1. **Action (Recommended)**: Use `wrap()` and `unwrap()` for simple, automatic operations
   - Automatically handles SPL interface fetching and transaction construction
   - Returns transaction signature
   - Example: Action code below

2. **Instruction (Advanced)**: Use `createWrapInstruction()` and `createUnwrapInstruction()` for manual control
   - Requires manual SPL interface fetching and transaction building
   - Useful for batching multiple instructions
   - Example: Instruction code below

#### Wrap Operation

**Action Approach:**
1. **RPC Setup**: Connect to ZK Compression RPC endpoint (Helius, Triton, or localnet)
   - Use `createRpc()` with mainnet, devnet, or local URLs
   - For devnet: `https://devnet.helius-rpc.com?api-key=${API_KEY}`
   - For localnet: `createRpc()` with no arguments

2. **Setup Source SPL Tokens**: Create SPL/T22 token account with tokens to wrap
   - Use `createAssociatedTokenAccount()` to create SPL ATA
   - Mint tokens to SPL ATA or decompress compressed tokens to SPL ATA

3. **Create Light-Token ATA**: Create destination light-token ATA
   - Use `getAssociatedTokenAddressInterface(mint, owner)` to derive address
   - Call `createAtaInterfaceIdempotent()` to create if it doesn't exist

4. **Wrap Tokens**: Call `wrap()` to move tokens from SPL to light-token ATA
   - Parameters: `(rpc, payer, source, destination, owner, mint, amount, splInterfaceInfo?, confirmOptions?)`
   - `source` is SPL/T22 token account
   - `destination` is light-token ATA (hot balance)
   - Returns transaction signature

**Instruction Approach:**
1. **RPC Setup**: Same as Action approach

2. **Setup Source SPL Tokens**: Same as Action approach

3. **Create Light-Token ATA**: Same as Action approach

4. **Get SPL Interface Info**: Fetch SPL interface for the mint
   - Use `getSplInterfaceInfos(rpc, mint)` to get all interfaces
   - Find the initialized interface with `.find(info => info.isInitialized)`
   - Throws error if no initialized interface found

5. **Build Wrap Instruction**: Create wrap instruction
   - Call `createWrapInstruction(source, destination, owner, mint, amount, splInterfaceInfo, payer)`
   - `source` is SPL/T22 token account
   - `destination` is light-token ATA
   - `owner` must be a signer

6. **Send Transaction**: Build transaction and submit
   - Create `Transaction()` and add compute budget + instruction
   - Sign with payer keypair
   - Use `sendAndConfirmTransaction(rpc, tx, [payer])`

#### Unwrap Operation

**Action Approach:**
1. **RPC Setup**: Connect to ZK Compression RPC endpoint

2. **Setup Compressed Tokens**: Create mint and mint compressed tokens (cold storage)
   - Use `createMint()` to create a light-mint
   - Use `mintTo()` to mint compressed tokens to owner

3. **Create Destination SPL ATA**: Create SPL/T22 token account for unwrapped tokens
   - Use `createAssociatedTokenAccount()` to create SPL ATA
   - Must exist before unwrapping

4. **Unwrap Tokens**: Call `unwrap()` to move tokens from light-token ATA to SPL ATA
   - Parameters: `(rpc, payer, destination, owner, mint, amount?, splInterfaceInfo?, confirmOptions?)`
   - `destination` is SPL/T22 token account
   - `amount` defaults to all available balance if not provided
   - Automatically loads compressed tokens to hot balance first
   - Returns transaction signature

**Instruction Approach:**
1. **RPC Setup**: Same as Action approach

2. **Setup Compressed Tokens**: Same as Action approach

3. **Load Compressed Tokens**: Load tokens to hot balance (light-token ATA)
   - Derive light-token ATA with `getAssociatedTokenAddressInterface(mint, owner)`
   - Call `loadAta(rpc, lightTokenAta, owner, mint, payer)` to load all compressed tokens

4. **Create Destination SPL ATA**: Create SPL/T22 token account
   - Use `createAssociatedTokenAccount()` to create SPL ATA

5. **Get SPL Interface Info**: Fetch SPL interface for the mint
   - Same as wrap instruction approach

6. **Build Unwrap Instruction**: Create unwrap instruction
   - Call `createUnwrapInstruction(source, destination, owner, mint, amount, splInterfaceInfo, payer)`
   - `source` is light-token ATA (hot balance)
   - `destination` is SPL/T22 token account

7. **Send Transaction**: Build transaction and submit
   - Same as wrap instruction approach

### Phase 4: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

## Code Reference

### Wrap - Action Approach (Recommended)

```typescript
import "dotenv/config";
import { Keypair } from "@solana/web3.js";
import { createRpc, bn } from "@lightprotocol/stateless.js";
import {
    createMint,
    mintTo,
    decompress,
    wrap,
    getAssociatedTokenAddressInterface,
    createAtaInterfaceIdempotent,
} from "@lightprotocol/compressed-token";
import { createAssociatedTokenAccount } from "@solana/spl-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
// localnet:
// const RPC_URL = undefined;
const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    // devnet:
    const rpc = createRpc(RPC_URL);
    // localnet:
    // const rpc = createRpc();

    // Setup: Get SPL tokens (needed to wrap)
    const { mint } = await createMint(rpc, payer, payer.publicKey, 9);
    const splAta = await createAssociatedTokenAccount(
        rpc,
        payer,
        mint,
        payer.publicKey
    );
    await mintTo(rpc, payer, mint, payer.publicKey, payer, bn(1000));
    await decompress(rpc, payer, mint, bn(1000), payer, splAta);

    // Wrap SPL tokens to rent-free token ATA
    const lightTokenAta = getAssociatedTokenAddressInterface(mint, payer.publicKey);
    await createAtaInterfaceIdempotent(rpc, payer, mint, payer.publicKey);

    const tx = await wrap(rpc, payer, splAta, lightTokenAta, payer, mint, bn(500));

    console.log("Tx:", tx);
})();
```

### Wrap - Instruction Approach (Advanced)

```typescript
import "dotenv/config";
import { Keypair, ComputeBudgetProgram, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { createRpc, bn } from "@lightprotocol/stateless.js";
import {
    createMint,
    mintTo,
    decompress,
    createWrapInstruction,
    getAssociatedTokenAddressInterface,
    createAtaInterfaceIdempotent,
    getSplInterfaceInfos,
} from "@lightprotocol/compressed-token";
import { createAssociatedTokenAccount } from "@solana/spl-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
const rpc = createRpc(RPC_URL);
// localnet:
// const rpc = createRpc();

const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {

    // Setup: Get SPL tokens (needed to wrap)
    const { mint } = await createMint(rpc, payer, payer.publicKey, 9);
    const splAta = await createAssociatedTokenAccount(
        rpc,
        payer,
        mint,
        payer.publicKey
    );
    await mintTo(rpc, payer, mint, payer.publicKey, payer, bn(1000));
    await decompress(rpc, payer, mint, bn(1000), payer, splAta);

    // Create wrap instruction
    const lightTokenAta = getAssociatedTokenAddressInterface(mint, payer.publicKey);
    await createAtaInterfaceIdempotent(rpc, payer, mint, payer.publicKey);

    const splInterfaceInfos = await getSplInterfaceInfos(rpc, mint);
    const splInterfaceInfo = splInterfaceInfos.find(
        (info) => info.isInitialized
    );

    if (!splInterfaceInfo) throw new Error("No SPL interface found");

    const ix = createWrapInstruction(
        splAta,
        lightTokenAta,
        payer.publicKey,
        mint,
        bn(500),
        splInterfaceInfo,
        payer.publicKey
    );

    const tx = new Transaction().add(
        ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 }),
        ix
    );
    const signature = await sendAndConfirmTransaction(rpc, tx, [payer]);

    console.log("Tx:", signature);
})();
```

### Unwrap - Action Approach (Recommended)

```typescript
import "dotenv/config";
import { Keypair } from "@solana/web3.js";
import { createRpc, bn } from "@lightprotocol/stateless.js";
import { createMint, mintTo } from "@lightprotocol/compressed-token";
import { unwrap } from "@lightprotocol/compressed-token/unified";
import { createAssociatedTokenAccount } from "@solana/spl-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
// localnet:
// const RPC_URL = undefined;
const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    // devnet:
    const rpc = createRpc(RPC_URL);
    // localnet:
    // const rpc = createRpc();

    // Setup: Get compressed tokens (cold storage)
    const { mint } = await createMint(rpc, payer, payer.publicKey, 9);
    await mintTo(rpc, payer, mint, payer.publicKey, payer, bn(1000));

    // Unwrap rent-free tokens to SPL ATA
    const splAta = await createAssociatedTokenAccount(
        rpc,
        payer,
        mint,
        payer.publicKey
    );
    const tx = await unwrap(rpc, payer, splAta, payer, mint, bn(500));

    console.log("Tx:", tx);
})();
```

### Unwrap - Instruction Approach (Advanced)

```typescript
import "dotenv/config";
import { Keypair, ComputeBudgetProgram, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { createRpc, bn } from "@lightprotocol/stateless.js";
import {
    createMint,
    mintTo,
    loadAta,
    getAssociatedTokenAddressInterface,
    getSplInterfaceInfos,
} from "@lightprotocol/compressed-token";
import { createUnwrapInstruction } from "@lightprotocol/compressed-token/unified";
import { createAssociatedTokenAccount } from "@solana/spl-token";
import { homedir } from "os";
import { readFileSync } from "fs";

// devnet:
const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
const rpc = createRpc(RPC_URL);
// localnet:
// const rpc = createRpc();

const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {

    // Setup: Get compressed tokens (cold storage)
    const { mint } = await createMint(rpc, payer, payer.publicKey, 9);
    await mintTo(rpc, payer, mint, payer.publicKey, payer, bn(1000));

    // Load compressed tokens to hot balance, then create unwrap instruction
    const lightTokenAta = getAssociatedTokenAddressInterface(mint, payer.publicKey);
    await loadAta(rpc, lightTokenAta, payer, mint, payer);

    const splAta = await createAssociatedTokenAccount(
        rpc,
        payer,
        mint,
        payer.publicKey
    );

    const splInterfaceInfos = await getSplInterfaceInfos(rpc, mint);
    const splInterfaceInfo = splInterfaceInfos.find(
        (info) => info.isInitialized
    );

    if (!splInterfaceInfo) throw new Error("No SPL interface found");

    const ix = createUnwrapInstruction(
        lightTokenAta,
        splAta,
        payer.publicKey,
        mint,
        bn(500),
        splInterfaceInfo,
        payer.publicKey
    );

    const tx = new Transaction().add(
        ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 }),
        ix
    );
    const signature = await sendAndConfirmTransaction(rpc, tx, [payer]);

    console.log("Tx:", signature);
})();
```

### Key Differences

| Aspect | Action Approach | Instruction Approach |
|--------|----------------|---------------------|
| Complexity | Simple, one function call | More setup required |
| Control | Automatic | Full manual control |
| Use Case | Most common scenarios | Batching, custom flows |
| SPL Interface | Auto-fetched | Must fetch manually |
| Transaction | Auto-built and sent | Must build and send |
| Unwrap Loading | Automatic | Must call loadAta() manually |

### Important Notes

1. **SPL Interface**: Both wrap and unwrap require an initialized SPL interface for the mint. The action approach fetches this automatically, while the instruction approach requires manual fetching.

2. **Wrap Direction**: Wrap moves tokens from SPL/T22 account → light-token ATA (hot balance). The light-token ATA must be created first using `createAtaInterfaceIdempotent()`.

3. **Unwrap Direction**: Unwrap moves tokens from light-token ATA (hot balance) → SPL/T22 account. The destination SPL ATA must exist before unwrapping.

4. **Hot Balance Requirement**: Unwrap requires tokens in hot balance (light-token ATA). The action approach automatically loads compressed tokens to hot balance. The instruction approach requires calling `loadAta()` manually.

5. **Amount Parameter**: In `unwrap()` action, amount is optional and defaults to all available balance. In instruction approach, amount is required.

6. **Network Selection**:
   - Devnet: Use Helius RPC with API key
   - Localnet: Use `createRpc()` with no arguments (requires `light test-validator`)

7. **Compute Units**: Both wrap and unwrap use 200,000 compute units.

8. **Use Cases**:
   - **Wrap**: Convert SPL/T22 tokens to light-token format for rent-free storage
   - **Unwrap**: Convert light-tokens back to SPL/T22 format to interact with applications that only support SPL/T22

~~~~
