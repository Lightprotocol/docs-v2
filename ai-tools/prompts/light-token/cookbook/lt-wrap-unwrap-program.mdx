---
argument-hint: <project_path>
description: Wrap SPL/Token-22 tokens to light-token ATA and unwrap back using Anchor framework
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Wrap and unwrap SPL/Token-22 tokens with light-token ATA

Create a Solana program using Anchor that wraps SPL/Token-22 tokens to light-token ATA (hot balance) and unwraps them back to SPL accounts.

References:
- Guide: https://zkcompression.com/light-token/cookbook/wrap-unwrap
- SDK Reference: https://docs.rs/light-ctoken-sdk/latest/light_ctoken_sdk/
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | What It Does |
|-----------|--------------|
| **Wrap** | Move tokens from SPL/T22 account → light-token ATA (hot balance) |
| **Unwrap** | Move tokens from light-token ATA (hot balance) → SPL/T22 account |

### Phase 1: Index project

```bash
find . -name "Cargo.toml" -o -name "lib.rs" -o -name "Anchor.toml"
```

### Phase 2: Add dependencies

Add to `programs/[name]/Cargo.toml`:

```toml
[dependencies]
light-ctoken-sdk = "0.2.0"
anchor_lang = "0.31.1"
```

### Phase 3: Implement program

Implementation follows these steps:

1. **Configure Wrap Transfer**: Set source_spl_token_account, destination_ctoken_account, amount, authority, mint, payer, spl_interface_pda
   - Source: `/home/tilo/Workspace/light-token-program-examples/src/transfer_spl_to_light_token.rs:44-56`
2. **Configure Unwrap Transfer**: Set source_ctoken_account, destination_spl_token_account, amount, authority, mint, payer, spl_interface_pda
   - Source: `/home/tilo/Workspace/light-token-program-examples/src/transfer_spl_to_light_token.rs:132-144`
3. **CPI to Light Token Program**: Use `.invoke()` or `.invoke_signed()` based on signer type
   - invoke: When authority is external keypair
   - invoke_signed: When authority is PDA (requires seeds)
   - Source: `/home/tilo/Workspace/light-token-program-examples/src/transfer_spl_to_light_token.rs:56`

### Phase 4: Test

Build and test the program:

```bash
anchor build && anchor test
```

On failure, debug and retry. Assign always to subagents with Task tool.

## Code Reference

### Wrap (SPL to Light-Token ATA)

#### invoke (External Keypair Authority)

```rust
use light_ctoken_sdk::ctoken::TransferSplToCtokenCpi;
use solana_program::{account_info::AccountInfo, program_error::ProgramError};

/// Handler for transferring SPL tokens to CToken (invoke)
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: source_spl_token_account
/// - accounts[2]: destination_ctoken_account (writable)
/// - accounts[3]: authority (signer)
/// - accounts[4]: mint
/// - accounts[5]: payer (signer)
/// - accounts[6]: spl_interface_pda
/// - accounts[7]: spl_token_program
/// - accounts[8]: compressed_token_program_authority
pub fn process_spl_to_ctoken_invoke(
    accounts: &[AccountInfo],
    amount: u64,
    spl_interface_pda_bump: u8,
) -> Result<(), ProgramError> {
    if accounts.len() < 9 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    TransferSplToCtokenCpi {
        source_spl_token_account: accounts[1].clone(),
        destination_ctoken_account: accounts[2].clone(),
        amount,
        authority: accounts[3].clone(),
        mint: accounts[4].clone(),
        payer: accounts[5].clone(),
        spl_interface_pda: accounts[6].clone(),
        spl_interface_pda_bump,
        spl_token_program: accounts[7].clone(),
        compressed_token_program_authority: accounts[8].clone(),
    }
    .invoke()?;

    Ok(())
}
```

#### invoke_signed (PDA Authority)

```rust
use light_ctoken_sdk::ctoken::TransferSplToCtokenCpi;
use solana_program::{account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey};
use crate::ID;

/// PDA seed for authority in invoke_signed variant
pub const TRANSFER_AUTHORITY_SEED: &[u8] = b"transfer_authority";

/// Handler for transferring SPL tokens to CToken with PDA authority (invoke_signed)
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: source_spl_token_account
/// - accounts[2]: destination_ctoken_account (writable)
/// - accounts[3]: authority (PDA, not signer - program signs)
/// - accounts[4]: mint
/// - accounts[5]: payer (signer)
/// - accounts[6]: spl_interface_pda
/// - accounts[7]: spl_token_program
/// - accounts[8]: compressed_token_program_authority
pub fn process_spl_to_ctoken_invoke_signed(
    accounts: &[AccountInfo],
    amount: u64,
    spl_interface_pda_bump: u8,
) -> Result<(), ProgramError> {
    if accounts.len() < 9 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the authority
    let (authority_pda, authority_bump) =
        Pubkey::find_program_address(&[TRANSFER_AUTHORITY_SEED], &ID);

    // Verify the authority account is the PDA we expect
    if &authority_pda != accounts[3].key {
        return Err(ProgramError::InvalidSeeds);
    }

    let account_infos = TransferSplToCtokenCpi {
        source_spl_token_account: accounts[1].clone(),
        destination_ctoken_account: accounts[2].clone(),
        amount,
        authority: accounts[3].clone(),
        mint: accounts[4].clone(),
        payer: accounts[5].clone(),
        spl_interface_pda: accounts[6].clone(),
        spl_interface_pda_bump,
        spl_token_program: accounts[7].clone(),
        compressed_token_program_authority: accounts[8].clone(),
    };

    // Invoke with PDA signing
    let authority_seeds: &[&[u8]] = &[TRANSFER_AUTHORITY_SEED, &[authority_bump]];
    account_infos.invoke_signed(&[authority_seeds])?;

    Ok(())
}
```

### Unwrap (Light-Token ATA to SPL)

#### invoke (External Keypair Authority)

```rust
use light_ctoken_sdk::ctoken::TransferCTokenToSplCpi;
use solana_program::{account_info::AccountInfo, program_error::ProgramError};

/// Handler for transferring CToken to SPL tokens (invoke)
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: source_ctoken_account
/// - accounts[2]: destination_spl_token_account
/// - accounts[3]: authority (signer)
/// - accounts[4]: mint
/// - accounts[5]: payer (signer)
/// - accounts[6]: spl_interface_pda
/// - accounts[7]: spl_token_program
/// - accounts[8]: compressed_token_program_authority
pub fn process_ctoken_to_spl_invoke(
    accounts: &[AccountInfo],
    amount: u64,
    spl_interface_pda_bump: u8,
) -> Result<(), ProgramError> {
    if accounts.len() < 9 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    TransferCTokenToSplCpi {
        source_ctoken_account: accounts[1].clone(),
        destination_spl_token_account: accounts[2].clone(),
        amount,
        authority: accounts[3].clone(),
        mint: accounts[4].clone(),
        payer: accounts[5].clone(),
        spl_interface_pda: accounts[6].clone(),
        spl_interface_pda_bump,
        spl_token_program: accounts[7].clone(),
        compressed_token_program_authority: accounts[8].clone(),
    }
    .invoke()?;

    Ok(())
}
```

#### invoke_signed (PDA Authority)

```rust
use light_ctoken_sdk::ctoken::TransferCTokenToSplCpi;
use solana_program::{account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey};
use crate::ID;

/// PDA seed for authority in invoke_signed variant
pub const TRANSFER_AUTHORITY_SEED: &[u8] = b"transfer_authority";

/// Handler for transferring CToken to SPL tokens with PDA authority (invoke_signed)
///
/// Account order:
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: source_ctoken_account
/// - accounts[2]: destination_spl_token_account
/// - accounts[3]: authority (PDA, not signer - program signs)
/// - accounts[4]: mint
/// - accounts[5]: payer (signer)
/// - accounts[6]: spl_interface_pda
/// - accounts[7]: spl_token_program
/// - accounts[8]: compressed_token_program_authority
pub fn process_ctoken_to_spl_invoke_signed(
    accounts: &[AccountInfo],
    amount: u64,
    spl_interface_pda_bump: u8,
) -> Result<(), ProgramError> {
    if accounts.len() < 9 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the authority
    let (authority_pda, authority_bump) =
        Pubkey::find_program_address(&[TRANSFER_AUTHORITY_SEED], &ID);

    // Verify the authority account is the PDA we expect
    if &authority_pda != accounts[3].key {
        return Err(ProgramError::InvalidSeeds);
    }

    let account_infos = TransferCTokenToSplCpi {
        source_ctoken_account: accounts[1].clone(),
        destination_spl_token_account: accounts[2].clone(),
        amount,
        authority: accounts[3].clone(),
        mint: accounts[4].clone(),
        payer: accounts[5].clone(),
        spl_interface_pda: accounts[6].clone(),
        spl_interface_pda_bump,
        spl_token_program: accounts[7].clone(),
        compressed_token_program_authority: accounts[8].clone(),
    };

    // Invoke with PDA signing
    let authority_seeds: &[&[u8]] = &[TRANSFER_AUTHORITY_SEED, &[authority_bump]];
    account_infos.invoke_signed(&[authority_seeds])?;

    Ok(())
}
```

## Key Concepts

### Wrap vs Unwrap

**Wrap (SPL to Light-Token ATA):**
- Transfers tokens from SPL/Token-22 account to light-token ATA (hot balance)
- Uses `TransferSplToCtokenCpi` builder
- Requires SPL token account with sufficient balance
- Creates light-token ATA if it doesn't exist

**Unwrap (Light-Token ATA to SPL):**
- Transfers tokens from light-token ATA (hot balance) to SPL account
- Uses `TransferCTokenToSplCpi` builder
- Requires light-token ATA with sufficient hot balance
- Creates SPL token account if it doesn't exist

### Core Components

1. **TransferSplToCtokenCpi**: Builder for wrap operations
   - `source_spl_token_account`: SPL token account to transfer from
   - `destination_ctoken_account`: Light-token ATA to transfer to
   - `amount`: Token amount to transfer
   - `authority`: Account authority (must be Signer or PDA)
   - `mint`: Token mint address
   - `payer`: Fee payer account
   - `spl_interface_pda`: SPL interface PDA for the mint
   - `spl_interface_pda_bump`: Bump seed for the interface PDA
   - `spl_token_program`: SPL Token program
   - `compressed_token_program_authority`: Compressed token program authority

2. **TransferCTokenToSplCpi**: Builder for unwrap operations
   - `source_ctoken_account`: Light-token ATA to transfer from
   - `destination_spl_token_account`: SPL token account to transfer to
   - `amount`: Token amount to transfer
   - `authority`: Account authority (must be Signer or PDA)
   - `mint`: Token mint address
   - `payer`: Fee payer account
   - `spl_interface_pda`: SPL interface PDA for the mint
   - `spl_interface_pda_bump`: Bump seed for the interface PDA
   - `spl_token_program`: SPL Token program
   - `compressed_token_program_authority`: Compressed token program authority

3. **SPL Interface PDA**: On-chain token pool account
   - Stores wrapped tokens during wrap operations
   - Releases tokens during unwrap operations
   - Derived using `getSplInterfaceInfos()` RPC method
   - Requires bump seed for CPI

### Security

- **Authority validation**: Authority must be valid Signer or PDA
- **PDA verification**: When using PDAs, verify derived address matches expected
- **Balance validation**: Ensure sufficient balance before wrap/unwrap
- **Account validation**: Verify all accounts are correct for the operation

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `ProgramError::InvalidSeeds` | PDA derivation mismatch | Verify PDA seeds match expected derivation |
| `ProgramError::NotEnoughAccountKeys` | Missing required accounts | Check all 9 accounts are provided |
| `InsufficientFunds` | Insufficient token balance | Ensure source account has enough tokens |
| `AccountNotInitialized` | Destination account missing | Create destination account before transfer |
| `InvalidAccountData` | Wrong spl_interface_pda | Fetch correct interface PDA using `getSplInterfaceInfos()` |
