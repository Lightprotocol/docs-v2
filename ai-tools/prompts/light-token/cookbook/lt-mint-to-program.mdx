---
argument-hint: <project_path>
description: Mint light-tokens to token accounts using Anchor framework
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Mint light-tokens to token accounts

Create a Solana program using Anchor that mints light-tokens to existing light-token accounts.

References:
- Guide: https://zkcompression.com/light-token/cookbook/mint-to
- SDK Reference: https://docs.rs/light-token/latest/light_token/
- GitHub Example: https://github.com/Lightprotocol/examples-light-token

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | SPL Token Mint To | Light-Token Mint To |
| --------- | ----------------- | ------------------- |
| Storage | Updates on-chain token account | Updates on-chain light-token account |
| Mint Access | Requires compressed mint proof | Compressed mint proven with validity proof |
| Authority | Mint authority can be PublicKey | Mint authority must be Signer |
| State Trees | Not required | Requires state tree, input queue, output queue |
| Token Accounts | SPL token accounts | Light-token accounts (on-chain) |

### Phase 1: Index project

```bash
find . -name "Cargo.toml" -o -name "lib.rs" -o -name "Anchor.toml"
```

### Phase 2: Add dependencies

Add to `programs/[name]/Cargo.toml`:

```toml
[dependencies]
light-token-sdk = "0.2.0"
light-token-interface = "0.7.0"
light-sdk = "0.13.0"
anchor_lang = "0.31.1"
borsh = "1.5.3"
```

### Phase 3: Implement program

See Code Reference below. Implementation follows these steps:

1. **Configure Mint Parameters**: Build `MintToParams` with compressed mint context, amount, mint authority, and validity proof
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/ctoken_mint_to.rs#L543-L549
2. **System Accounts**: Include Light System Program accounts and state/address trees in `SystemAccountInfos`
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/ctoken_mint_to.rs#L552-L559
3. **Build Account Infos**: Create `MintToCpi` with required accounts (authority, payer, state_tree, queues, token_accounts)
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/ctoken_mint_to.rs#L562-L578
4. **CPI to Light Token Program**: Use `.invoke()` or `.invoke_signed()` based on signer type
   - invoke: When mint authority is external keypair
   - invoke_signed: When mint authority is PDA (requires seeds)
   - Source: https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-light-token-test/src/ctoken_mint_to.rs#L579

### Phase 4: Test

Build and test the program:

```bash
anchor build && anchor test
```

On failure, debug and retry. Assign always to subagents with Task tool.

## Code Reference

### Mint Parameters Configuration

```rust
use light_token_sdk::token::MintToParams;
use light_token_interface::instructions::mint_action::CompressedMintWithContext;
use light_sdk::instruction::ValidityProof;

let params = MintToParams::new(
    data.compressed_mint_inputs,
    data.amount,
    data.mint_authority,
    data.proof,
);
```

**Note**: The client passes a validity proof that proves the light-mint exists in the state tree. The `CompressedMintWithContext` includes the mint state, leaf index, root index, and compression address.

### System Accounts

```rust
use light_token_sdk::token::SystemAccountInfos;

let system_accounts = SystemAccountInfos {
    light_system_program: light_system_program.clone(),
    cpi_authority_pda: cpi_authority_pda.clone(),
    registered_program_pda: registered_program_pda.clone(),
    account_compression_authority: account_compression_authority.clone(),
    account_compression_program: account_compression_program.clone(),
    system_program: system_program.clone(),
};
```

### CPI Variants

#### invoke (External Keypair Authority)

```rust
use light_token_sdk::token::MintToCpi;

MintToCpi {
    authority: authority.clone(),
    payer: payer.clone(),
    state_tree: state_tree.clone(),
    input_queue: input_queue.clone(),
    output_queue: output_queue.clone(),
    token_accounts,
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    params,
}
.invoke()?;
```

#### invoke_signed (PDA Authority)

```rust
use light_token_sdk::token::MintToCpi;

let account_infos = MintToCpi {
    authority: authority.clone(),
    payer: payer.clone(),
    state_tree: state_tree.clone(),
    input_queue: input_queue.clone(),
    output_queue: output_queue.clone(),
    token_accounts,
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    params,
};

let signer_seeds: &[&[u8]] = &[MINT_AUTHORITY_SEED, &[bump]];
account_infos.invoke_signed(&[signer_seeds])?;
```

### Full Anchor Program Example

```rust
use borsh::{BorshDeserialize, BorshSerialize};
use light_token_interface::instructions::mint_action::CompressedMintWithContext;
use light_token_sdk::token::{MintToCpi, MintToParams, SystemAccountInfos};
use light_sdk::instruction::ValidityProof;
use solana_program::{account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey};

use crate::ID;

/// PDA seed for mint authority in invoke_signed variant
pub const MINT_AUTHORITY_SEED: &[u8] = b"mint_authority";

/// Instruction data for mint_to
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct MintToData {
    pub compressed_mint_inputs: CompressedMintWithContext,
    pub amount: u64,
    pub mint_authority: Pubkey,
    pub proof: ValidityProof,
}

/// Handler for minting tokens to compressed token accounts
///
/// Uses the MintToCpi builder pattern. This demonstrates how to:
/// 1. Build MintToParams using the constructor
/// 2. Build MintToCpi with accounts and params
/// 3. Call invoke() which handles instruction building and CPI
///
/// Account order (all accounts from SDK-generated instruction):
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: light_system_program
/// - accounts[2]: authority (mint_authority)
/// - accounts[3]: fee_payer
/// - accounts[4]: cpi_authority_pda
/// - accounts[5]: registered_program_pda
/// - accounts[6]: account_compression_authority
/// - accounts[7]: account_compression_program
/// - accounts[8]: system_program
/// - accounts[9]: output_queue
/// - accounts[10]: state_tree
/// - accounts[11]: input_queue
/// - accounts[12..]: token_accounts (variable length - destination accounts)
pub fn process_mint_to(
    accounts: &[AccountInfo],
    data: MintToData,
) -> Result<(), ProgramError> {
    if accounts.len() < 13 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Build params using the constructor
    let params = MintToParams::new(
        data.compressed_mint_inputs,
        data.amount,
        data.mint_authority,
        data.proof,
    );

    // Build system accounts struct
    let system_accounts = SystemAccountInfos {
        light_system_program: accounts[1].clone(),
        cpi_authority_pda: accounts[4].clone(),
        registered_program_pda: accounts[5].clone(),
        account_compression_authority: accounts[6].clone(),
        account_compression_program: accounts[7].clone(),
        system_program: accounts[8].clone(),
    };

    // Collect token accounts from remaining accounts (index 12 onwards)
    let token_accounts: Vec<AccountInfo> = accounts[12..].to_vec();

    // Build the account infos struct and invoke
    // SDK account order: output_queue (9), tree (10), input_queue (11), token_accounts (12+)
    // In this case, payer == authority (accounts[3])
    MintToCpi {
        authority: accounts[2].clone(),    // authority from SDK accounts
        payer: accounts[3].clone(),        // fee_payer from SDK accounts
        state_tree: accounts[10].clone(),  // tree at index 10
        input_queue: accounts[11].clone(), // input_queue at index 11
        output_queue: accounts[9].clone(), // output_queue at index 9
        token_accounts,
        system_accounts,
        cpi_context: None,
        cpi_context_account: None,
        params,
    }
    .invoke()?;

    Ok(())
}

/// Handler for minting tokens with PDA mint authority (invoke_signed)
///
/// Uses the MintToCpi builder pattern with invoke_signed.
/// The mint authority is a PDA derived from this program.
///
/// Account order (all accounts from SDK-generated instruction):
/// - accounts[0]: compressed_token_program (for CPI)
/// - accounts[1]: light_system_program
/// - accounts[2]: authority (PDA mint_authority, not signer - program signs)
/// - accounts[3]: fee_payer
/// - accounts[4]: cpi_authority_pda
/// - accounts[5]: registered_program_pda
/// - accounts[6]: account_compression_authority
/// - accounts[7]: account_compression_program
/// - accounts[8]: system_program
/// - accounts[9]: output_queue
/// - accounts[10]: state_tree
/// - accounts[11]: input_queue
/// - accounts[12..]: token_accounts (variable length - destination accounts)
pub fn process_mint_to_invoke_signed(
    accounts: &[AccountInfo],
    data: MintToData,
) -> Result<(), ProgramError> {
    if accounts.len() < 13 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the mint authority
    let (pda, bump) = Pubkey::find_program_address(&[MINT_AUTHORITY_SEED], &ID);

    // Verify the authority account is the PDA we expect
    if &pda != accounts[2].key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Build params using the constructor
    let params = MintToParams::new(
        data.compressed_mint_inputs,
        data.amount,
        data.mint_authority,
        data.proof,
    );

    // Build system accounts struct
    let system_accounts = SystemAccountInfos {
        light_system_program: accounts[1].clone(),
        cpi_authority_pda: accounts[4].clone(),
        registered_program_pda: accounts[5].clone(),
        account_compression_authority: accounts[6].clone(),
        account_compression_program: accounts[7].clone(),
        system_program: accounts[8].clone(),
    };

    // Collect token accounts from remaining accounts (index 12 onwards)
    let token_accounts: Vec<AccountInfo> = accounts[12..].to_vec();

    // Build the account infos struct
    // authority is the PDA (accounts[2])
    let account_infos = MintToCpi {
        authority: accounts[2].clone(),    // authority PDA
        payer: accounts[3].clone(),        // fee_payer from SDK accounts
        state_tree: accounts[10].clone(),  // tree at index 10
        input_queue: accounts[11].clone(), // input_queue at index 11
        output_queue: accounts[9].clone(), // output_queue at index 9
        token_accounts,
        system_accounts,
        cpi_context: None,
        cpi_context_account: None,
        params,
    };

    // Invoke with PDA signing
    let signer_seeds: &[&[u8]] = &[MINT_AUTHORITY_SEED, &[bump]];
    account_infos.invoke_signed(&[signer_seeds])?;

    Ok(())
}
```

## Key Concepts

### Mint To vs Create Mint

**Create Mint:**
- Creates new mint account with metadata
- Requires validity proof that mint address doesn't exist
- Sets initial mint authority and freeze authority
- Uses address tree for compression address

**Mint To:**
- Mints tokens to existing token accounts
- Requires validity proof that compressed mint exists
- Uses state tree, input queue, and output queue
- Mint authority must sign transaction

### Core Components

1. **CompressedMintWithContext**: Mint state with proof data
   - `address`: Compression address (32 bytes)
   - `leaf_index`: Position in state tree
   - `root_index`: Merkle tree root index for proof
   - `prove_by_index`: Boolean for proof method
   - `mint`: Deserialized compressed mint state

2. **MintToParams**: Mint operation configuration
   - `compressed_mint_inputs`: CompressedMintWithContext
   - `amount`: Number of tokens to mint (in base units)
   - `mint_authority`: Authority that can mint (must be Signer)
   - `proof`: Validity proof proving mint exists

3. **SystemAccountInfos**: Light System Program accounts
   - `light_system_program`: Main compression program
   - `cpi_authority_pda`: CPI authorization PDA
   - `registered_program_pda`: Program registration account
   - `account_compression_authority`: Compression authority
   - `account_compression_program`: Account compression program
   - `system_program`: Solana system program

4. **MintToCpi**: Builder pattern for CPI
   - `authority`: Mint authority (must be Signer)
   - `payer`: Fee payer account
   - `state_tree`: State tree containing mint
   - `input_queue`: Input queue for compressed mint
   - `output_queue`: Output queue for state updates
   - `token_accounts`: Destination light-token accounts (variable length)
   - `.invoke()`: For external keypair signers
   - `.invoke_signed()`: For PDA signers

5. **Validity Proof**: Zero-knowledge proof
   - Proves the compressed mint exists in state tree
   - Fetched with `getValidityProof()` RPC method
   - Includes mint account hash and root index
   - Verified by Light System Program during mint operation

### State Tree Management

1. **State Tree**: Stores compressed mint account
   - Retrieved from RPC with `get_compressed_account()`
   - Contains mint state and leaf index

2. **Input Queue**: Queue for reading compressed state
   - Associated with the state tree containing the mint
   - Used to verify mint existence

3. **Output Queue**: Queue for state updates
   - Retrieved from RPC with `get_random_state_tree_info()`
   - Different from input queue (state updates go to output)

### Token Account Requirements

- Token accounts must be initialized light-token accounts
- Each account must match the mint being minted from
- Accounts are on-chain (not compressed)
- Multiple accounts can be passed in single transaction
- Accounts stored in variable-length slice starting at index 12

### Security

- **Authority validation**: Mint authority must be valid Signer
- **Proof verification**: Light System Program validates ZK proof of mint existence
- **PDA verification**: When using PDAs, verify derived address matches expected
- **Tree validation**: Ensure state trees and queues are correct
- **Amount validation**: Ensure amount doesn't cause overflow based on mint decimals

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `ProgramError::InvalidSeeds` | PDA derivation mismatch | Verify PDA seeds match expected derivation |
| `ProgramError::NotEnoughAccountKeys` | Missing required accounts | Check all 13+ accounts are provided (12 fixed + token accounts) |
| `ProgramError::InvalidAccountData` | Invalid proof or mint state | Verify validity proof and compressed mint context are correct |
| Authority not Signer | Mint authority requires Signer | Ensure mint_authority is marked as Signer |
| Invalid state tree | Wrong tree for mint | Verify state_tree matches mint's tree from `get_compressed_account()` |
| Invalid output queue | Wrong queue for devnet | Fetch active queue with `get_random_state_tree_info()` |
| Token account mint mismatch | Account mint != minting mint | Verify all token accounts belong to the mint |
