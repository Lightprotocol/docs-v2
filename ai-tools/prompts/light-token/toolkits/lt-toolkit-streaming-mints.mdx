~~~~text
---
argument-hint: <project_path>
description: Stream and index compressed token mints using Helius Laserstream
allowed-tools: [Bash, Read, Glob, Grep, Write, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Stream and index compressed token mints (Rust)

References:
- Guide: https://zkcompression.com/light-token/toolkits/for-streaming-mints
- SDK Reference: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- GitHub Example: https://github.com/Lightprotocol/examples-light-token/tree/main/toolkits/streaming-tokens

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Type | Purpose |
|-----------|------|---------|
| Connect | LaserstreamConfig | Connect to Helius Laserstream |
| Subscribe | subscribe() | Create streaming subscription |
| Parse Events | event_from_light_transaction() | Parse compressed account events from transactions |
| Extract Mints | Mint::try_from_slice() | Deserialize mint data from output accounts |
| Detect New Mints | Check input_compressed_account_hashes | Compare output address against inputs |
| Parse Metadata | ExtensionStruct::TokenMetadata | Extract token metadata from mint extensions |

### Phase 1: Index project

```bash
grep -r "helius-laserstream\|light-event\|light-token-interface" .
```

### Phase 2: Add dependencies

```toml
[dependencies]
helius-laserstream = "0.1"
tokio = { version = "1", features = ["full"] }
futures = "0.3"
light-event = "0.3"
light-compressed-account = "0.8"
light-token-interface = "0.2"
borsh = "0.10"
bs58 = "0.5"
```

### Phase 3: Implement streaming mint indexer

See Code Reference below for Rust implementation.

**Workflow:**

1. **Connect to Laserstream**: Configure Helius Laserstream endpoint with API key
   - Use `LaserstreamConfig::new(endpoint, api_key)` with mainnet or devnet URL
   - Mainnet: `https://laserstream-mainnet-ewr.helius-rpc.com`
   - Devnet: `https://laserstream-devnet-ewr.helius-rpc.com`

2. **Create Subscription**: Subscribe to Light System Program transactions
   - Use `SubscribeRequest` to filter for `SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7`
   - Filter: `vote: false`, `failed: false`, `account_include: [LIGHT_SYSTEM_PROGRAM]`
   - Call `subscribe(config, request)` to get stream and handle

3. **Process Stream**: Iterate over transaction updates
   - Use `stream.next().await` to get transaction messages
   - Extract transaction message and metadata
   - Pass to event parser

4. **Parse Events**: Extract compressed account events from transactions
   - Call `event_from_light_transaction(&program_ids, &instruction_data, accounts_per_ix)`
   - Returns `Option<Vec<PublicTransactionEventBatch>>`
   - Each batch contains input/output compressed accounts

5. **Extract Mints**: Filter and deserialize mint accounts
   - Iterate over `event.output_compressed_accounts`
   - Check `owner` equals Light Token Program ID (`cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m`)
   - Check `discriminator` equals `COMPRESSED_MINT_DISCRIMINATOR` ([0, 0, 0, 0, 0, 0, 0, 1])
   - Deserialize data with `Mint::try_from_slice(&data)`

6. **Detect New Mints**: Compare output address against input hashes
   - Get `compressed_account.address` from output
   - Check if address exists in `event.input_compressed_account_hashes`
   - If not found in inputs, mint is newly created

7. **Extract Metadata**: Parse TokenMetadata extension if present
   - Check `mint.extensions` for `ExtensionStruct::TokenMetadata(m)`
   - Extract `name`, `symbol`, `uri` as UTF-8 strings
   - Parse `update_authority` (all zeros = immutable)

### Phase 4: Test

Run the streaming indexer. Requires Helius API key in `.env` file:

```bash
cargo build
cargo run
```

For testing:
- Watch for new mints created on network
- Verify mint data extraction
- Check metadata parsing

## Code Reference

### Complete Streaming Mint Indexer

```rust
use futures::StreamExt;
use helius_laserstream::{subscribe, LaserstreamConfig};
use light_event::parse::event_from_light_transaction;
use light_token_interface::state::mint::Mint;
use light_token_interface::state::extensions::ExtensionStruct;
use borsh::BorshDeserialize;

const LIGHT_SYSTEM_PROGRAM: &str = "SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7";
const LIGHT_TOKEN_PROGRAM_ID: &str = "cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m";
const COMPRESSED_MINT_DISCRIMINATOR: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 1];

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. Connect to Laserstream
    let config = LaserstreamConfig::new(
        "https://laserstream-devnet-ewr.helius-rpc.com".to_string(),
        std::env::var("HELIUS_API_KEY")?,
    );

    // 2. Create subscription
    let request = helius_laserstream::grpc::SubscribeRequest {
        transactions: [(
            "light".to_string(),
            helius_laserstream::grpc::SubscribeRequestFilterTransactions {
                vote: Some(false),
                failed: Some(false),
                account_include: vec![LIGHT_SYSTEM_PROGRAM.to_string()],
                ..Default::default()
            },
        )]
        .into(),
        ..Default::default()
    };

    let (stream, _handle) = subscribe(config, request);
    tokio::pin!(stream);

    // 3. Process stream
    while let Some(update) = stream.next().await {
        if let Some(tx) = update?.transaction {
            process_transaction(&tx)?;
        }
    }

    Ok(())
}

fn process_transaction(msg: &TransactionUpdate) -> anyhow::Result<()> {
    // Extract transaction components
    let account_keys = extract_account_keys(&msg.transaction.message);
    let (program_ids, instruction_data, accounts_per_ix) =
        extract_instructions(&msg, &account_keys);

    // 4. Parse events
    match event_from_light_transaction(&program_ids, &instruction_data, accounts_per_ix) {
        Ok(Some(batches)) => {
            for batch in batches {
                process_event(&batch.event)?;
            }
        }
        Ok(None) => {} // No compressed account events
        Err(e) => eprintln!("Parse error: {:?}", e),
    }

    Ok(())
}

fn process_event(event: &PublicTransactionEvent) -> anyhow::Result<()> {
    let light_token_program_id = bs58::decode(LIGHT_TOKEN_PROGRAM_ID).into_vec()?;

    // 5. Extract mints
    for output in event.output_compressed_accounts.iter() {
        let owner = &output.compressed_account.owner;

        // Check owner
        if owner != light_token_program_id.as_slice() {
            continue;
        }

        // Check discriminator
        let data = match &output.compressed_account.data {
            Some(d) if d.discriminator == COMPRESSED_MINT_DISCRIMINATOR => &d.data,
            _ => continue,
        };

        // Deserialize mint
        let mint = Mint::try_from_slice(data)?;

        // 6. Detect new mints
        let is_new = output
            .compressed_account
            .address
            .map(|addr| {
                !event
                    .input_compressed_account_hashes
                    .iter()
                    .any(|h| *h == addr)
            })
            .unwrap_or(true);

        if is_new {
            println!("New mint: {}", bs58::encode(mint.metadata.mint).into_string());

            // 7. Extract metadata
            if let Some((name, symbol, uri)) = extract_metadata(&mint) {
                println!("  Name: {}", name);
                println!("  Symbol: {}", symbol);
                println!("  URI: {}", uri);
            }
        } else {
            println!("Mint update: {}", bs58::encode(mint.metadata.mint).into_string());
            println!("  Supply: {}", mint.base.supply);
        }
    }

    Ok(())
}

// 7. Extract metadata helper
fn extract_metadata(mint: &Mint) -> Option<(String, String, String)> {
    let extensions = mint.extensions.as_ref()?;

    for ext in extensions {
        if let ExtensionStruct::TokenMetadata(m) = ext {
            let name = String::from_utf8_lossy(&m.name).to_string();
            let symbol = String::from_utf8_lossy(&m.symbol).to_string();
            let uri = String::from_utf8_lossy(&m.uri).to_string();
            return Some((name, symbol, uri));
        }
    }
    None
}
```

### Helper Functions

```rust
use solana_transaction_status::UiMessage;

fn extract_account_keys(message: &UiMessage) -> Vec<String> {
    match message {
        UiMessage::Parsed(_) => vec![],
        UiMessage::Raw(msg) => msg.account_keys.clone(),
    }
}

fn extract_instructions(
    tx: &TransactionUpdate,
    account_keys: &[String],
) -> (Vec<Pubkey>, Vec<Vec<u8>>, Vec<Vec<Pubkey>>) {
    let message = &tx.transaction.message;

    let instructions = match message {
        UiMessage::Raw(msg) => &msg.instructions,
        UiMessage::Parsed(_) => return (vec![], vec![], vec![]),
    };

    let mut program_ids = Vec::new();
    let mut instruction_data = Vec::new();
    let mut accounts_per_ix = Vec::new();

    for ix in instructions {
        let program_id_index = ix.program_id_index as usize;
        if program_id_index < account_keys.len() {
            let program_id = bs58::decode(&account_keys[program_id_index])
                .into_vec()
                .ok()
                .and_then(|b| TryInto::<[u8; 32]>::try_into(b).ok())
                .map(Pubkey::from)
                .unwrap_or_default();

            program_ids.push(program_id);
        }

        let data = bs58::decode(&ix.data).into_vec().unwrap_or_default();
        instruction_data.push(data);

        let mut ix_accounts = Vec::new();
        for &account_idx in &ix.accounts {
            let idx = account_idx as usize;
            if idx < account_keys.len() {
                if let Ok(bytes) = bs58::decode(&account_keys[idx]).into_vec() {
                    if let Ok(arr) = TryInto::<[u8; 32]>::try_into(bytes) {
                        ix_accounts.push(Pubkey::from(arr));
                    }
                }
            }
        }
        accounts_per_ix.push(ix_accounts);
    }

    (program_ids, instruction_data, accounts_per_ix)
}
```

## Data Structures

### Mint Layout

```rust
#[repr(C)]
pub struct Mint {
    pub base: BaseMint,           // 82 bytes (SPL-compatible)
    pub metadata: MintMetadata,   // 67 bytes (Light Protocol metadata)
    pub reserved: [u8; 16],       // Reserved for T22 compatibility
    pub account_type: u8,         // 1 = Mint, 2 = Account (at offset 165)
    pub compression: CompressionInfo,
    pub extensions: Option<Vec<ExtensionStruct>>,
}

#[repr(C)]
pub struct BaseMint {
    pub mint_authority: Option<Pubkey>,
    pub supply: u64,
    pub decimals: u8,
    pub is_initialized: bool,
    pub freeze_authority: Option<Pubkey>,
}

#[repr(C)]
pub struct MintMetadata {
    pub version: u8,               // Version for upgradability
    pub mint_decompressed: bool,   // Whether mint has been decompressed
    pub mint: Pubkey,              // PDA derived from mint_signer
    pub mint_signer: [u8; 32],     // Signer pubkey used to derive mint PDA
    pub bump: u8,                  // Bump seed from PDA derivation
}
```

### TokenMetadata Extension

```rust
#[repr(C)]
pub struct TokenMetadata {
    pub update_authority: Pubkey,  // [0u8; 32] = immutable
    pub mint: Pubkey,
    pub name: Vec<u8>,
    pub symbol: Vec<u8>,
    pub uri: Vec<u8>,
    pub additional_metadata: Vec<AdditionalMetadata>,
}

pub struct AdditionalMetadata {
    pub key: Vec<u8>,
    pub value: Vec<u8>,
}
```

### Event Structure

```rust
pub struct PublicTransactionEvent {
    pub input_compressed_account_hashes: Vec<[u8; 32]>,
    pub output_compressed_accounts: Vec<OutputCompressedAccountWithPackedContext>,
    pub output_compressed_account_hashes: Vec<[u8; 32]>,
    pub output_leaf_indices: Vec<u32>,
    // ...
}

pub struct OutputCompressedAccountWithPackedContext {
    pub compressed_account: CompressedAccount,
    pub merkle_tree_index: u8,
}

pub struct CompressedAccount {
    pub owner: Vec<u8>,
    pub lamports: u64,
    pub address: Option<[u8; 32]>,
    pub data: Option<CompressedAccountData>,
}

pub struct CompressedAccountData {
    pub discriminator: [u8; 8],
    pub data: Vec<u8>,
    pub data_hash: [u8; 32],
}
```

## Important Notes

1. **Event Detection**: New mints have `address` not in `input_compressed_account_hashes`. Updates have `address` present in inputs.

2. **Discriminator**: Compressed mints use discriminator `[0, 0, 0, 0, 0, 0, 0, 1]`. Token accounts use `[0, 0, 0, 0, 0, 0, 0, 2]`.

3. **Metadata Parsing**: TokenMetadata is optional. Check `mint.extensions` for `ExtensionStruct::TokenMetadata` variant.

4. **API Key**: Requires Helius API key. Set `HELIUS_API_KEY` environment variable.

5. **Network Selection**:
   - Mainnet: `https://laserstream-mainnet-ewr.helius-rpc.com`
   - Devnet: `https://laserstream-devnet-ewr.helius-rpc.com`

6. **Filtering**: Subscribe to Light System Program (`SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7`) to get all compressed account events.

7. **Updates vs New**: Check if output account address exists in input hashes to distinguish updates from new mints.

~~~~
