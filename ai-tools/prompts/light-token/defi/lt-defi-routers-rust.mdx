~~~~text
---
argument-hint: <project_path>
description: Integrate rent-free AMMs on Solana using Light Protocol router interface (Rust)
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Add router support for rent-free AMMs (Rust)

References:
- Router Guide: https://zkcompression.com/light-token/defi/routers
- SDK Reference: https://docs.rs/light-client/latest/light_client/
- Reference Implementation: https://github.com/Lightprotocol/cp-swap-reference

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Function/Type | Purpose |
|-----------|--------------|---------|
| Fetch Account | get_account_interface() | Returns AccountInterface (superset of Account) |
| Initialize SDK | from_keyed_accounts() | Create program SDK from AccountInterface array |
| Update Cache | update() | Update SDK state with new account data |
| Load Cold Accounts | create_load_instructions() | Generate instructions to load compressed accounts |
| Check Account State | is_cold() | Determine if account needs loading |
| Quote | quote() | Calculate swap output (works for hot or cold) |

### Phase 1: Index project

```bash
grep -r "get_account\|AccountInterface\|LightProgramInterface" src/
grep -r "swap\|quote\|pool" src/
```

### Phase 2: Add dependencies

```toml
[dependencies]
light-client = "0.18.0"
light-sdk = "0.18.0"
example-amm-sdk = "0.1"
solana-sdk = "2.1.6"
tokio = { version = "1.41", features = ["full"] }
dotenvy = "0.15"
serde_json = "1.0"
```

Note: `example-amm-sdk` represents the AMM team's SDK that implements `LightProgramInterface`. Replace with actual AMM SDK package.

### Phase 3: Implement router integration

See Code Reference below for Rust implementation.

**Three Key Changes:**

1. **Use get_account_interface instead of get_account**
   - Returns `AccountInterface` with `Option<ColdContext>`
   - Works for both hot and cold accounts
   - Superset of standard `Account` type

2. **Store AccountInterface in cache**
   - Maintain cache of `&[AccountInterface]`
   - Initialize SDK with `from_keyed_accounts(&[AccountInterface])`
   - Update cache with `update(&[AccountInterface])`

3. **Prepend create_load_instructions when cold**
   - Check if any accounts are cold with `specs.iter().any(|s| s.is_cold())`
   - Generate load instructions only if needed
   - No-op if all accounts are hot

#### Integration Steps

1. **Fetch Account Interfaces**: Replace `get_account` with `get_account_interface`
   - Use `rpc.get_account_interface(&pool_address, &program_id).await?`
   - Returns `AccountInterface` with cold context
   - Works identically for hot and cold accounts

2. **Initialize SDK from Interfaces**: Create program SDK from account data
   - Call `ExampleAmmSdk::from_keyed_accounts(&[pool_interface])?`
   - SDK implements `LightProgramInterface` trait
   - Maintains internal cache of account states

3. **Update SDK State**: Fetch and update related accounts
   - Use `sdk.get_accounts_to_update(&LightInstruction::Swap)` to identify dependencies
   - Fetch with `rpc.get_multiple_account_interfaces(&accounts_to_fetch).await?`
   - Update SDK with `sdk.update(&keyed_accounts)?`

4. **Quote Swap**: Calculate expected output (works for hot or cold)
   - Call `sdk.quote(amount_in, min_out)?`
   - Quoting works identically regardless of account state
   - No special handling needed for cold accounts

5. **Build Transaction**: Create swap transaction with conditional loading
   - Get account specs with `sdk.get_specs_for_instruction(&LightInstruction::Swap)`
   - Check if cold: `specs.iter().any(|s| s.is_cold())`
   - Generate load instructions if needed: `create_load_instructions(&specs, payer, config_pda, rent_sponsor_pda, &rpc).await?`
   - Append swap instruction: `sdk.swap_ix(&swap_params)`

6. **Send Transaction**: Submit to network
   - Use `rpc.create_and_send_transaction(&ixs, &payer.pubkey(), &[&payer]).await?`
   - Load instructions no-op if accounts are hot
   - Transaction executes identically on hot or cold path

### Phase 4: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

## Code Reference

### Full Router Integration

```rust
use light_client::interface::{
    create_load_instructions, AccountSpec, LightProgramInterface,
};
use light_client::rpc::{LightClient, LightClientConfig, Rpc};
use light_sdk::compressible::AccountInterface;
use solana_sdk::{
    instruction::Instruction, pubkey::Pubkey, signature::Keypair, signer::Signer,
};
use std::env;

// Example AMM SDK that implements LightProgramInterface
use example_amm_sdk::{ExampleAmmSdk, LightInstruction, SwapParams};

#[tokio::test(flavor = "multi_thread")]
async fn test_integrate_router() -> Result<(), Box<dyn std::error::Error>> {
    dotenvy::dotenv().ok();

    let api_key = env::var("api_key")
        .expect("api_key environment variable must be set");

    let config = LightClientConfig::devnet(
        Some("https://devnet.helius-rpc.com".to_string()),
        Some(api_key),
    );
    let mut rpc = LightClient::new_with_retry(config, None).await?;

    let payer = load_keypair("~/.config/solana/id.json")?;
    let pool_address = Pubkey::new_unique(); // Your pool address
    let amount_in = 1_000_000u64;
    let min_out = 950_000u64;

    // 1. Fetch account interfaces (works for both hot and cold)
    let pool_interface = rpc
        .get_account_interface(&pool_address, &ExampleAmmSdk::program_id())
        .await?;

    // 2. Initialize SDK from interfaces
    let mut sdk = ExampleAmmSdk::from_keyed_accounts(&[pool_interface])?;

    // 3. Fetch related accounts and update SDK state
    let accounts_to_fetch = sdk.get_accounts_to_update(&LightInstruction::Swap);
    let keyed_accounts = rpc
        .get_multiple_account_interfaces(&accounts_to_fetch)
        .await?;
    sdk.update(&keyed_accounts)?;

    // 4. Quote (works same for hot or cold)
    let quote = sdk.quote(amount_in, min_out)?;
    println!("Expected output: {}", quote.amount_out);

    // 5. Build transaction
    let mut ixs: Vec<Instruction> = vec![];

    // Prepend load instructions if any accounts are cold
    let specs = sdk.get_specs_for_instruction(&LightInstruction::Swap);
    if specs.iter().any(|s| s.is_cold()) {
        let load_ixs = create_load_instructions(
            &specs,
            payer.pubkey(),
            sdk.light_config_pda(),
            sdk.light_rent_sponsor_pda(),
            &rpc,
        )
        .await?;
        ixs.extend(load_ixs);
    }

    // Add actual swap instruction
    ixs.push(sdk.swap_ix(&SwapParams {
        amount_in,
        min_out,
        user: payer.pubkey(),
    })?);

    // 6. Send
    rpc.create_and_send_transaction(&ixs, &payer.pubkey(), &[&payer])
        .await?;

    println!("Swap transaction sent successfully");
    Ok(())
}

fn load_keypair(path: &str) -> Result<Keypair, Box<dyn std::error::Error>> {
    let path = if path.starts_with("~") {
        path.replace("~", &env::var("HOME").unwrap_or_default())
    } else {
        path.to_string()
    };
    let file = std::fs::read_to_string(&path)?;
    let bytes: Vec<u8> = serde_json::from_str(&file)?;
    Ok(Keypair::try_from(&bytes[..])?)
}
```

### Key Types and Traits

```rust
use light_sdk::compressible::{AccountInterface, ColdContext};
use solana_sdk::{account::Account, pubkey::Pubkey};

// AccountInterface (replaces Account)
pub struct AccountInterface {
    pub key: Pubkey,
    pub account: Account,
    pub cold: Option<ColdContext>,
}

impl AccountInterface {
    pub fn is_cold(&self) -> bool {
        self.cold.is_some()
    }

    pub fn is_hot(&self) -> bool {
        self.cold.is_none()
    }
}

// Standard Account (nested inside AccountInterface)
pub struct Account {
    pub lamports: u64,
    pub data: Vec<u8>,
    pub owner: Pubkey,
    pub executable: bool,
    pub rent_epoch: u64,
}

// LightProgramInterface (implemented by AMM SDKs)
pub trait LightProgramInterface<Instruction> {
    fn from_keyed_accounts(accounts: &[AccountInterface]) -> Result<Self, Error>
    where
        Self: Sized;

    fn get_accounts_to_update(&self, ix: &Instruction) -> Vec<AccountToFetch>;

    fn update(&mut self, accounts: &[AccountInterface]) -> Result<(), Error>;

    fn get_specs_for_instruction(&self, ix: &Instruction) -> Vec<AccountSpec>;
}

// AccountSpec (specifies load requirements)
pub struct AccountSpec {
    pub address: Pubkey,
    pub cold_context: Option<ColdContext>,
}

impl AccountSpec {
    pub fn is_cold(&self) -> bool {
        self.cold_context.is_some()
    }
}
```

### Hot vs Cold Account Handling

| Aspect | Hot Account | Cold Account |
|--------|-------------|--------------|
| On-chain state | Yes | Ledger (compressed) |
| get_account_interface | Returns immediately | Returns with ColdContext |
| Quote | Works | Works |
| Swap | Direct execution | Load first, then swap |
| Transaction size | Normal | +100-2400 bytes* |
| Compute units | Normal | +15k-400k CU* |
| Latency | Normal | +0-200ms* |

*Depends on number and type of cold accounts

### When Accounts Go Cold

Accounts become cold after compression by a miner. Compression triggers when accounts are inactive (no lamport bumps from fee payers) for a period, causing virtual rent balance to fall below threshold.

**Best Practice**: Always prepend `create_load_instructions` to swap transactions. This ensures swaps execute regardless of account state and no-ops if accounts are hot.

### Error Handling

```rust
use light_client::error::LightClientError;

match rpc.get_account_interface(&pool_address, &program_id).await {
    Ok(account) => {
        // Account exists (hot or cold)
        // Proceed with quote and swap
    }
    Err(LightClientError::AccountNotFound) => {
        // Account does not exist
    }
    Err(e) => {
        // Other error
        return Err(e.into());
    }
}
```

### Jito Bundle Support (Large Transactions)

If load instructions + swap instructions exceed Solana's 1232 byte limit:

```rust
use solana_sdk::{
    system_instruction, transaction::Transaction, signature::Keypair,
};

const JITO_TIP_ACCOUNTS: &[&str] = &[
    "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
    "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
    "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
    "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
    "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
    "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
    "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
    "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
];

fn jito_tip_instruction(payer: &Pubkey, tip_lamports: u64) -> Instruction {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let tip_account = JITO_TIP_ACCOUNTS[rng.gen_range(0..JITO_TIP_ACCOUNTS.len())];

    system_instruction::transfer(
        payer,
        &Pubkey::from_str(tip_account).unwrap(),
        tip_lamports,
    )
}

async fn send_jito_bundle(
    load_ixs: Vec<Instruction>,
    swap_ixs: Vec<Instruction>,
    payer: &Keypair,
    recent_blockhash: Hash,
) -> Result<(), Box<dyn std::error::Error>> {
    // Create load transaction
    let load_tx = Transaction::new_signed_with_payer(
        &load_ixs,
        Some(&payer.pubkey()),
        &[payer],
        recent_blockhash,
    );

    // Add tip to swap transaction
    let mut swap_with_tip = swap_ixs;
    swap_with_tip.push(jito_tip_instruction(&payer.pubkey(), 10_000)); // 10k lamports

    let swap_tx = Transaction::new_signed_with_payer(
        &swap_with_tip,
        Some(&payer.pubkey()),
        &[payer],
        recent_blockhash,
    );

    // Serialize transactions
    let load_tx_base64 = base64::encode(bincode::serialize(&load_tx)?);
    let swap_tx_base64 = base64::encode(bincode::serialize(&swap_tx)?);

    // Send bundle to Jito
    let client = reqwest::Client::new();
    let response = client
        .post("https://mainnet.block-engine.jito.wtf/api/v1/bundles")
        .json(&serde_json::json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "sendBundle",
            "params": [[load_tx_base64, swap_tx_base64], {"encoding": "base64"}]
        }))
        .send()
        .await?;

    println!("Bundle response: {:?}", response.text().await?);
    Ok(())
}
```

## Important Notes

1. **Swap Instructions Unchanged**: Swap instructions remain identical for hot and cold accounts. Only difference is prepending load instructions when cold.

2. **Quote Always Works**: `get_account_interface` returns full account state via the same `Account` type regardless of hot/cold status. Quoting works identically.

3. **RPC Provider Support**: Interface endpoints require RPC providers like Helius or Triton, or self-hosted Photon indexer.

4. **Indexer Dependency**: Hot markets work as long as Solana is up. Cold accounts cannot load until indexer/RPC recovers. Compression is cryptographically verifiable, so integrity and safety are independent of indexer.

5. **API Beta Status**: Router integration API is in beta and subject to change.

## Reference Implementation

| Resource | Link |
|----------|------|
| AMM Program | https://github.com/Lightprotocol/cp-swap-reference |
| LightProgramInterface Trait Impl | https://github.com/Lightprotocol/cp-swap-reference/blob/main/programs/cp-swap/tests/program.rs#L409 |
| Client Test | https://github.com/Lightprotocol/cp-swap-reference/blob/main/programs/cp-swap/tests/program.rs |

## Support

Questions or need hands-on support?
- Telegram: https://t.me/swen_light
- Email: support@lightprotocol.com
- Discord: https://discord.com/invite/7cJ8BhAXhu

~~~~
