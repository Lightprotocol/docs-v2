~~~~text
---
argument-hint: <project_path>
description: Integrate Light SDK for rent-free DeFi accounts in TypeScript
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Integrate rent-free DeFi accounts (TypeScript)

References:
- Program Guide: https://zkcompression.com/light-token/defi/programs
- SDK Reference: https://lightprotocol.github.io/light-protocol/compressed-token/index.html
- CP-Swap Reference: https://github.com/Lightprotocol/cp-swap-reference
- Light Protocol Source: /home/tilo/Workspace/light-protocol

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Operation | Function/Interface | Purpose |
|-----------|-------------------|---------|
| Account Interface | AccountInterface | Unified interface for hot and cold account state |
| Load Accounts | createLoadAccountsParams() | Build instructions to load compressed accounts |
| Load ATA | createLoadAtaInstructionsFromInterface() | Load compressed token accounts |
| Get Account | getAccountInterface() | Fetch account in unified format |
| Get ATA | getAtaInterface() | Fetch token account with load context |
| Find ATA | getAssociatedTokenAddressInterface() | Derive ATA address |
| Connect RPC | createRpc() | Connect to ZK Compression RPC endpoint |

### Phase 1: Understand DeFi program integration

Read the source guide at /home/tilo/Workspace/docs/light-token/defi/programs.mdx to understand:
- What changes in program structure (LightAccount, LightAccounts, light_program)
- How rent-free accounts work (hot vs cold state)
- Client SDK integration pattern (LightProgramInterface trait)
- Load instructions workflow

### Phase 2: Index project structure

```bash
grep -r "import.*@solana/web3.js\|import.*@lightprotocol" src/
grep -r "class.*Program\|interface.*Program\|type.*Program" src/
```

Identify:
- Existing program integration points
- Account fetching patterns
- Transaction building logic

### Phase 3: Install dependencies

```bash
npm install --save \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @solana/web3.js
```

### Phase 4: Implement client SDK

**Two Integration Approaches:**

#### Approach A: Direct Load Instructions (Simple)

Use when you have a simple DeFi program and don't need trait abstraction.

1. **Fetch Accounts**: Get program accounts with load context
   - Use `getAccountInterface()` for general accounts
   - Use `getAtaInterface()` for token accounts
   - Returns `AccountInterface` with `.isHot()`, `.isCold()`, `.loadContext`

2. **Check State**: Determine if accounts need loading
   - Hot accounts: Work normally, no load needed
   - Cold accounts: Have `loadContext`, need decompression

3. **Build Load Instructions**: Create instructions to load cold accounts
   - Call `createLoadAccountsParams()` with program accounts and ATAs
   - Returns `{ decompressParams, ataInstructions }`
   - Add to transaction before your program instruction

4. **Send Transaction**: Build and submit transaction with load + instruction
   - Include `ataInstructions` first
   - Add decompress instruction if `decompressParams` exists
   - Add your program instruction last

#### Approach B: LightProgramInterface Trait (Advanced)

Use when building a reusable SDK or router integration.

1. **Define Account Specs**: Create PDA and token account specifications
   - Use `PdaSpec<YourVariant>` for program PDAs
   - Use `TokenSpec` for token vaults
   - Include seeds for account derivation

2. **Implement Interface**: Create class implementing `LightProgramInterface`
   - `from_keyed_accounts()`: Parse accounts into SDK state
   - `get_accounts_to_update()`: List accounts needed for instruction
   - `update()`: Update SDK state with fresh accounts
   - `get_specs_for_instruction()`: Return specs for loading

3. **Build Load Instructions**: Use trait methods for standardized loading
   - Fetch accounts via `get_accounts_to_update()`
   - Update SDK via `update()`
   - Get specs via `get_specs_for_instruction()`
   - Pass specs to `create_load_instructions()`

4. **Router Integration**: SDK can be used by aggregators
   - Routers fetch accounts using `AccountToFetch`
   - Update SDK state with fresh data
   - Build load instructions from specs
   - Execute user instruction

### Phase 5: Implement account loading

See Code Reference below for both approaches.

**Key Concepts:**

1. **AccountInterface**: Unified account representation
   - `.isHot()`: Returns true if account is onchain
   - `.isCold()`: Returns true if account is compressed
   - `.loadContext`: Contains MerkleContext for loading (undefined for hot accounts)
   - `.parsed`: Parsed account data (program-specific)

2. **CompressibleAccountInput**: Input for load params
   - `address`: Account public key
   - `accountType`: Type key for packing ("poolState", "cTokenData", etc.)
   - `tokenVariant`: Optional variant for token vaults ("lpVault", "token0Vault")
   - `info`: ParsedAccountInfoInterface with parsed data and loadContext

3. **LoadResult**: Output from createLoadAccountsParams
   - `decompressParams`: Params for decompressAccountsIdempotent (null if none)
   - `ataInstructions`: Instructions to load ATAs

4. **State Transitions**:
   - Hot (active): Account is onchain, works normally
   - Cold (inactive): Account is compressed, needs load instruction
   - Auto-compression: Triggered by miners when virtual rent is low

### Phase 6: Test

Run the client code. On failure, debug and retry. Assign debugging to subagents with Task tool.

For localnet testing:
```bash
light test-validator
```

For devnet/mainnet, ensure RPC endpoint supports ZK Compression (Helius, Triton).

**Test Scenarios:**
- Hot path: Accounts are active, no load needed
- Cold path: Accounts are compressed, load instructions required
- Mixed: Some accounts hot, some cold
- Time warp: Advance slots to trigger compression

## Code Reference

### Approach A: Direct Load Instructions

```typescript
import "dotenv/config";
import { Keypair, PublicKey, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { createRpc } from "@lightprotocol/stateless.js";
import {
    getAccountInterface,
    getAtaInterface,
    getAssociatedTokenAddressInterface,
    createLoadAccountsParams,
} from "@lightprotocol/compressed-token";
import { homedir } from "os";
import { readFileSync } from "fs";

const RPC_URL = `https://devnet.helius-rpc.com?api-key=${process.env.API_KEY!}`;
const payer = Keypair.fromSecretKey(
    new Uint8Array(
        JSON.parse(readFileSync(`${homedir()}/.config/solana/id.json`, "utf8"))
    )
);

(async function () {
    const rpc = createRpc(RPC_URL);

    // Your program ID and account addresses
    const programId = new PublicKey("YourProgramId");
    const poolAddress = new PublicKey("YourPoolAddress");
    const token0Mint = new PublicKey("Token0MintAddress");
    const token0Vault = new PublicKey("Token0VaultAddress");

    // 1. Fetch program accounts with load context
    const poolInfo = await getAccountInterface(
        rpc,
        poolAddress,
        programId
    );

    // 2. Fetch token vaults
    const vault0Info = await getAtaInterface(
        rpc,
        token0Vault,
        poolAddress, // owner
        token0Mint,  // mint
        undefined,   // tokenProgramId (defaults to Token Program)
    );

    // 3. Fetch user ATA
    const userAta = getAssociatedTokenAddressInterface(token0Mint, payer.publicKey);
    const userAtaInfo = await getAtaInterface(
        rpc,
        userAta,
        payer.publicKey,
        token0Mint
    );

    // 4. Check if accounts need loading
    if (poolInfo.isCold() || vault0Info.isCold()) {
        console.log("Accounts are cold, creating load instructions");

        // 5. Build load instructions
        const loadResult = await createLoadAccountsParams(
            rpc,
            payer.publicKey,
            programId,
            [
                {
                    address: poolAddress,
                    accountType: "poolState",
                    info: poolInfo,
                },
                {
                    address: token0Vault,
                    accountType: "cTokenData",
                    tokenVariant: "token0Vault",
                    info: vault0Info,
                },
            ],
            [userAtaInfo]
        );

        // 6. Build transaction with load instructions
        const tx = new Transaction();

        // Add ATA load instructions
        tx.add(...loadResult.ataInstructions);

        // Add program decompress instruction if needed
        if (loadResult.decompressParams) {
            // Call your program's decompressAccountsIdempotent instruction
            // with the params from loadResult.decompressParams
            // Example (using Anchor):
            // const decompressIx = await program.methods
            //     .decompressAccountsIdempotent(
            //         loadResult.decompressParams.proofOption,
            //         loadResult.decompressParams.compressedAccounts,
            //         loadResult.decompressParams.systemAccountsOffset,
            //     )
            //     .remainingAccounts(loadResult.decompressParams.remainingAccounts)
            //     .instruction();
            // tx.add(decompressIx);
        }

        // 7. Add your program instruction
        // tx.add(yourProgramInstruction);

        // 8. Send transaction
        const signature = await sendAndConfirmTransaction(rpc, tx, [payer]);
        console.log("Load transaction:", signature);
    } else {
        console.log("Accounts are hot, no load needed");
        // Build and send your program instruction directly
    }
})();
```

### Approach B: LightProgramInterface Implementation

```typescript
import { PublicKey } from "@solana/web3.js";
import { Rpc } from "@lightprotocol/stateless.js";
import { AccountInterface } from "@lightprotocol/compressed-token";

// 1. Define your account variant (for PDA specs)
export enum AmmAccountVariant {
    PoolState = "PoolState",
    ObservationState = "ObservationState",
}

// 2. Define PDA spec type
export interface PdaSpec<T> {
    variant: T;
    seeds: Buffer[];
}

// 3. Define account to fetch type
export interface AccountToFetch {
    address: PublicKey;
    type: "pda" | "token";
}

// 4. Define account spec (for loading)
export type AccountSpec<T> =
    | { type: "Pda"; spec: PdaSpec<T> }
    | { type: "Token"; address: PublicKey };

// 5. Implement LightProgramInterface
export interface LightProgramInterface<TVariant, TInstruction> {
    // Parse accounts into SDK state
    from_keyed_accounts(accounts: AccountInterface[]): this;

    // List accounts needed for instruction
    get_accounts_to_update(instruction: TInstruction): AccountToFetch[];

    // Update SDK state with fresh accounts
    update(accounts: AccountInterface[]): void;

    // Return specs for loading cold accounts
    get_specs_for_instruction(instruction: TInstruction): AccountSpec<TVariant>[];

    // Program ID
    program_id(): PublicKey;
}

// 6. Example SDK implementation
export class AmmSdk implements LightProgramInterface<AmmAccountVariant, AmmInstruction> {
    private poolState?: AccountInterface;
    private token0Vault?: AccountInterface;
    private token1Vault?: AccountInterface;
    private lpMint?: AccountInterface;

    // Account specs for loading
    private programOwnedSpecs: Map<string, PdaSpec<AmmAccountVariant>> = new Map();

    program_id(): PublicKey {
        return new PublicKey("YourProgramId");
    }

    from_keyed_accounts(accounts: AccountInterface[]): this {
        for (const account of accounts) {
            this.parseAccount(account);
        }
        return this;
    }

    get_accounts_to_update(instruction: AmmInstruction): AccountToFetch[] {
        const accounts: AccountToFetch[] = [];

        switch (instruction.type) {
            case "Swap":
                if (this.poolState) {
                    accounts.push({
                        address: this.poolState.address,
                        type: "pda",
                    });
                }
                if (this.token0Vault) {
                    accounts.push({
                        address: this.token0Vault.address,
                        type: "token",
                    });
                }
                if (this.token1Vault) {
                    accounts.push({
                        address: this.token1Vault.address,
                        type: "token",
                    });
                }
                break;
            // ... other instructions
        }

        return accounts;
    }

    update(accounts: AccountInterface[]): void {
        for (const account of accounts) {
            this.parseAccount(account);
        }
    }

    get_specs_for_instruction(instruction: AmmInstruction): AccountSpec<AmmAccountVariant>[] {
        const specs: AccountSpec<AmmAccountVariant>[] = [];

        // Add PDA specs
        for (const spec of this.programOwnedSpecs.values()) {
            specs.push({ type: "Pda", spec });
        }

        // Add token specs
        if (this.token0Vault) {
            specs.push({ type: "Token", address: this.token0Vault.address });
        }
        if (this.token1Vault) {
            specs.push({ type: "Token", address: this.token1Vault.address });
        }

        return specs;
    }

    private parseAccount(account: AccountInterface): void {
        // Parse account based on discriminator or seeds
        // Store in SDK state and add specs for loading

        // Example for pool state:
        // this.poolState = account;
        // this.programOwnedSpecs.set("poolState", {
        //     variant: AmmAccountVariant.PoolState,
        //     seeds: [Buffer.from("pool"), token0.toBuffer(), token1.toBuffer()],
        // });
    }
}

// 7. Define instruction types
export type AmmInstruction =
    | { type: "Swap"; amountIn: bigint; minOut: bigint }
    | { type: "Deposit"; amount0: bigint; amount1: bigint }
    | { type: "Withdraw"; lpAmount: bigint };

// 8. Usage example
async function executeSwap(
    rpc: Rpc,
    payer: Keypair,
    poolAddress: PublicKey,
    amountIn: bigint,
    minOut: bigint
) {
    // Initialize SDK
    const sdk = new AmmSdk();

    // Fetch pool account
    const poolAccount = await getAccountInterface(rpc, poolAddress, sdk.program_id());
    sdk.from_keyed_accounts([poolAccount]);

    // Define instruction
    const instruction: AmmInstruction = {
        type: "Swap",
        amountIn,
        minOut,
    };

    // Get accounts to fetch
    const accountsToFetch = sdk.get_accounts_to_update(instruction);

    // Fetch accounts (simplified - use getAccountInterface/getAtaInterface)
    const accounts: AccountInterface[] = [];
    for (const toFetch of accountsToFetch) {
        if (toFetch.type === "pda") {
            const account = await getAccountInterface(rpc, toFetch.address, sdk.program_id());
            accounts.push(account);
        } else {
            // Fetch token account
        }
    }

    // Update SDK with fresh data
    sdk.update(accounts);

    // Get specs for loading
    const specs = sdk.get_specs_for_instruction(instruction);

    // Build load instructions (using hypothetical create_load_instructions)
    // const loadInstructions = await create_load_instructions(rpc, payer, specs);

    // Build transaction
    // const tx = new Transaction();
    // tx.add(...loadInstructions);
    // tx.add(swapInstruction);
    // await sendAndConfirmTransaction(rpc, tx, [payer]);
}
```

### Key Differences

| Aspect | Direct Load | Trait Implementation |
|--------|-------------|---------------------|
| Complexity | Simpler | More structured |
| Reusability | One-off integration | Reusable SDK |
| Router Support | Manual | Automatic |
| Account Parsing | Manual | Encapsulated |
| Use Case | Single program | Multi-program aggregator |

### Account State Management

```typescript
import { AccountInterface } from "@lightprotocol/compressed-token";

function handleAccountState(account: AccountInterface) {
    if (account.isHot()) {
        // Account is onchain, works normally
        console.log("Hot account - no load needed");
        // Use account.data directly
    } else if (account.isCold()) {
        // Account is compressed, needs load instruction
        console.log("Cold account - load required");
        console.log("Load context:", account.loadContext);
        // Build load instruction before using
    }
}
```

### Load Instructions Flow

```typescript
import { createLoadAccountsParams } from "@lightprotocol/compressed-token";

async function buildLoadInstructions(
    rpc: Rpc,
    payer: PublicKey,
    programId: PublicKey,
    programAccounts: Array<{
        address: PublicKey;
        accountType: string;
        tokenVariant?: string;
        info: AccountInterface;
    }>,
    atas: AccountInterface[]
) {
    const result = await createLoadAccountsParams(
        rpc,
        payer,
        programId,
        programAccounts,
        atas
    );

    // result.ataInstructions: Instructions to load user ATAs
    // result.decompressParams: Params for decompressAccountsIdempotent

    return result;
}
```

### Important Notes

1. **Account Interface**: `AccountInterface` unifies hot and cold accounts
   - Hot accounts: Return account data directly
   - Cold accounts: Include `loadContext` for loading

2. **Load Instructions**: Always add before program instruction
   - ATA load instructions first
   - Decompress instruction second
   - Program instruction last

3. **Compute Units**: Budget for load operations
   - Base: 50,000 CU
   - Validity proof: +100,000 CU
   - Per compressed account: +30,000 CU

4. **Testing**: Use `light test-validator` for local testing
   - Warp slots forward to trigger compression
   - Test hot, cold, and mixed scenarios

5. **RPC Requirements**: Use ZK Compression RPC
   - Devnet: Helius with API key
   - Mainnet: Helius or Triton
   - Localnet: `light test-validator`

6. **Program Requirements**: Your program needs
   - `#[light_program]` macro on module
   - `#[derive(LightAccounts)]` on accounts struct
   - `#[light_account]` annotations on init accounts
   - `decompressAccountsIdempotent` instruction for loading

### Reference Implementation

| Resource | Link |
|----------|------|
| CP-Swap Reference | https://github.com/Lightprotocol/cp-swap-reference |
| CpSwapSdk Implementation | programs/cp-swap/tests/program.rs#L409 |
| Test Example | programs/cp-swap/tests/program.rs |
| Load Instructions | js/compressed-token/src/v3/instructions/create-load-accounts-params.ts |
| Account Interface | js/compressed-token/src/v3/get-account-interface.ts |

~~~~
