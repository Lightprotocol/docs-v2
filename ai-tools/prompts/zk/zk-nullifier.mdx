---
argument-hint: <project_path>
description: Implement ZK nullifiers to prevent double-spending using compressed accounts
allowed-tools: [Bash, Read, Glob, Grep, Task, mcp__deepwiki, mcp__zkcompression]
---

## Task: Implement ZK nullifiers to prevent double-spending

Implement nullifiers using compressed accounts on Solana. Nullifiers are deterministically derived hashes that ensure an action (e.g., spending a private state) can only be performed once, without revealing which state was spent.

References:
- Guide: https://zkcompression.com/zk/overview#nullifiers-on-solana
- SDK Reference: https://docs.rs/light-sdk/latest/light_sdk/
- GitHub Example: https://github.com/Lightprotocol/program-examples/tree/main/zk/nullifier

MCP:
* deepwiki https://mcp.deepwiki.com/mcp
* zkcompression https://www.zkcompression.com/mcp

## Workflow

- This plan must execute without user intervention
- All questions have been resolved in planning phase
- If blocked, find alternative approach - do not stop
- Keep working until ALL todos are complete
- Use Task tool with subagents for parallel research or when stuck
- Use subagents with Read, Glob, Grep, and Deepwiki permissions when stuck
- Always assign Tasks to subagents and tell the user

## DeepWiki fallback

```
mcp__deepwiki__read_wiki_structure("Lightprotocol/light-protocol"),
mcp__deepwiki__read_wiki_contents("Lightprotocol/light-protocol"),
mcp__deepwiki__ask_question("Lightprotocol/light-protocol", "<question>")
```

## Quick Reference

| Storage | Cost per nullifier | Persistence |
|---------|-------------------|-------------|
| PDA | ~0.001 SOL (890,880 lamports) | Permanent rent lock |
| Compressed PDA | ~0.000015 SOL (15,000 lamports) | Rent-free |

### What are nullifiers?

A nullifier is a hash derived from your secret and the leaf the transaction is using. When you use private state (stored in a Merkle tree leaf), you publish the nullifier to invalidate the state and prevent double spending. The program stores all nullifiers in a set. If anyone tries to spend the same leaf again, the nullifier would match one already stored, so the transaction fails. The nullifier reveals nothing about which leaf was spent.

### Phase 1: Index project

```bash
find . -name "Cargo.toml" -o -name "lib.rs" -o -name "Anchor.toml"
```

### Phase 2: Add dependencies

Add to `programs/[name]/Cargo.toml`:

```toml
[dependencies]
anchor-lang = "0.31.1"
borsh = "0.10.4"
light-sdk = { version = "0.18.0", features = ["anchor", "anchor-discriminator", "cpi-context"] }
```

For TypeScript tests, add to `package.json`:

```json
{
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.1",
    "@lightprotocol/stateless.js": "latest"
  }
}
```

### Phase 3: Implement program

See Code Reference below. Implementation follows these steps:

1. **Program entry point**: Define instruction that accepts nullifiers and validity proof
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L14-L31
2. **Proof verification placeholder**: Add your Groth16 proof verification logic
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L19-L23
3. **CPI signer constant**: Derive authority PDA for Light System Program CPIs
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L62-L63
4. **Nullifier prefix constant**: Define seed prefix for nullifier address derivation
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L65
5. **Nullifier account struct**: Empty struct with `LightDiscriminator`
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L59-L60
6. **Instruction data struct**: Define parameters for proof, address tree info, state tree index
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L67-L73
7. **Create nullifiers helper**: Loop through nullifiers, derive addresses, create compressed accounts
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L81-L132
8. **Address derivation**: Use `derive_address()` with nullifier prefix and nullifier value
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L108-L112
9. **CPI to Light System Program**: Batch create all nullifier accounts
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/programs/nullifier/src/lib.rs#L127-L129

### Phase 4: Implement client

Client implementation for TypeScript tests:

1. **Setup RPC connection**: Connect to local validator with Light RPC and indexer endpoints
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L20-L25
2. **Generate nullifier values**: Random 32-byte values (replace with actual hash computation)
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L47-L49
3. **Derive nullifier addresses**: Use `deriveAddressV2()` with nullifier prefix and value
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L136-L139
4. **Fetch validity proof**: Request proof that addresses don't exist in tree
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L142
5. **Build instruction data**: Pack proof, address tree info, state tree index
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L144-L161
6. **Submit transaction**: Call `create_nullifier` with instruction data
   - Source: https://github.com/Lightprotocol/program-examples/blob/main/zk/nullifier/ts-tests/nullifier.test.ts#L58-L71

### Phase 5: Test

Build and test the program:

```bash
# Build program
cargo build-sbf

# Start local validator (in separate terminal)
light test-validator

# Run TypeScript tests
npm install
npm run test:ts
```

On failure, debug and retry. Assign debugging to subagents with Task tool.

## Code Reference

### Full Anchor Program

```rust
#![allow(unexpected_cfgs)]
#![allow(deprecated)]

use anchor_lang::prelude::*;
use nullifier_creation::{create_nullifiers, NullifierInstructionData};

declare_id!("Bw8aty8LJY5Kg2b6djghjWGwt6cBc1tVQUoreUehvVq4");

#[program]
pub mod nullifier {
    use super::*;

    /// Creates nullifier accounts for the provided nullifier values.
    pub fn create_nullifier<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateNullifierAccounts<'info>>,
        data: NullifierInstructionData,
        nullifiers: Vec<[u8; 32]>,
    ) -> Result<()> {
        // Verify your proof here. Use nullifiers as public inputs
        // among your other public inputs.
        // Example:
        // let public_inputs = [...nullifiers, ...your_other_inputs];
        // Groth16Verifier::new(...).verify()?;

        create_nullifiers(
            &nullifiers,
            data,
            ctx.accounts.signer.as_ref(),
            ctx.remaining_accounts,
        )
    }
}

#[derive(Accounts)]
pub struct CreateNullifierAccounts<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
}

pub mod nullifier_creation {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    use light_sdk::account::LightAccount;
    use light_sdk::cpi::v2::CpiAccounts;
    use light_sdk::{
        address::{v2::derive_address, NewAddressParamsAssignedPacked},
        cpi::{v2::LightSystemProgramCpi, InvokeLightSystemProgram, LightCpiInstruction},
        derive_light_cpi_signer,
        instruction::{PackedAddressTreeInfo, ValidityProof},
        LightDiscriminator,
    };
    use light_sdk::CpiSigner;
    #[error_code]
    pub enum ErrorCode {
        #[msg("Not enough keys in remaining accounts")]
        AccountNotEnoughKeys,
    }

    #[derive(Clone, Debug, Default, BorshSerialize, BorshDeserialize, LightDiscriminator)]
    pub struct NullifierAccount {}

    pub const LIGHT_CPI_SIGNER: CpiSigner =
        derive_light_cpi_signer!("Bw8aty8LJY5Kg2b6djghjWGwt6cBc1tVQUoreUehvVq4");

    pub const NULLIFIER_PREFIX: &[u8] = b"nullifier";

    #[derive(Clone, Debug, AnchorSerialize, AnchorDeserialize)]
    pub struct NullifierInstructionData {
        pub proof: ValidityProof,
        pub address_tree_info: PackedAddressTreeInfo,
        pub output_state_tree_index: u8,
        pub system_accounts_offset: u8,
    }

    /// Creates nullifier compressed pdas for the given nullifier values.
    ///
    /// # Arguments
    /// * `nullifiers` - Slice of nullifier values to create compressed pdas for
    /// * `data` - Instruction data with proof and tree info
    /// * `remaining_accounts` - Remaining accounts must contain zk compression system program accounts and Merkle trees.
    pub fn create_nullifiers<'info>(
        nullifiers: &[[u8; 32]],
        data: NullifierInstructionData,
        signer: &AccountInfo<'info>,
        remaining_accounts: &[AccountInfo<'info>],
    ) -> Result<()> {
        let light_cpi_accounts = CpiAccounts::new(
            signer,
            &remaining_accounts[data.system_accounts_offset as usize..],
            LIGHT_CPI_SIGNER,
        );

        let address_tree_pubkey = data
            .address_tree_info
            .get_tree_pubkey(&light_cpi_accounts)
            .map_err(|_| ErrorCode::AccountNotEnoughKeys)?;

        if address_tree_pubkey.to_bytes() != light_sdk::constants::ADDRESS_TREE_V2 {
            msg!("Invalid address tree");
            return Err(ProgramError::InvalidAccountData.into());
        }

        let mut cpi_builder = LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, data.proof);
        let mut new_address_params: Vec<NewAddressParamsAssignedPacked> =
            Vec::with_capacity(nullifiers.len());

        for (i, nullifier) in nullifiers.iter().enumerate() {
            let (address, address_seed) = derive_address(
                &[NULLIFIER_PREFIX, nullifier.as_slice()],
                &address_tree_pubkey,
                &crate::ID,
            );

            let nullifier_account = LightAccount::<NullifierAccount>::new_init(
                &crate::ID,
                Some(address),
                data.output_state_tree_index,
            );

            cpi_builder = cpi_builder.with_light_account(nullifier_account)?;
            new_address_params.push(
                data.address_tree_info
                    .into_new_address_params_assigned_packed(address_seed, Some(i as u8)),
            );
        }

        cpi_builder
            .with_new_addresses(&new_address_params)
            .invoke(light_cpi_accounts)?;

        Ok(())
    }
}
```

### Client Test (TypeScript)

```typescript
import { web3, Program, AnchorProvider, setProvider } from "@coral-xyz/anchor";
import { createRpc, Rpc, sleep, confirmTx } from "@lightprotocol/stateless.js";
import * as assert from "assert";
import * as path from "path";
import * as fs from "fs";

const IDL = JSON.parse(
  fs.readFileSync(path.join(process.cwd(), "target/idl/nullifier.json"), "utf8")
);

const PROGRAM_ID = new web3.PublicKey(IDL.address);

describe("nullifier", () => {
  let rpc: Rpc;
  let signer: web3.Keypair;
  let program: Program;

  before(async () => {
    rpc = createRpc(
      "http://127.0.0.1:8899",
      "http://127.0.0.1:8784",
      "http://127.0.0.1:3001",
      { commitment: "confirmed" }
    );

    signer = web3.Keypair.generate();
    await rpc.requestAirdrop(signer.publicKey, web3.LAMPORTS_PER_SOL);
    await sleep(2000);

    const wallet = {
      publicKey: signer.publicKey,
      signTransaction: async (tx: web3.Transaction) => {
        tx.sign(signer);
        return tx;
      },
      signAllTransactions: async (txs: web3.Transaction[]) => {
        txs.forEach((tx) => tx.sign(signer));
        return txs;
      },
    };
    const provider = new AnchorProvider(rpc, wallet as any, { commitment: "confirmed" });
    setProvider(provider);
    program = new Program(IDL, provider);
  });

  function randomBytes32(): Uint8Array {
    return web3.Keypair.generate().publicKey.toBytes();
  }

  describe("Single nullifier", () => {
    it("should create a nullifier", async () => {
      const nullifier = randomBytes32();

      const { data, remainingAccounts } = await createNullifierInstructionData(
        rpc, PROGRAM_ID, [nullifier]
      );
      const ix = await program.methods
        .createNullifier(data, [Array.from(nullifier)])
        .accounts({ signer: signer.publicKey })
        .remainingAccounts(remainingAccounts)
        .instruction();
      const computeIx = web3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 });

      const tx = new web3.Transaction().add(computeIx, ix);
      tx.recentBlockhash = (await rpc.getLatestBlockhash()).blockhash;
      tx.feePayer = signer.publicKey;
      tx.sign(signer);

      const sig = await rpc.sendTransaction(tx, [signer]);
      await confirmTx(rpc, sig);

      console.log("Tx:", sig);

      const slot = await rpc.getSlot();
      await rpc.confirmTransactionIndexed(slot);

      const accounts = await rpc.getCompressedAccountsByOwner(PROGRAM_ID);
      assert.ok(accounts.items.length > 0, "Nullifier account should be created");
    });
  });

  describe("Multiple nullifiers", () => {
    it("should create multiple nullifiers in one transaction", async () => {
      const nullifiers = [randomBytes32(), randomBytes32()];

      const { data, remainingAccounts } = await createNullifierInstructionData(
        rpc, PROGRAM_ID, nullifiers
      );
      const ix = await program.methods
        .createNullifier(data, nullifiers.map((n) => Array.from(n)))
        .accounts({ signer: signer.publicKey })
        .remainingAccounts(remainingAccounts)
        .instruction();
      const computeIx = web3.ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 });

      const tx = new web3.Transaction().add(computeIx, ix);
      tx.recentBlockhash = (await rpc.getLatestBlockhash()).blockhash;
      tx.feePayer = signer.publicKey;
      tx.sign(signer);

      const sig = await rpc.sendTransaction(tx, [signer]);
      await confirmTx(rpc, sig);

      console.log("Tx:", sig);

      const slot = await rpc.getSlot();
      await rpc.confirmTransactionIndexed(slot);
    });
  });
});

async function createNullifierInstructionData(
  rpc: Rpc,
  programId: web3.PublicKey,
  nullifiers: Uint8Array[]
) {
  const {
    bn,
    deriveAddressSeedV2,
    deriveAddressV2,
    batchAddressTree,
    PackedAccounts,
    SystemAccountMetaConfig,
    defaultTestStateTreeAccounts,
    featureFlags,
    VERSION,
  } = await import("@lightprotocol/stateless.js");

  (featureFlags as any).version = VERSION.V2;

  const NULLIFIER_PREFIX = Buffer.from("nullifier");
  const addressTree = new web3.PublicKey(batchAddressTree);
  const outputStateTree = defaultTestStateTreeAccounts().merkleTree;

  const addressesWithTree = nullifiers.map((nullifier) => {
    const seed = deriveAddressSeedV2([NULLIFIER_PREFIX, nullifier]);
    const address = deriveAddressV2(seed, addressTree, programId);
    return { tree: addressTree, queue: addressTree, address: bn(address.toBytes()) };
  });

  const proofResult = await rpc.getValidityProofV0([], addressesWithTree);

  const remainingAccounts = new PackedAccounts();
  remainingAccounts.addSystemAccountsV2(SystemAccountMetaConfig.new(programId));

  const addressMerkleTreeIndex = remainingAccounts.insertOrGet(addressTree);
  const outputStateTreeIndex = remainingAccounts.insertOrGet(outputStateTree);

  const { remainingAccounts: accountMetas, systemStart } = remainingAccounts.toAccountMetas();

  const data = {
    proof: { 0: proofResult.compressedProof },
    addressTreeInfo: {
      addressMerkleTreePubkeyIndex: addressMerkleTreeIndex,
      addressQueuePubkeyIndex: addressMerkleTreeIndex,
      rootIndex: proofResult.rootIndices[0],
    },
    outputStateTreeIndex,
    systemAccountsOffset: systemStart,
  };

  return { data, remainingAccounts: accountMetas };
}
```

## Key Concepts

### Nullifiers for Privacy and Double-Spend Prevention

Nullifiers are cryptographic primitives that prevent double-spending in privacy-preserving systems. Key properties:

1. **Deterministic**: Same input always produces same nullifier
2. **One-way**: Cannot reverse nullifier to find original input
3. **Unlinkable**: Cannot link nullifier to source leaf/state
4. **Unique**: Each nullifier represents one specific action

### How Nullifiers Work

```
User Action → Compute nullifier = hash(secret, leaf_data)
             → Submit to program
             → Program creates compressed account with nullifier as seed
             → If account already exists → Transaction fails (double-spend prevented)
             → If account doesn't exist → Transaction succeeds
```

### Storage Comparison

**Traditional PDA Nullifiers:**
- Created with `create_account()` using nullifier as PDA seed
- Require rent-exemption (890,880 lamports per nullifier)
- Cannot be closed (permanent storage)
- Standard Solana account model

**Compressed PDA Nullifiers:**
- Created via CPI to Light System Program
- Pay once for state tree space (15,000 lamports)
- Rent-free (no ongoing costs)
- Same derivation pattern, different storage mechanism
- 59x more cost-efficient

### Integration with ZK Proofs

Typical flow in a privacy-preserving application:

1. **Off-chain**: Generate ZK proof with nullifiers as public inputs
2. **On-chain**: Verify proof in your program (using Groth16)
3. **On-chain**: Call `create_nullifiers()` to persist nullifiers
4. **Light System Program**: Verifies addresses don't exist, creates accounts
5. **Result**: If nullifier already exists, entire transaction fails

### Security Considerations

- **Address tree validation**: Always verify `address_tree_pubkey.to_bytes() == ADDRESS_TREE_V2`
- **Proof verification**: Verify ZK proof before creating nullifiers
- **Public inputs**: Nullifiers must be included as public inputs to your ZK circuit
- **Atomicity**: Nullifier creation is atomic with your transaction
- **No deletion**: Nullifiers cannot be deleted once created

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `ProgramError::InvalidAccountData` | Invalid address tree | Verify tree pubkey matches `ADDRESS_TREE_V2` |
| `ErrorCode::AccountNotEnoughKeys` | Missing accounts in remaining_accounts | Include all system accounts and trees |
| Address already exists | Duplicate nullifier (double-spend attempt) | Expected behavior - transaction should fail |
| Proof verification failure | Invalid proof or public inputs | Check nullifiers match between proof and instruction |
