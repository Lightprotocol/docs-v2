---
title: Client Library
description: >-
  Overview to Rust and Typescript client guides. Guides include step-by-step
  implementation and full code examples.
icon: 'code'
---

<Steps>
<Step>
## Prerequisites

<Tabs>
<Tab title="Typescript">
The Typescript SDK consists of two packages:

1. [@lightprotocol/stateless.js](https://lightprotocol.github.io/light-protocol/stateless.js/index.html) is the core RPC client that provides the ZK Compression RPC interface to query and build transactions that create or interact with compressed accounts on Solana.
2. [@lightprotocol/compressed-token](https://lightprotocol.github.io/light-protocol/compressed-token/index.html) uses the stateless.js RPC interface to build transactions with compressed tokens.

<Note>
Use the [API documentation](https://lightprotocol.github.io/light-protocol/) to look up specific function signatures, parameters, and return types.
</Note>

### 1. Installation

<Tabs>
<Tab title="npm">

```bash
npm install --save \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="yarn">

```bash
yarn add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="pnpm">

```bash
pnpm add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>
</Tabs>

### 2. Create an RPC Connection

<Tip>
`Rpc` and `TestRpc` implement the same `CompressionApiInterface` for consistent usage across `TestRpc`, local test validator, and public Solana networks.
</Tip>

**Use `Rpc` for test-validator, devnet and mainnet**

* `Rpc` is a thin wrapper extending Solana's web3.js `Connection` class with compression-related endpoints.

<Tabs>
<Tab title="Mainnet">

Connect to Photon indexer to query compressed accounts and prover service to generate validity proofs.

```typescript
const rpc = createRpc('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```

</Tab>

<Tab title="Devnet">

Connect to Photon indexer to query compressed accounts and prover service to generate validity proofs.

```typescript
const rpc = createRpc('https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```
</Tab>

<Tab title="Localnet">

1. Install the CLI

```bash
npm install -g @lightprotocol/zk-compression-cli
```

2. Start a single-node Solana cluster, an RPC node, and a prover node at ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>

**For unit tests, use `TestRpc`.**
* Starts a mock RPC instance that parses events and builds Merkle trees on-demand without persisting state.

```typescript
const lightWasm: LightWasm = await WasmFactory.getInstance();
const testRpc = await TestRpc.create(lightWasm);
```

</Tab>

<Tab title="Rust">
The Rust packages separate client library, and program-side development:

1. [`light-client`](https://docs.rs/light-client): The RPC client that provides the ZK Compression RPC interface to query and build transactions for **compressed accounts and tokens** on Solana.
2. [`light-sdk`](https://docs.rs/light-sdk): Program-side abstractions (macros, wrappers, CPI interface) to create and interact with compressed accounts in Solana programs. Similar to Anchor's `Account` pattern.

**For devnet and mainnet, use `light-client`**

* Connects to Photon indexer to query compressed accounts and generate validity proofs.

```toml
[dependencies]
light-client = "0.16.0"
light-sdk = "0.16.0"
```

<Tabs>
<Tab title="Mainnet">

```rust
let config = LightClientConfig::new(
    "https://api.mainnet-beta.solana.com".to_string(),
    Some("https://mainnet.helius.xyz".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Devnet">

```rust
let config = LightClientConfig::devnet(
    Some("https://devnet.helius-rpc.com".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Localnet">

```rust
let config = LightClientConfig::local();

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

1. Install the CLI

```bash
npm install -g @lightprotocol/zk-compression-cli
```

2. Start a single-node Solana cluster, an RPC node, and a prover node at ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>

**For local testing, use [**`light-program-test`**](https://docs.rs/light-program-test).**

* Initializes a [LiteSVM](https://github.com/LiteSVM/LiteSVM) optimized for ZK Compression with auto-funded payer and TestIndexer. Requires Light CLI for program binaries.
* Use for unit and integration tests of your program or client code.

```toml
[dev-dependencies]
light-program-test = "0.16.0"
light-sdk = "0.16.0"
```

```bash
npm install -g @lightprotocol/zk-compression-cli
```

Run light test-validator once if programs are not found

```bash
light test-validator
```

```rust
let config = ProgramTestConfig::new_v2(
    true,
    Some(vec![("program_create", program_create::ID)])
);
let mut rpc = LightProgramTest::new(config).await.unwrap();
let payer = rpc.get_payer().insecure_clone();
```

<Tip>
`LightClient` and `LightProgramTest` implement the same [`Rpc`](https://docs.rs/light-client/latest/light_client/rpc/trait.Rpc.html) and [`Indexer`](https://docs.rs/light-client/latest/light_client/indexer/trait.Indexer.html) traits for consistent usage across `light-program-test`, local test validator, and public Solana networks.
</Tip>
</Tab>
</Tabs>
</Step>

<Step>
## Tree Configuration

Your client must fetch metadata of two Merkle trees:

* an address tree to derive and store the account address and
* a state tree to store the compressed account hash.

<Tip>
The protocol maintains Merkle trees. You don't need to initialize custom trees. Find the [addresses for Merkle trees here](https://www.zkcompression.com/resources/addresses-and-urls).
</Tip>

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="V1 Trees">

```typescript
const addressTree = getDefaultAddressTreeInfo();
const stateTreeInfos = await rpc.getStateTreeInfos();
const outputStateTree = selectStateTreeInfo(stateTreeInfos);
```

</Tab>

<Tab title="V2 Trees">

```typescript focus={1}
const addressTree = await rpc.getAddressTreeInfoV2();
const stateTreeInfos = await rpc.getStateTreeInfos();
const outputStateTree = selectStateTreeInfo(stateTreeInfos);
```

</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="V1 Trees">

```rust
let address_tree_info = rpc.get_address_tree_v1();
let output_state_tree_info = rpc.get_random_state_tree_info().unwrap();
```

</Tab>

<Tab title="V2 Trees">

```rust focus={1}
let address_tree_info = rpc.get_address_tree_v2();
let output_state_tree_info = rpc.get_random_state_tree_info().unwrap();
```

</Tab>
</Tabs>
</Tab>
</Tabs>

<Tip>
**V2 is on Devnet and reduces compute unit consumption by up to 70%**.
</Tip>

These methods return `TreeInfo` with the public key and other metadata of trees.

All instructions require the state tree `TreeInfo` to store or reference the compressed account hash.

<table>
  <thead>
    <tr>
      <th width="200">Instruction</th>
      <th width="150" className="text-center">Address Tree Required</th>
      <th width="130" className="text-center">State Tree Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit / Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Combined (Create + Update)</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
  </tbody>
</table>

**Use the address tree `TreeInfo`**, when you create a compressed account:
1. In **Step 3 to derive the address** for the compressed account.
2. In **Step 4 for `getValidityProofV0()`** to prove the address does not exist yet.

**Use the state tree `TreeInfo`**:
1. In **Step 4 for `getValidityProofV0()`** to prove the account hash exists in the state tree, if you update/close/reinit/burn a compressed account.
2. In **Step 5 to pack accounts** to optimize instruction data. This assigns indices to accounts instead of repeating full pubkeys in the instruction data.

<Accordion title="Expand to learn what TreeInfo contains">
* `tree`: Merkle tree account pubkey
* `queue`: Queue account pubkey of queue associated with a Merkle tree
  * Buffers updates of compressed accounts before they are added to the Merkle tree.
  * Clients and programs do not interact with the queue. The Light System Program inserts values into the queue.
* `treeType`: Automatically set based on which tree selection method you used.
* `cpiContext`: Optional CPI context account for batched operations across multiple programs (may be null, currently on devnet)
  * Allows a single zero-knowledge proof to verify compressed accounts from different programs in one instruction
  * Reduces instruction data size and compute unit costs when multiple programs interact with compressed accounts
* `nextTreeInfo`: Next tree to use when current tree reaches ~95% capacity (may be null).
  * The SDK automatically switches to next tree when present. Developers don't need to handle tree rollovers manually.
  * The protocol creates new trees, once existing trees fill up.
</Accordion>

<Tip>
For other instructions than create, **use the state tree of the existing compressed account**.
* **Best practice**: minimize the number of different trees per transaction to keep instruction data light.
* Account hashes can move to different state trees after each state transition.
* Since trees fill up over time, your programs must be able to handle accounts from different state trees within the same transaction.
</Tip>

</Step>

<Step>
## Address

You only need to derive an address when you create a compressed account.

<Tabs>
<Tab title="Create">
Derive a persistent address as a unique identifier for your compressed account, similar to [program-derived addresses (PDAs)](https://solana.com/docs/core/pda).

* Use the derivation method that matches your address tree type from the previous step (V1 or V2).
* Like PDAs, compressed account addresses don't belong to a private key; rather, they're derived from the program that owns them.
* The key difference to PDAs is that compressed accounts require an **address tree** parameter.

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="V1 Address Trees">

```typescript
const seed = deriveAddressSeed(
  [Buffer.from('my-seed')],
  programId
);
const address = deriveAddress(
  seed,
  addressTree.tree
);
```

**1. Derive the seed**:

* Seeds are predefined inputs, such as strings, numbers or other account addresses.
* Specify your `programId` to combine with your seeds

**2. Then, derive the address**:

* Pass the derived 32-byte `seed` from the first step
* Specify `addressTree.tree` pubkey
</Tab>

<Tab title="V2 Address Trees">

```typescript focus={1,5,8}
const seed = deriveAddressSeedV2(
  [Buffer.from('my-seed')]
);

const address = deriveAddressV2(
  seed,
  addressTree.tree,
  programId
);
```

**1. Derive the seed**

**2. Then, derive the address**:

* Pass the derived 32-byte `seed` from the first step.
* Specify `addressTree.tree` pubkey to ensure an address is unique to an address tree. Different trees produce different addresses from identical seeds.
* Specify your *`programId` in this step.*
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="V1 Address Trees">

```rust
use light_sdk::address::v1::derive_address;

let (address, _) = derive_address(
    &[b"my-seed"],
    &address_tree_info.tree,
    &program_id,
);
```

</Tab>

<Tab title="V2 Address Trees">

```rust focus={1}
use light_sdk::address::v2::derive_address;

let (address, _) = derive_address(
    &[b"my-seed"],
    &address_tree_info.tree,
    &program_id,
);
```

</Tab>
</Tabs>

**Pass these parameters**:

* `&[b"my-seed"]`: Predefined inputs, such as strings, numbers or other account addresses.
* `&address_tree_info.tree`: Specify the tree pubkey to ensure an address is unique to this address tree. Different trees produce different addresses from identical seeds.
* `&program_id`: Specify your program ID.
</Tab>
</Tabs>

<Tip>
**Use the same address** tree for all subsequent instructions **in client and program**.
</Tip>
</Tab>

<Tab title="Update, Close, Reinit, Burn">
Use the address from the existing compressed account. Fetch the account with the RPC methods to get its address.

<Tabs>
<Tab title="Typescript">

```typescript
const compressedAccount = await rpc.getCompressedAccount(address);
const accountAddress = compressedAccount.address;
```

</Tab>

<Tab title="Rust">

```rust
let compressed_account = rpc.get_compressed_account(address).await?;
let account_address = compressed_account.address;
```

</Tab>
</Tabs>

<Note>
Use the same address tree that was used during account creation. The address is stored in the compressed account data returned by the RPC methods.
</Note>
</Tab>
</Tabs>
</Step>

<Step>
## Validity Proof

Fetch a validity proof from your RPC provider that supports ZK Compression (Helius, Triton, ...). The proof type depends on the instruction:

* To **create** a compressed account, you prove the **address doesn't already exist** in the address tree.
* In **other instructions**, you **prove its account hash exists** in a state tree.
* You can **combine multiple addresses and hashes in one proof** to optimize compute cost and instruction data.

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = await rpc.getValidityProofV0(
  [],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* Leave the **hash array empty** (`[]`) since no compressed account exists yet to reference.
* Specify the **derived address** with `tree` and `queue` pubkeys from the address tree `TreeInfo`.

**2. The RPC returns**:

* `compressedProof` with the proof that the address does not exist in the address tree for your instruction data (Step 6)
* `rootIndices` array with root index from the validity proof for the address tree.
* Empty `leafIndices` array since you do not reference an existing account when you create a compressed account.
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  []
);
```
<Note>
These instructions prove that the account hash exists in the state tree. The difference is in your program's instruction handler.
</Note>

**1. Pass these parameters**:

* Specify the **account hash** with `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
* Leave the **address array empty** (`[]`) since the proof verifies the account hash exists in a state tree, not that the address doesn't exist in an address tree.

**2. The RPC returns**:

* `compressedProof` with the proof that the **account hash exists in the state tree** for your instruction data (Step 6)
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts (Step 5).
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```


**1. Pass these parameters**:

* Leave (`vec![]`) empty to create compressed accounts since no compressed account exists yet to reference.
* Specify the pubkeys of the new address and address tree from `TreeInfo`.

**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with the proof that the address does not exist in the address tree for your instruction data (Step 6)
* `addresses` with the public key and metadata of the address tree to pack accounts (Step 5).
* Empty `accounts` field since you do not reference an existing account when you create a compressed account.
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![],
        None,
    )
    .await?
    .value;
```
<Note>
These instructions prove that the account hash exists in the state tree. The difference is in your program's instruction handler.
</Note>

**1. Pass these parameters**:

* Specify the **compressed account hash in `vec![hash]`** to prove its existence in the state tree.
* Leave the **address vector empty**, since the proof verifies the account hash exists in a state tree, not that the address doesn't exist in an address tree.

**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with the proof that the **account hash exists in the state tree** for your instruction data (Step 6)
* `accounts` with the **public key and metadata of the state tree** to pack accounts (Step 5).
* **Empty `addresses` field** (only needed when creating an address).
</Tab>
</Tabs>
</Tab>
</Tabs>

### Optimize with Combined Proofs

<Tip>
**Advantages of combined proofs**:

* You only add one validity proof with 128 bytes in size instead of two to your instruction data.
* Reduction of compute unit consumption by at least 100k CU, since combined proofs are verified in a single CPI by the Light System Program.
</Tip>

The specific combinations and maximums to combine proofs depend on the circuit version (v1 or v2) and the proof type.

* Combine multiple hashes **or** multiple addresses in a single proof, or
* multiple hashes **and** addresses in a single combined proof.

<Tabs>
<Tab title="V1 Circuits">
V1 circuits can prove in a single proof

* 1, 2, 3, 4, or 8 hashes,
* 1, 2, 3, 4, or 8 addresses, or
* multiple hashes or addresses in any combination of the below.

| **Single Combined Proofs** | Any combination of |
| -------------------------- | :----------------: |
| Hashes                     |    1, 2, 3, 4, 8   |
| Addresses                  |     1, 2, 4, 8     |
</Tab>

<Tab title="V2 Circuits">
V2 circuits can prove in a single proof

* 1 to 20 hashes,
* 1 to 32 addresses, or
* multiple hashes or addresses in any combination of the below.

| **Single Combined Proofs** | Any combination of |
| -------------------------- | :----------------: |
| Hashes                     |       1 to 4       |
| Addresses                  |       1 to 4       |
</Tab>
</Tabs>

<Note>
The combinations and maximums are determined by the available circuit verifying keys. Different proof sizes require different circuits optimized for that specific combination. View the [source code here](https://github.com/Lightprotocol/light-protocol/tree/871215642b4b5b69d2bcd7eca22542346d0e2cfa/program-libs/verifier/src/verifying_keys).
</Note>

### Example Create Address & Update Account in one Proof

In this example, we generate one proof that proves that an account exists and that an address does not exist yet. 
This updates an account and create the address for a new account.

<Tabs>
<Tab title="Typescript">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* Specify one or more **account hashes** with `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
* Specify one or more **derived addresses** with `tree` and `queue` pubkeys from the address tree `TreeInfo`.

**2. The RPC returns**:

* `compressedProof` with a single combined proof that verifies both the **account hash exists in the state tree** and the **address does not exist in the address tree** for your instruction data (Step 6)
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts (Step 5).
</Tab>

<Tab title="Rust">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```


**1. Pass these parameters**:

* Specify one or more **account hashes** in `vec![hash]` from compressed accounts.
* Specify one or more **derived addresses** in `vec![AddressWithTree]` with `tree` pubkey from the address tree `TreeInfo`.

**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with a single combined proof that verifies both the **account hash exists in the state tree** and the **address does not exist in the address tree** for your instruction data (Step 6)
* `addresses` with the public key and metadata of the address tree to pack accounts (Step 5).
* `accounts` with the public key and metadata of the state tree to pack accounts (Step 5).
</Tab>
</Tabs>

<Note>
See the full [create-and-update program example with tests](https://github.com/Lightprotocol/program-examples/tree/main/create-and-update).
</Note>
</Step>

<Step>
## Accounts


### Overview

Transactions with compressed accounts reference three types of accounts:
1. **Your custom accounts**: Signers, fee payers, or program-specific accounts
2. **[Light System accounts](https://www.zkcompression.com/resources/addresses-and-urls#system-accounts)**: 8 required accounts for proof verification and CPI calls to update state and address trees.
3. **Merkle tree accounts**: State trees, address trees, and their associated queues to store compressed accounts and addresses.

<Accordion title="Light System Accounts Explained">

<table>
  <thead>
    <tr>
      <th width="20">#</th>
      <th width="200">Account</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Light System Program</td>
      <td>Verifies validity proofs, compressed account ownership checks, CPIs the account compression program to update tree accounts</td>
    </tr>
    <tr>
      <td>2</td>
      <td>CPI Signer</td>
      <td>PDA to sign CPI calls from your program to Light System Program. Verified by Light System Program during CPI. Derived from your program ID</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Registered Program PDA</td>
      <td>Access control to the Account Compression Program</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Noop Program</td>
      <td>Logs compressed account state to Solana ledger. Only used in v1. Indexers parse transaction logs to reconstruct compressed account state</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Account Compression Authority</td>
      <td>Signs CPI calls from Light System Program to Account Compression Program</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Account Compression Program</td>
      <td>Writes to state and address tree accounts. Client and the account compression program do not interact directly</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Invoking Program</td>
      <td>Your program's ID, used by Light System Program to derive the CPI Signer PDA, verify the CPI Signer matches your program ID, and set the owner of created compressed accounts</td>
    </tr>
    <tr>
      <td>8</td>
      <td>System Program</td>
      <td>Solana System Program to transfer lamports</td>
    </tr>
  </tbody>
</table>

</Accordion>

### PackedAccounts

To optimize instruction data, we reference these accounts with u8 indices instead of their 32-byte pubkeys.

The SDK provides the `PackedAccounts` helper:
* Each account is assigned a sequential u8 index (0, 1, 2...). 
* Duplicate pubkeys return the cached index automatically.
* All accounts are concatenated in a defined order to return the accounts array.

Programs use these indices to retrieve accounts from the instruction's accounts array.
* Anchor programs from `remainingAccounts`
* Native programs from the account info slice

```
                          PackedAccounts
               ┌-------------------------------┐
[pre_accounts] [system_accounts] [tree_accounts]
      ↑               ↑                ↑
   Signers,      Light System     state trees,
  fee payer       accounts       address trees,
                                   queues
```
<Tip>
In your instruction,
1. Put your program-specific accounts first
2. Append Packed accounts to end of the vector (recommended due to variable length)
</Tip>

<Tabs>
<Tab title="Typescript">

<Tabs>
<Tab title="Create">

```typescript
// 1. Initialize helper
const packedAccounts 
  = new PackedAccounts();

// 2. Add system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts
const addressMerkleTreePubkeyIndex 
  = packedAccounts.insertOrGet(addressTree);
const addressQueuePubkeyIndex 
  = packedAccounts.insertOrGet(addressQueue);

const packedAddressTreeInfo = {
  rootIndex: proofRpcResult.rootIndices[0],
  addressMerkleTreePubkeyIndex,
  addressQueuePubkeyIndex,
};

// 4. Get index for output state tree
const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 5. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>

<Tab title="Update, Close, Reinit Burn">
```typescript focus={10-21}
// 1. Initialize helper
const packedAccounts
  = new PackedAccounts();

// 2. Add system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts
const merkleTreePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.tree);
const queuePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.queue);

const packedInputAccounts = {
  merkleTreePubkeyIndex,
  queuePubkeyIndex,
  leafIndex: proofRpcResult.leafIndices[0],
  rootIndex: proofRpcResult.rootIndices[0],
};

// 4. Get index for output state tree
const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 5. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>
</Tabs>

</Tab>

<Tab title="Rust">

<Tabs>
<Tab title="Create">

```rust
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_accounts
  = rpc_result.pack_tree_infos(&mut remaining_accounts);

// 4. Get index for output state tree
let output_state_tree_index
  = output_state_tree_info.pack_output_tree_index(&mut remaining_accounts)?;

// 5. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust focus={3,8-14}
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_tree_accounts = rpc_result
    .pack_tree_infos(&mut remaining_accounts)
    .state_trees // includes output_state_tree_index
    .unwrap();

// 4. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```

</Tab>
</Tabs>

</Tab>
</Tabs>

### Tree Accounts

Depending on your instruction you must include indices for different tree and queue accounts. 
* For other instructions than create, **use the state tree of the existing compressed account** as output state tree.
* The pubkey is automatically deduplicated when you pack accounts.

<Warning>
When creating or updating multiple accounts in a single transaction, use one output state tree. 
</Warning>

<Tabs>
<Tab title="V1 Trees">

<table>
  <thead>
    <tr>
      <th width="150">Instruction</th>
      <th width="80" className="text-center">Address Tree</th>
      <th width="80" className="text-center">State Tree</th>
      <th width="100" className="text-center">Nullifier Queue</th>
      <th width="120" className="text-center">Output State Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
    </tr>
  </tbody>
</table>

</Tab>

<Tab title="V2 Trees">

<table>
  <thead>
    <tr>
      <th width="150">Instruction</th>
      <th width="80" className="text-center">Address Tree</th>
      <th width="200" className="text-center">State Tree (includes nullifier queue)</th>
      <th width="90" className="text-center">Output Queue</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
    </tr>
  </tbody>
</table>

</Tab>
</Tabs>

<Tip>
**V2 is on Devnet and reduces compute unit consumption by up to 70%**.
</Tip>

<Accordion title="Tree Accounts Explained">

* **Address tree**: only used to derive and store a new address.
* **State tree**: used to reference the existing compressed account hash. Therefore not used by create.
* **Nullifier queue**: used to nullify the existing compressed account hash to prevent double spending. Therefore not used by create.
  * V2 combines the state tree and nullifier queue into a single account.
* **Output State tree**: used to store the new or updated compressed account hash. Burn does not produce output state.
* **Output Queue**: used by V2 to store compressed account hashes. A forester node updates the Merkle tree asynchronously.

</Accordion>

</Step>

<Step>
## Instruction Data

Build your instruction data with the validity proof, tree account indices, and account data.

<Note>
Compressed account data must be passed in instruction data because only the Merkle root hash is stored on-chain. Regular accounts store full data on-chain for programs to read directly.

The program hashes this data, and the Light System Program verifies the hash against the root in a Merkle tree account.
</Note>

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  addressTreeInfo: packedAddressTreeInfo,
  outputStateTreeIndex: outputStateTreeIndex,
  message,
};
```

1. Include `compressedProof` from Step 4 to **prove the address does not exist** in the address tree
2. Specify **Merkle trees to store address and account hash** from Step 5
   * `packedAddressTreeInfo`: Index to the address tree account used to derive the address, from Step 5 Section 3
   * `outputStateTreeIndex`: Index to the state tree account that will store the compressed account hash, from Step 5 Section 4
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```typescript focus={7-13}
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
  newMessage,
};
```

1. Include `compressedProof` from **Step 4** to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from **Step 5**
   * `treeInfo`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `outputStateTreeIndex`: Index to the state tree that will store the updated account hash (Pack Accounts, Step 5 Section 3)
3. Pass **current account data** and **new data** 
</Tab>

<Tab title="Close">

```typescript focus={7-12}
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
};
```

1. Include `compressedProof` from **Step 4** to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from **Step 5**
   * `treeInfo`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `outputStateTreeIndex`: Index to the state tree that will store a **hash with zero values** (Pack Accounts, Step 5 Section 3)
3. Pass **current account data**
</Tab>

<Tab title="Reinit">

```typescript focus={7-11}
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
};
```

1. Include `compressedProof` from **Step 4** to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from **Step 5**
   * `treeInfo`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `outputStateTreeIndex`: Index to the state tree that will store the reinitialized account hash (Pack Accounts, Step 5 Section 3)
3. Reinitialize creates an account with **default-initialized values**
* These values are `Pubkey` as all zeros, numbers as `0`, strings as empty.
* To set custom values, update the account in the same or a separate transaction.
</Tab>

<Tab title="Burn">

```typescript focus={7-11}
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address
  },
  currentMessage: currentAccount.message,
};
```

1. Include `compressedProof` from **Step 4** to prove the **account hash exists** in the state tree
2. Specify **input hash** from **Step 5**
   * `treeInfo`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * No `outputStateTreeIndex` - Burn permanently removes the account with no output state
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let instruction_data = create::instruction::CreateAccount {
    proof: rpc_result.proof,
    address_tree_info: packed_accounts.address_trees[0],
    output_state_tree_index: output_state_tree_index,
    message,
}
.data();
```

1. Include `proof` from Step 4 to prove the **address does not exist** in the address tree
2. Specify **Merkle trees** to store **address and account hash** from Step 5
   * `address_tree_info`: Index to the address tree account used to derive the address (Pack Accounts, Step 5 Section 3)
   * `output_state_tree_index`: Index to the state tree that stores the compressed account hash (Pack Accounts, Step 5 Section 4)
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```rust focus={3-10}
let instruction_data = update::instruction::UpdateAccount {
    proof: rpc_result.proof,
    current_account,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    new_message,
}
.data();
```

1. Include `proof` from Step 4 to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from Step 5
   * `tree_info`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `output_state_tree_index`: Index to the state tree that stores the updated account hash (Pack Accounts, Step 5 Section 3)
3. Pass **current account data** and **new data**
</Tab>

<Tab title="Close">

```rust focus={3-9}
let instruction_data = close::instruction::CloseAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    current_message,
}
.data();
```

1. Include `proof` from Step 4 to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from Step 5
   * `tree_info`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `output_state_tree_index`: Index to the state tree that stores a **hash with zero values** (Pack Accounts, Step 5 Section 3)
3. Pass **current account data**
</Tab>

<Tab title="Reinit">

```rust focus={3-8}
let instruction_data = reinit::instruction::ReinitAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
}
.data();
```

1. Include `proof` from Step 4 to prove the **account hash exists** in the state tree
2. Specify **input hash** and **output state tree** from Step 5
   * `tree_info`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * `output_state_tree_index`: Index to the state tree that stores the reinitialized account hash (Pack Accounts, Step 5 Section 3)
3. Reinitialize creates an account with **default-initialized values** (`Pubkey` as all zeros, numbers as `0`, strings as empty). To set custom values, update the account in the same or a separate transaction.
</Tab>

<Tab title="Burn">

```rust focus={3-8}
let instruction_data = burn::instruction::BurnAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMetaBurn {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
    },
    current_message,
}
.data();
```

1. Include `proof` from Step 4 to prove the **account hash exists** in the state tree
2. Specify **input hash** from Step 5
   * `tree_info`: Packed indices to the state tree and nullifier queue accounts (Pack Accounts, Step 5 Section 3)
   * `address`: Account's derived address from Step 3
   * No `output_state_tree_index` - Burn permanently removes the account with no output state
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>
</Tabs>

<Tip>
For other instructions than create, **use the state tree of the existing compressed account** as output state tree.
* **Best practice**: minimize the number of different trees per transaction to keep instruction data light.
* Still, account hashes can move to different state trees after each state transition.
* Since trees fill up over time, your programs must be able to handle accounts from different state trees within the same transaction.
</Tip>

<Warning>
When creating or updating multiple accounts in a single transaction, use one output state tree. 
</Warning>

</Step>

<Step>
## Instruction

Build the instruction with your `program_id`, `accounts`, and `data` from Step 6.

<Tip>
In `accounts`,
1. Put your program-specific accounts first
2. Append Packed accounts to end of the vector (recommended due to variable length)
</Tip>

```rust
let instruction = Instruction {
    program_id: program_id,
    accounts: [
        vec![AccountMeta::new(payer.pubkey(), true)],
        remaining_accounts,
    ]
    .concat(),
    data: instruction_data,
};
```

</Step>

<Step>
## Send Transaction

</Step>
</Steps>

# Full Code Examples

<Tabs>
<Tab title="Typescript">
```typescript expandable wrap
// create.ts
import * as anchor from "@coral-xyz/anchor";
import { Program, web3 } from "@coral-xyz/anchor";
import { Create } from "../target/types/create";
import idl from "../target/idl/create.json";
import {
  bn,
  CompressedAccountWithMerkleContext,
  confirmTx,
  createRpc,
  defaultStaticAccountsStruct,
  defaultTestStateTreeAccounts,
  deriveAddress,
  deriveAddressSeed,
  LightSystemProgram,
  PackedAccounts,
  Rpc,
  sleep,
  SystemAccountMetaConfig,
} from "@lightprotocol/stateless.js";
import * as assert from "assert";

const path = require("path");
const os = require("os");
require("dotenv").config();

const anchorWalletPath = path.join(os.homedir(), ".config/solana/id.json");
process.env.ANCHOR_WALLET = anchorWalletPath;

describe("test-anchor", () => {
  const program = anchor.workspace.Create as Program<Create>;
  const coder = new anchor.BorshCoder(idl as anchor.Idl);

  it("create compressed account", async () => {
    let signer = new web3.Keypair();
    let rpc = createRpc(
      "http://127.0.0.1:8899",
      "http://127.0.0.1:8784",
      "http://127.0.0.1:3001",
      {
        commitment: "confirmed",
      },
    );
    let lamports = web3.LAMPORTS_PER_SOL;
    await rpc.requestAirdrop(signer.publicKey, lamports);
    await sleep(2000);

    const outputStateTree = defaultTestStateTreeAccounts().merkleTree;
    const addressTree = defaultTestStateTreeAccounts().addressTree;
    const addressQueue = defaultTestStateTreeAccounts().addressQueue;

    const messageSeed = new TextEncoder().encode("message");
    const seed = deriveAddressSeed(
      [messageSeed, signer.publicKey.toBytes()],
      new web3.PublicKey(program.idl.address),
    );
    const address = deriveAddress(seed, addressTree);

    // Create compressed account with message
    const txId = await createCompressedAccount(
      rpc,
      addressTree,
      addressQueue,
      address,
      program,
      outputStateTree,
      signer,
      "Hello, compressed world!",
    );
    console.log("Transaction ID:", txId);

    // Wait for indexer to process the transaction
    const slot = await rpc.getSlot();
    await rpc.confirmTransactionIndexed(slot);

    let compressedAccount = await rpc.getCompressedAccount(bn(address.toBytes()));
    let myAccount = coder.types.decode(
      "MyCompressedAccount",
      compressedAccount.data.data,
    );

    console.log("Decoded data owner:", myAccount.owner.toBase58());
    console.log("Decoded data message:", myAccount.message);

    // Verify account data
    assert.ok(
      myAccount.owner.equals(signer.publicKey),
      "Owner should match signer public key"
    );
    assert.strictEqual(
      myAccount.message,
      "Hello, compressed world!",
      "Message should match the created message"
    );
  });
});

async function createCompressedAccount(
  rpc: Rpc,
  addressTree: anchor.web3.PublicKey,
  addressQueue: anchor.web3.PublicKey,
  address: anchor.web3.PublicKey,
  program: anchor.Program<Create>,
  outputStateTree: anchor.web3.PublicKey,
  signer: anchor.web3.Keypair,
  message: string,
) {
  const proofRpcResult = await rpc.getValidityProofV0(
    [],
    [
      {
        tree: addressTree,
        queue: addressQueue,
        address: bn(address.toBytes()),
      },
    ],
  );
  const systemAccountConfig = new SystemAccountMetaConfig(program.programId);
  let remainingAccounts = new PackedAccounts();
  remainingAccounts.addSystemAccounts(systemAccountConfig);

  const addressMerkleTreePubkeyIndex =
    remainingAccounts.insertOrGet(addressTree);
  const addressQueuePubkeyIndex = remainingAccounts.insertOrGet(addressQueue);
  const packedAddressTreeInfo = {
    rootIndex: proofRpcResult.rootIndices[0],
    addressMerkleTreePubkeyIndex,
    addressQueuePubkeyIndex,
  };
  const outputStateTreeIndex =
    remainingAccounts.insertOrGet(outputStateTree);
  let proof = {
    0: proofRpcResult.compressedProof,
  };
  const computeBudgetIx = web3.ComputeBudgetProgram.setComputeUnitLimit({
    units: 1000000,
  });
  let tx = await program.methods
    .createAccount(proof, packedAddressTreeInfo, outputStateTreeIndex, message)
    .accounts({
      signer: signer.publicKey,
    })
    .preInstructions([computeBudgetIx])
    .remainingAccounts(remainingAccounts.toAccountMetas().remainingAccounts)
    .signers([signer])
    .transaction();
  tx.recentBlockhash = (await rpc.getRecentBlockhash()).blockhash;
  tx.sign(signer);

  const sig = await rpc.sendTransaction(tx, [signer]);
  await confirmTx(rpc, sig);
  return sig;
}
```
</Tab>

<Tab title="Rust">
```rust expandable wrap
// test.rs
#![cfg(feature = "test-sbf")]

use anchor_lang::AnchorDeserialize;
use light_program_test::{
    program_test::LightProgramTest, AddressWithTree, Indexer, ProgramTestConfig, Rpc, RpcError,
};
use light_sdk::{
    address::v1::derive_address,
    instruction::{PackedAccounts, SystemAccountMetaConfig},
};
use create::MyCompressedAccount;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signature, Signer},
};

#[tokio::test]
async fn test_create() {
    let config = ProgramTestConfig::new(true, Some(vec![("create", create::ID)]));
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let address_tree_info = rpc.get_address_tree_v1();

    let (address, _) = derive_address(
        &[b"message", payer.pubkey().as_ref()],
        &address_tree_info.tree,
        &create::ID,
    );

    create_compressed_account(&mut rpc, &payer, &address, "Hello, compressed world!".to_string())
        .await
        .unwrap();

    let compressed_account = rpc
        .get_compressed_account(address, None)
        .await
        .unwrap()
        .value
        .unwrap();
    let data = &compressed_account.data.as_ref().unwrap().data;
    let account = MyCompressedAccount::deserialize(&mut &data[..]).unwrap();
    assert_eq!(account.owner, payer.pubkey());
    assert_eq!(account.message, "Hello, compressed world!");
}

async fn create_compressed_account(
    rpc: &mut LightProgramTest,
    payer: &Keypair,
    address: &[u8; 32],
    message: String,
) -> Result<Signature, RpcError> {
    let config = SystemAccountMetaConfig::new(create::ID);
    let mut remaining_accounts = PackedAccounts::default();
    remaining_accounts.add_system_accounts(config)?;

    let address_tree_info = rpc.get_address_tree_v1();

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: *address,
                tree: address_tree_info.tree,
            }],
            None,
        )
        .await?
        .value;
    let packed_accounts = rpc_result.pack_tree_infos(&mut remaining_accounts);

    let output_state_tree_index = rpc
        .get_random_state_tree_info()?
        .pack_output_tree_index(&mut remaining_accounts)?;

    let (remaining_accounts, _, _) = remaining_accounts.to_account_metas();

    let instruction = Instruction {
        program_id: create::ID,
        accounts: [
            vec![AccountMeta::new(payer.pubkey(), true)],
            remaining_accounts,
        ]
        .concat(),
        data: {
            use anchor_lang::InstructionData;
            create::instruction::CreateAccount {
                proof: rpc_result.proof,
                address_tree_info: packed_accounts.address_trees[0],
                output_state_tree_index: output_state_tree_index,
                message,
            }
            .data()
        },
    };

    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[payer])
        .await
}
```
</Tab>
</Tabs>

Find all [full code examples with Rust and Typescript tests here](https://github.com/Lightprotocol/program-examples/tree/add-basic-operations-examples/basic-operations/anchor) for the following instructions:
- **create** - Initialize a new compressed account
- **update** - Modify data in an existing compressed account
- **close** - Clear account data while preserving address
- **reinit** - Reinitialize a closed account
- **burn** - Permanently delete a compressed account

<Warning>
For help with debugging, see the [Error Cheatsheet](https://www.zkcompression.com/resources/error-cheatsheet) and [AskDevin](https://deepwiki.com/Lightprotocol/light-protocol/3.1-javascripttypescript-sdks).
</Warning>

# Next Steps

<Card
  title=" Learn how to Create Compressed Accounts"
  icon="chevron-right"
  color="#0066ff"
  href="/c-token/ctoken-overview"
  horizontal
>
</Card>
