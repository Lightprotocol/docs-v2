---
title: Client Guide
description: >-
  Rust and Typescript client guides with step-by-step implementation and full
  code examples.
keywords: ["compressed pda client", "light protocol sdk"]
---

import SystemAccountsList from '/snippets/accounts-list/compressed-pdas-system-accounts-list.mdx';
import TypescriptClient from '/snippets/code-snippets/create/typescript-client.mdx';
import RustClient from '/snippets/code-snippets/create/rust-client.mdx';

ZK Compression provides Rust and Typescript clients to interact with compressed accounts and tokens on Solana.

<table>
  <thead>
    <tr>
      <th width="120"></th>
      <th width="250" className="text-left"></th>
      <th width="280" className="text-left"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**TypeScript**</td>
      <td>[@lightprotocol/stateless.js](https://lightprotocol.github.io/light-protocol/stateless.js/index.html)</td>
      <td>Client SDK for Compressed Accounts</td>
    </tr>
    <tr>
      <td>**TypeScript**</td>
      <td>[@lightprotocol/compressed-token](https://lightprotocol.github.io/light-protocol/compressed-token/index.html)</td>
      <td>Client SDK for Compressed Tokens</td>
    </tr>
    <tr>
      <td>**Rust**</td>
      <td>[light-client](https://docs.rs/light-client)</td>
      <td>Client SDK for Compressed Accounts and Tokens</td>
    </tr>
  </tbody>
</table>

# Key Points

1. **Derive a new address** or **fetch compressed account** for on-chain verification.
2. **Fetch validity proof** from the RPC that verifies a new address does not exist (create) and/or the account hash exists in the state tree (update, close, etc.).
3. **Pack accounts** with the SDKs helper. Instructions require <Tooltip tip="The system program enforces the compressed account layout with ownership and sum checks and verifies the validity of your input state. It is also invoked to create/write to compressed accounts and PDAs.">Light System Program</Tooltip> and <Tooltip tip="Merkle tree accounts are the accounts of state tree and address trees that store compressed account hashes and addresses.">Merkle tree accounts</Tooltip>. `PackedAccounts` converts their pubkeys to `u8` indices pointing to accounts in the instruction.
4. **Build the instruction** with the current account data, new data, packed accounts and validity proof.
<Tabs>
  <Tab title="Create">
    <div className="hidden dark:block">
    <Frame>
      ![](/images/client-create-dark.png)
    </Frame>
    </div>
    <div className="block dark:hidden">
      <Frame>
        ![](/images/client-create.png)
      </Frame>
    </div>
  </Tab>
  <Tab title="Update">
    <div className="hidden dark:block">
    <Frame>
      ![](/images/client-update-dark.png)
    </Frame>
    </div>
    <div className="block dark:hidden">
      <Frame>
      ![](/images/client-update.png)
    </Frame>
      </div>
  </Tab>
  <Tab title="Close">
    <div className="hidden dark:block">
    <Frame>
      ![](/images/client-close-dark.png)
    </Frame>
    </div>
    <div className="block dark:hidden">
      <Frame>
      ![](/images/client-close.png)
    </Frame>
    </div>
  </Tab>
  <Tab title="Reinitialize">
    <div className="hidden dark:block">
    <Frame>
      ![](/images/client-reinit-dark.png)
    </Frame>
    </div>
    <div className="block dark:hidden">
      <Frame>
      ![](/images/client-reinit.png)
    </Frame>
    </div>
  </Tab>
  <Tab title="Burn">
    <div className="hidden dark:block">
    <Frame>
      ![](/images/client-burn-dark.png)
    </Frame>
    </div>
    <div className="block dark:hidden">
      <Frame>
      ![](/images/client-burn.png)
    </Frame>
    </div>
  </Tab>
</Tabs>

# Get Started
<Steps>
<Step>
## Setup

<Tabs>
<Tab title="Typescript">

<Note>
Use the [API documentation](https://lightprotocol.github.io/light-protocol/) to look up specific function signatures, parameters, and return types.
</Note>

### 1. Installation

<Tabs>
<Tab title="npm">

```bash
npm install --save \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="yarn">

```bash
yarn add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="pnpm">

```bash
pnpm add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>
</Tabs>

### 2. RPC Connection

`Rpc` is a thin wrapper extending Solana's web3.js `Connection` class with compression-related endpoints.

<Tabs>
<Tab title="Mainnet">

```typescript
const rpc = createRpc('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```

</Tab>

<Tab title="Devnet">

```typescript
const rpc = createRpc('https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```
</Tab>

<Tab title="Localnet">

1. Install the CLI

```bash
npm i -g @lightprotocol/zk-compression-cli@alpha
```

2. Start a local Solana test validator, photon indexer, and prover server on default ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">

### 1. Dependencies

```toml
[dependencies]
light-client = "0.16.0"
light-sdk = "0.16.0"
```

### 2. RPC Connection

Connect to an RPC provider that supports ZK Compression, such as Helius and Triton.

<Tabs>
<Tab title="Mainnet">

```rust
let config = LightClientConfig::new(
    "https://api.mainnet-beta.solana.com".to_string(),
    Some("https://mainnet.helius.xyz".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Devnet">

```rust
let config = LightClientConfig::devnet(
    Some("https://devnet.helius-rpc.com".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Localnet">

```rust
let config = LightClientConfig::local();

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

1. Install the CLI

```bash
npm i -g @lightprotocol/zk-compression-cli@alpha
```

2. Start a single-node Solana cluster, an RPC node, and a prover node at ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>

</Tab>
</Tabs>
</Step>

<Step>
## Address

Derive a persistent address as a unique identifier for your compressed account, similar to [program-derived addresses (PDAs)](https://solana.com/docs/core/pda).

You derive addresses in two scenarios:
* **At account creation** - derive the address to create the account's persistent identifier, then pass it to `getValidityProofV0()` in the address array
* **Before building instructions** - derive the address to fetch existing accounts using `rpc.getCompressedAccount()`

<Tabs>
<Tab title="Typescript">

```typescript
const addressTree = await rpc.getAddressTreeInfoV2();
const seed = deriveAddressSeedV2(
  [Buffer.from('my-seed')]
);

const address = deriveAddressV2(
  seed,
  addressTree.tree,
  programId
);
```

</Tab>

<Tab title="Rust">

```rust
use light_sdk::address::v2::derive_address;

let address_tree_info = rpc.get_address_tree_v2();
let (address, _) = derive_address(
    &[b"my-seed"],
    &address_tree_info.tree,
    &program_id,
);
```

</Tab>
</Tabs>

Like PDAs, compressed account addresses don't have a private key; rather, they're derived from the program that owns them.
* The key difference to PDAs is compressed addresses are stored in an address tree and include this tree in the address derivation.
* Different trees produce different addresses from identical seeds. You should check the address tree in your program.

<Tip>
The protocol maintains Merkle trees. You don't need to initialize custom trees. Find the [pubkeys for Merkle trees here](https://www.zkcompression.com/resources/addresses-and-urls).
</Tip>
</Step>

<Step>
## Validity Proof

Transactions with compressed accounts must include a validity proof:
* To **create** a compressed account, you prove the **new address doesn't already exist** in the address tree.
* In **other instructions**, you **prove  the compressed account hash exists** in a state tree.
* You can **combine multiple addresses and hashes in one proof** to optimize compute cost and instruction data.

<Info>
You fetch a validity proof from your RPC provider that supports ZK Compression, such as Helius or Triton.
</Info>

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = await rpc.getValidityProofV0(
  [],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* **Specify the new address**, `tree` and `queue` pubkeys from the address tree `TreeInfo`.
* When you create an account you don't reference a compressed account hash in the hash array (`[]`). The account doesn't exist in a state Merkle tree yet.
<Note>
For account creation, you prove the address does not exist yet in the address tree.
</Note>
**2. The RPC returns**:

* The proof that the new address does not exist in the address tree. It is used in the instruction data.
* `rootIndices` array with root index. 
  * The root index points to the root in the address tree accounts root history array. 
  * This root is used by the `LightSystemProgram` to verify the validity proof.
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  []
);
```

**1. Pass these parameters**:

Specify the **account hash**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.

<Note>
* You don't specify the address for update, close, reinitialize, and burn instructions. 
* The proof **verifies the account hash exists in the state tree** for these instructions. 
* The validity proof structure is identical. The difference is in your program's instruction handler.
</Note>

**2. The RPC returns**:

* The proof that the account hash exists in the state tree for your instruction data.
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts.
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```


**1. Pass these parameters**:
* **Specify the new address** and `tree` pubkey from the address tree `TreeInfo`. The `queue` pubkey is only required in TypeScript.
* When you create an account you don't reference a compressed account hash in the hash array (`vec![]`).
<Note>
For account creation, you prove the address does not exist yet in the address tree.
</Note>

**2. The RPC returns `ValidityProofWithContext`**:

* The proof that the new address does not exist in the address tree for your instruction data.
* `addresses` with the public key and metadata of the address tree to pack accounts.
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![],
        None,
    )
    .await?
    .value;
```

**1. Pass these parameters**:

Specify the **account hash**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
<Note>
* You don't specify the address for update, close, reinitialize, and burn instructions. 
* The proof **verifies the account hash exists in the state tree** for these instructions. 
* The validity proof structure is identical. The difference is in your program's instruction handler.
</Note>
**2. The RPC returns `ValidityProofWithContext`**:

* The proof that the **account hash exists in the state tree** for your instruction data
* `accounts` with the **public key and metadata of the state tree** to pack accounts.
</Tab>
</Tabs>
</Tab>
</Tabs>

### Optimize with Combined Proofs

You can prove **in a single proof**:
* multiple addresses,
* multiple account hashes, or
* a combination of addresses and account hashes.

|              |                   |
| ----------------------- | --------------------------------------------------- |
| Account Hash-only        | 1 to 8 hashes                                     |
| Address-only      | 1 to 8 addresses                                  |
| Mixed (hash + address)  | Any combination of <br/>**1 to 4** account hashes **and** <br/>**1 or 4** new addresses |

<Tip>
**Advantages of combined proofs**:
* You only add **one 128 byte validity proof** to your instruction data.
* This can **optimize** your **transaction's size** to stay inside the 1232 byte instruction data limit.
* **Compute unit consumption is 100k CU** per `ValidityProof` verification by the Light System Program.
</Tip>

### Example Create Address & Update Account in one Proof

In this example, we generate one proof that proves that an account exists and that a new address does not exist yet. 

<Tabs>
<Tab title="Typescript">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* Specify one or more **account hashes**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
* Specify one or more **new addresses** with their `tree` and `queue` pubkeys from the address tree `TreeInfo`.

**2. The RPC returns**:

* A single combined proof that proves both the **account hash exists in the state tree** and the **new address does not exist in the address tree** for your instruction data
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts.
</Tab>

<Tab title="Rust">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```

**1. Pass these parameters**:

* Specify one or more **compressed account hashes**.
* Specify one or more **derived addresses** with their `tree` pubkeys from the address tree `TreeInfo`. The `queue` pubkey is only required in TypeScript.

**2. The RPC returns `ValidityProofWithContext`**:

* A single combined proof that verifies both the **account hash exists in the state tree** and the **new address does not exist in the address tree** for your instruction data
* New `addresses` with the public key and metadata of the address tree to pack accounts.
* `accounts` with the public key and metadata of the state tree to pack accounts.
</Tab>
</Tabs>

<Note>
See the full [create-and-update program example for this proof combination with tests](https://github.com/Lightprotocol/program-examples/tree/main/create-and-update).
</Note>
</Step>

<Step>
## Accounts

To interact with a compressed account you need System accounts such as the <Tooltip tip="The system program enforces the compressed account layout with ownership and sum checks and verifies the validity of your input state. It is also invoked to create/write to compressed accounts and PDAs.">Light System Program</Tooltip>,
and <Tooltip tip="Merkle tree accounts are the accounts of state tree and address trees that store compressed account hashes and addresses.">Merkle tree accounts</Tooltip>.

Compressed account metadata (`TreeInfo`) includes Merkle tree pubkeys.
To optimize instruction data we pack the `pubkeys` of `TreeInfo` into the `u8` indices of `PackedTreeInfo`.

The `u8` indices point to the Merkle tree account in the instructions accounts.
You can create the instructions accounts and indices with `PackedAccounts`.

We recommend to append `PackedAccounts` after your program specific accounts and in anchor in `remaining_accounts`.


```
                                  PackedAccounts
                  ┌--------------------------------------------┐
[custom accounts] [pre accounts][system accounts][tree accounts]
                        ↑              ↑               ↑
                     Signers,      Light System    State trees,
                    fee payer        accounts     address trees,
```
<Accordion title="Custom Accounts">
Custom accounts are program-specific accounts you pass manually in your instruction, typically through Anchor's account struct.

</Accordion>

<Accordion title="Pre Accounts">
Optional, custom accounts (signers, PDAs for CPIs) and other accounts can be added to pre accounts.
Pre accounts can simplify building the accounts for pinocchio and native programs.

</Accordion>

<Accordion title="Light System Accounts">

**Light System accounts** are 6 required accounts for proof verification and CPI calls to update state and address trees.

<SystemAccountsList />
</Accordion>

<Accordion title="Merkle Tree Accounts">

**Merkle tree accounts** are the accounts of state tree and address trees that store compressed account hashes and addresses.


</Accordion>

<Tabs>
<Tab title="Typescript">

<Tabs>
<Tab title="Create">

```typescript
// 1. Initialize helper
const packedAccounts 
  = new PackedAccounts();

// 2. Add light system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts
const addressMerkleTreePubkeyIndex 
  = packedAccounts.insertOrGet(addressTree);
const addressQueuePubkeyIndex 
  = packedAccounts.insertOrGet(addressQueue);

const packedAddressTreeInfo = {
  rootIndex: proofRpcResult.rootIndices[0],
  addressMerkleTreePubkeyIndex,
  addressQueuePubkeyIndex,
};

// 4. Get index for output state tree
const stateTreeInfos = await rpc.getStateTreeInfos();
const outputStateTree = selectStateTreeInfo(stateTreeInfos).tree;
const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 5. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>

<Tab title="Update, Close, Reinit Burn">
```typescript
// 1. Initialize helper
const packedAccounts
  = new PackedAccounts();

// 2. Add system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts 
const merkleTreePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.tree);
const queuePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.queue);

const packedInputAccounts = {
  merkleTreePubkeyIndex,
  queuePubkeyIndex,
  leafIndex: proofRpcResult.leafIndices[0],
  rootIndex: proofRpcResult.rootIndices[0],
};

const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 4. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">

<Tabs>
<Tab title="Create">

```rust
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_accounts
  = rpc_result.pack_tree_infos(&mut remaining_accounts);

// 4. Get index for output state tree
let output_state_tree_info = rpc.get_random_state_tree_info()?;
let output_state_tree_index
  = output_state_tree_info.pack_output_tree_index(&mut remaining_accounts)?;

// 5. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_tree_accounts = rpc_result
    .pack_tree_infos(&mut remaining_accounts)
    .state_trees // includes output_state_tree_index
    .unwrap();

// 4. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```

</Tab>
</Tabs>
</Tab>

</Tabs>

Depending on your instruction you must include different tree and queue accounts.

<table>
  <thead>
    <tr>
      <th width="150">Instruction</th>
      <th width="80" className="text-center">Address Tree</th>
      <th width="200" className="text-center">State Tree (includes nullifier queue)</th>
      <th width="90" className="text-center">Output Queue</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
    </tr>
  </tbody>
</table>

* **Address tree**: only used to derive and store a new address.
* **State tree**: used to reference the existing compressed account hash. Therefore not used by create. The state tree and nullifier queue are combined into a single account.
* **Output Queue**: used to store compressed account hashes. A forester node updates the state tree asynchronously.
  * **Create only** - Choose any available queue, or use a pre-selected queue to store the new compressed account.
  * **Update/Close/Reinit** - Use the queue of the existing compressed account as output queue.
  * **Mixed instructions (create + update in same tx)** - Use the queue from the existing account as output queue.
  * **Burn** - Do not include an output queue.

</Step>

<Step>
## Instruction Data

Build your instruction data with the validity proof, tree account indices, and account data.

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  addressTreeInfo: packedAddressTreeInfo,
  outputStateTreeIndex: outputStateTreeIndex,
  message,
};
```

1. Include `proof` to **prove the address does not exist** in the address tree
2. Specify **Merkle trees to store address and account hash** to where you packed accounts.
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
  newMessage,
};
```

1. Include `proof` to to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree to store the updated compressed account hash.
3. Pass **current account data** and **new data**
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Close">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
};
```

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree to store the **hash with zero values** for the closed account.
3. Pass **current account data**
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Reinit">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
};
```

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree that will store the reinitialized account hash
3. Reinitialize creates an account with **default-initialized values**
* These values are `Pubkey` as all zeros, numbers as `0`, strings as empty.
* To set custom values, update the account in the same or a separate transaction.
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Burn">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address
  },
  currentMessage: currentAccount.message,
};
```

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address and its `packedStateTreeInfo`. You don't need to specify the output state tree, since burn permanently removes the account.
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let instruction_data = create::instruction::CreateAccount {
    proof: rpc_result.proof,
    address_tree_info: packed_accounts.address_trees[0],
    output_state_tree_index: output_state_tree_index,
    message,
}
.data();
```

1. Include `proof` to prove the **address does not exist** in the address tree
2. Specify **address tree and output state tree** to where you packed accounts
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```rust
let instruction_data = update::instruction::UpdateAccount {
    proof: rpc_result.proof,
    current_account,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    new_message,
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree to store the updated compressed account hash
3. Pass **current account data** and **new data**

</Tab>

<Tab title="Close">

```rust
let instruction_data = close::instruction::CloseAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    current_message,
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree to store the **hash with zero values** for the closed account
3. Pass **current account data**

</Tab>

<Tab title="Reinit">

```rust
let instruction_data = reinit::instruction::ReinitAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree that will store the reinitialized account hash
3. Reinitialize creates an account with **default-initialized values**
* These values are `Pubkey` as all zeros, numbers as `0`, strings as empty.
* To set custom values, update the account in the same or a separate transaction.
</Tab>

<Tab title="Burn">

```rust
let instruction_data = burn::instruction::BurnAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMetaBurn {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
    },
    current_message,
}
.data();
```

1. Include `proof` to prove the **account hash exists** in the state tree
2. Specify the existing accounts address and its `packed_tree_infos`. You don't need to specify the output state tree, since burn permanently removes the account
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>
</Tabs>

<Warning>
* When creating or updating multiple accounts in a single transaction, use one output state tree. 
* Minimize the number of different trees per transaction to keep instruction data light.
</Warning>

</Step>

<Step>
## Instruction

Build the instruction with your `program_id`, `accounts`, and `data`.
* Accounts combine your program-specific accounts and `PackedAccounts`.
* Data includes your compressed accounts, validity proof and other instruction data.

<Tabs>
<Tab title="Typescript">

```typescript
//             Accounts
// ┌-------------------------------┐
// .accounts()    .remainingAccounts()
// [custom]         [PackedAccounts]

const instruction = await program.methods
  .yourInstruction(instructionData)
  .accounts({
    signer: signer.publicKey,
  })
  .remainingAccounts(remainingAccounts)
  .instruction();
```

</Tab>

<Tab title="Rust">

```rust
//          Accounts
// ┌---------------------------------┐
// [custom accounts]  [PackedAccounts]
let accounts = [vec![AccountMeta::new(payer.pubkey(), true)], remaining_accounts].concat();

let instruction = Instruction {
    program_id: program_id,
    accounts,
    data: instruction_data,
};
```

</Tab>
</Tabs>

</Step>

<Step>
## Send Transaction

</Step>
</Steps>

# Full Code Examples

<Tabs>
<Tab title="TypeScript">
<Info>
Find the source code [here](https://github.com/Lightprotocol/program-examples/tree/main/basic-operations/anchor/create/tests).
</Info>

<TypescriptClient />
</Tab>

<Tab title="Rust">
<Info>
Find the source code [here](https://github.com/Lightprotocol/program-examples/tree/main/basic-operations/anchor/create/programs/create/tests).
</Info>

<RustClient />
</Tab>
</Tabs>

Find all [full code examples with Rust and TypeScript tests here](https://github.com/Lightprotocol/program-examples/tree/main/basic-operations/anchor) for the following instructions:
- **create** - Initialize a new compressed account
- **update** - Modify data of an existing compressed account
- **close** - Close a compressed account (it can be initialized again).
- **reinit** - Reinitialize a closed account
- **burn** - Permanently delete a compressed account (it cannot be initialized again).

<Warning>
For help with debugging, see the [Error Cheatsheet](../resources/error-cheatsheet/) and [AskDevin](https://deepwiki.com/Lightprotocol/light-protocol/3.1-javascripttypescript-sdks).
</Warning>

# Next Steps

<Card
  title="Get an overview to Compressed PDA guides and build a program."
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-pdas/guides"
  horizontal
>
</Card>
