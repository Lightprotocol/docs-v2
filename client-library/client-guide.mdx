---
title: Client Guide
description: >-
  Overview to Rust and Typescript client guides. Guides include step-by-step
  implementation and full code examples.
---

ZK Compression provides Rust and Typescript clients to interact with compressed accounts and tokens on Solana.

<table>
  <thead>
    <tr>
      <th width="120"></th>
      <th width="250" className="text-left"></th>
      <th width="280" className="text-left"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**TypeScript**</td>
      <td>[@lightprotocol/stateless.js](https://lightprotocol.github.io/light-protocol/stateless.js/index.html)</td>
      <td>Client SDK for Compressed Accounts</td>
    </tr>
    <tr>
      <td>**TypeScript**</td>
      <td>[@lightprotocol/compressed-token](https://lightprotocol.github.io/light-protocol/compressed-token/index.html)</td>
      <td>Client SDK for Compressed Tokens</td>
    </tr>
    <tr>
      <td>**Rust**</td>
      <td>[light-client](https://docs.rs/light-client)</td>
      <td>Client SDK for Compressed Accounts and Tokens</td>
    </tr>
  </tbody>
</table>

<Steps>
<Step>
## Setup

<Tabs>
<Tab title="Typescript">

<Note>
Use the [API documentation](https://lightprotocol.github.io/light-protocol/) to look up specific function signatures, parameters, and return types.
</Note>

### 1. Installation

<Tabs>
<Tab title="npm">

```bash
npm install --save \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="yarn">

```bash
yarn add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>

<Tab title="pnpm">

```bash
pnpm add \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @lightprotocol/compressed-token@0.22.1-alpha.1 \
    @solana/web3.js
```

</Tab>
</Tabs>

### 2. RPC Connection

`Rpc` is a thin wrapper extending Solana's web3.js `Connection` class with compression-related endpoints.

<Tabs>
<Tab title="Mainnet">

```typescript
const rpc = createRpc('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```

</Tab>

<Tab title="Devnet">

```typescript
const rpc = createRpc('https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY');
```
</Tab>

<Tab title="Localnet">

1. Install the CLI

```bash
npm install -g @lightprotocol/zk-compression-cli
```

2. Start a local Solana test validator, photon indexer, and prover server on default ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">

### 1. Dependencies

```toml
[dependencies]
light-client = "0.16.0"
light-sdk = "0.16.0"
```

### 2. RPC Connection

Connect to an RPC provider that supports ZK Compression, such as Helius and Triton.

<Tabs>
<Tab title="Mainnet">

```rust
let config = LightClientConfig::new(
    "https://api.mainnet-beta.solana.com".to_string(),
    Some("https://mainnet.helius.xyz".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Devnet">

```rust
let config = LightClientConfig::devnet(
    Some("https://devnet.helius-rpc.com".to_string()),
    Some("YOUR_API_KEY".to_string())
);

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

</Tab>

<Tab title="Localnet">

```rust
let config = LightClientConfig::local();

let mut client = LightClient::new(config).await?;

client.payer = read_keypair_file("~/.config/solana/id.json")?;
```

1. Install the CLI

```bash
npm install -g @lightprotocol/zk-compression-cli
```

2. Start a single-node Solana cluster, an RPC node, and a prover node at ports 8899, 8784, and 3001.

```bash
light test-validator
```
</Tab>
</Tabs>

</Tab>
</Tabs>
</Step>

<Step>
## Address (Create only)

<Note>
You only need to derive an address when you create a compressed account.
</Note>

<Tabs>
<Tab title="Create">
Derive a persistent address as a unique identifier for your compressed account, similar to [program-derived addresses (PDAs)](https://solana.com/docs/core/pda).

* Like PDAs, compressed account addresses don't belong to a private key; rather, they're derived from the program that owns them.
* The key difference to PDAs is that compressed accounts require an **address tree** parameter.
* An address tree is a Merkle tree that stores the compressed account addresses.

<Tip>
The protocol maintains Merkle trees. You don't need to initialize custom trees. Find the [pubkeys for Merkle trees here](https://www.zkcompression.com/resources/addresses-and-urls).
</Tip>

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="V1 Address Trees">

```typescript
const addressTree = getDefaultAddressTreeInfo();
const seed = deriveAddressSeed(
  [Buffer.from('my-seed')],
  programId
);
const address = deriveAddress(
  seed,
  addressTree.tree
);
```

**1. Derive the seed**

**2. Then, derive the address**:

* Pass the derived 32-byte `seed` from the first step
* Specify `addressTree.tree` pubkey to ensure an address is unique to an address tree. Different trees produce different addresses from identical seeds.
</Tab>

<Tab title="V2 Address Trees">

```typescript
const addressTree = await rpc.getAddressTreeInfoV2();
const seed = deriveAddressSeedV2(
  [Buffer.from('my-seed')]
);

const address = deriveAddressV2(
  seed,
  addressTree.tree,
  programId
);
```

**1. Derive the seed**

**2. Then, derive the address**:

* Pass the derived 32-byte `seed` from the first step.
* Specify `addressTree.tree` pubkey to ensure an address is unique to an address tree. Different trees produce different addresses from identical seeds.
* Specify your *`programId` in this step.*
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="V1 Address Trees">

```rust
use light_sdk::address::v1::derive_address;

let address_tree_info = rpc.get_address_tree_v1();
let (address, _) = derive_address(
    &[b"my-seed"],
    &address_tree_info.tree,
    &program_id,
);
```

</Tab>

<Tab title="V2 Address Trees">

```rust
use light_sdk::address::v2::derive_address;

let address_tree_info = rpc.get_address_tree_v2();
let (address, _) = derive_address(
    &[b"my-seed"],
    &address_tree_info.tree,
    &program_id,
);
```

</Tab>
</Tabs>

**Pass these parameters**:

* `&[b"my-seed"]`: Predefined inputs, such as strings, numbers or other account addresses.
* `&address_tree_info.tree`: Specify the tree pubkey to ensure an address is unique to this address tree. Different trees produce different addresses from identical seeds.
* `&program_id`: Specify your program ID.
</Tab>
</Tabs>

<Tip>
**Use the same address** tree for all subsequent instructions **in client and program**.
</Tip>
</Tab>
</Tabs>
</Step>

<Step>
## Validity Proof

Transactions with compressed accounts must include a validity proof:
* To **create** a compressed account, you prove the **address doesn't already exist** in the address tree.
* In **other instructions**, you **prove its account hash exists** in a state tree.
* You can **combine multiple addresses and hashes in one proof** to optimize compute cost and instruction data.

<Info>
You fetch a validity proof from your RPC provider that supports ZK Compression (Helius, Triton, ...).
</Info>

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = await rpc.getValidityProofV0(
  [],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* **Specify the derived address**, `tree` and `queue` pubkeys from the address tree `TreeInfo`.
* When you create an account you don't reference a compressed account hash in the hash array (`[]`).
<Note>
For account creation, you prove the address does not exist yet in the address tree.
</Note>
**2. The RPC returns**:

* `compressedProof` with the proof that the address does not exist in the address tree for your instruction data (Step 5)
* `rootIndices` array with root index from the validity proof for the address tree.
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  []
);
```

**1. Pass these parameters**:

Specify the **account hash**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.

<Note>
* You don't specify the address for update, close, reinitialize, and burn instructions. 
* The proof **verifies the account hash exists in the state tree** for these instructions. 
* The validity proof structure is identical. The difference is in your program's instruction handler.
</Note>

**2. The RPC returns**:

* `compressedProof` with the proof that the account hash exists in the state tree for your instruction data (Step 5)
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts (Step 4).
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```


**1. Pass these parameters**:
* **Specify the derived address** and `tree` pubkey from the address tree `TreeInfo`. The `queue` pubkey is only required in TypeScript.
* When you create an account you don't reference a compressed account hash in the hash array (`vec![]`).
<Note>
For account creation, you prove the address does not exist yet in the address tree.
</Note>

**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with the proof that the address does not exist in the address tree for your instruction data (Step 5)
* `addresses` with the public key and metadata of the address tree to pack accounts (Step 4).
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![],
        None,
    )
    .await?
    .value;
```

**1. Pass these parameters**:

Specify the **account hash**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
<Note>
* You don't specify the address for update, close, reinitialize, and burn instructions. 
* The proof **verifies the account hash exists in the state tree** for these instructions. 
* The validity proof structure is identical. The difference is in your program's instruction handler.
</Note>
**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with the proof that the **account hash exists in the state tree** for your instruction data (Step 5)
* `accounts` with the **public key and metadata of the state tree** to pack accounts (Step 4).
</Tab>
</Tabs>
</Tab>
</Tabs>

### Optimize with Combined Proofs

A single proof can contain:
* multiple addresses,
* multiple account hashes, or
* a combination of addresses and account hashes

<Tip>
**Advantages of combined proofs**:
* You only add **one 128 byte validity proof** to your instruction data **for multiple instructions**.
* This can **optimize** your **transaction's size** to stay inside the 1232 byte limit.
* **Compute unit consumption is reduced by at least 100k CU**, since combined proofs are verified in a single CPI by the Light System Program.
</Tip>

Depending on the **Merkle tree version** (V1 or V2) you are using, you can prove the following **in a single proof**:

<Tabs>
<Tab title="V1">
|              |                  |
| ----------------------- | --------------------------------------------------- |
| Account Hash-only (bulk)        | 1, 2, 3, 4, or 8 hashes                            |
| Address-only (bulk)     | 1, 2, 4, or 8 addresses                            |
| Mixed (hash + address)  | Any combination of <br/>**1, 2, 3, 4, or 8** account hashes **and** <br/>**1, 2, 4, or 8** new addresses |
</Tab>

<Tab title="V2">

|              |                   |
| ----------------------- | --------------------------------------------------- |
| Account Hash-only (bulk)        | 1 to 20 hashes                                     |
| Address-only (bulk)     | 1 to 32 addresses                                  |
| Mixed (hash + address)  | Any combination of <br/>**1 to 4** account hashes **and** <br/>**1 to 4** new addresses |
</Tab>
</Tabs>

<Note>
View the [source code for the proof combinations here](https://github.com/Lightprotocol/light-protocol/tree/871215642b4b5b69d2bcd7eca22542346d0e2cfa/program-libs/verifier/src/verifying_keys).
</Note>

### Example Create Address & Update Account in one Proof

In this example, we generate one proof that proves that an account exists and that an address does not exist yet. 
This updates an account and create the address for a new account.

<Tabs>
<Tab title="Typescript">

```typescript
const proof = await rpc.getValidityProofV0(
  [{
    hash: compressedAccount.hash,
    tree: compressedAccount.treeInfo.tree,
    queue: compressedAccount.treeInfo.queue
  }],
  [{
    address: bn(address.toBytes()),
    tree: addressTree.tree,
    queue: addressTree.queue
  }]
);
```

**1. Pass these parameters**:

* Specify one or more **account hashes**, `tree` and `queue` pubkeys from the compressed account's `TreeInfo`.
* Specify one or more **derived addresses** with their `tree` and `queue` pubkeys from the address tree `TreeInfo`.

**2. The RPC returns**:

* `compressedProof` with a single combined proof that verifies both the **account hash exists in the state tree** and the **address does not exist in the address tree** for your instruction data (Step 5)
* `rootIndices` and `leafIndices` arrays with proof metadata to pack accounts (Step 4).
</Tab>

<Tab title="Rust">

```rust
let rpc_result = rpc
    .get_validity_proof(
        vec![compressed_account.hash],
        vec![AddressWithTree {
          address: *address,
          tree: address_tree_info.tree
        }],
        None,
    )
    .await?
    .value;
```

**1. Pass these parameters**:

* Specify one or more **compressed account hashes**.
* Specify one or more **derived addresses** with their `tree` pubkeys from the address tree `TreeInfo`. The `queue` pubkey is only required in TypeScript.

**2. The RPC returns `ValidityProofWithContext`**:

* `proof` with a single combined proof that verifies both the **account hash exists in the state tree** and the **address does not exist in the address tree** for your instruction data (Step 5)
* `addresses` with the public key and metadata of the address tree to pack accounts (Step 4).
* `accounts` with the public key and metadata of the state tree to pack accounts (Step 4).
</Tab>
</Tabs>

<Note>
See the full [create-and-update program example for this proof combination with tests](https://github.com/Lightprotocol/program-examples/tree/main/create-and-update).
</Note>
</Step>

<Step>
## Accounts

Transactions with compressed accounts reference **custom accounts and `PackedAccounts`** in their instruction data in the accounts array:

```
                                    PackedAccounts
                    ┌----------------------------------------------┐
 [custom accounts]  [pre accounts] [system accounts] [tree accounts]
                          ↑                ↑                  ↑
                      Signers,        Light System       State trees,
                     fee payer         accounts         address trees,                                                          
```
<Note>
The `PackedAccounts` helper allows you to **reference accounts by u8 indices instead of 32-byte pubkeys**.
</Note>

Program-specific (custom) accounts can be added to `PackedAccounts` using e.g. `add_pre_accounts_signer` or `add_pre_accounts_meta`.
These are typically accounts that need to be at a specific, known position in the instruction's account list.

<Accordion title="Light System Accounts Explained">
**Light System accounts** are 8 required accounts for proof verification and CPI calls to update state and address trees.

<table>
  <thead>
    <tr>
      <th width="20">#</th>
      <th width="200">Account</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Light System Program</td>
      <td>Verifies validity proofs, compressed account ownership checks, CPIs the account compression program to update tree accounts</td>
    </tr>
    <tr>
      <td>2</td>
      <td>CPI Signer</td>
      <td>PDA to sign CPI calls from your program to Light System Program. Verified by Light System Program during CPI. Derived from your program ID</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Registered Program PDA</td>
      <td>Access control to the Account Compression Program</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Noop Program</td>
      <td>Logs compressed account state to Solana ledger. Only used in v1. Indexers parse transaction logs to reconstruct compressed account state</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Account Compression Authority</td>
      <td>Signs CPI calls from Light System Program to Account Compression Program</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Account Compression Program</td>
      <td>Writes to state and address tree accounts. Client and the account compression program do not interact directly</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Invoking Program</td>
      <td>Your program's ID, used by Light System Program to derive the CPI Signer PDA, verify the CPI Signer matches your program ID, and set the owner of created compressed accounts</td>
    </tr>
    <tr>
      <td>8</td>
      <td>System Program</td>
      <td>Solana System Program to transfer lamports</td>
    </tr>
  </tbody>
</table>

</Accordion>


<Accordion title="Tree Accounts Explained">
**Merkle tree accounts** are state trees, address trees, and their associated queues to store compressed accounts and addresses.

Depending on your instruction you must include indices for different tree and queue accounts. 
* For other instructions than create, **use the state tree of the existing compressed account** as output state tree.
* The pubkey is automatically deduplicated when you pack accounts.

<Warning>
When creating or updating multiple accounts in a single transaction, use one output state tree. 
</Warning>

<Tip>
V2 is on Devnet and reduces compute unit consumption by up to 70%.
</Tip>
<Tabs>
<Tab title="V1 Trees">

<table>
  <thead>
    <tr>
      <th width="150">Instruction</th>
      <th width="80" className="text-center">Address Tree</th>
      <th width="80" className="text-center">State Tree</th>
      <th width="100" className="text-center">Nullifier Queue</th>
      <th width="120" className="text-center">Output State Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
    </tr>
  </tbody>
</table>

* **Address tree**: only used to derive and store a new address.
* **State tree**: used to reference the existing compressed account hash. Therefore not used by create.
* **Nullifier queue**: used to nullify the existing compressed account hash to prevent double spending. Therefore not used by create.
* **Output State tree**: used to store the new or updated compressed account hash. Burn does not produce output state.

</Tab>

<Tab title="V2 Trees">

<table>
  <thead>
    <tr>
      <th width="150">Instruction</th>
      <th width="80" className="text-center">Address Tree</th>
      <th width="200" className="text-center">State Tree (includes nullifier queue)</th>
      <th width="90" className="text-center">Output Queue</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Update / Close / Reinit</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">✓</td>
    </tr>
    <tr>
      <td>Burn</td>
      <td className="text-center">-</td>
      <td className="text-center">✓</td>
      <td className="text-center">-</td>
    </tr>
  </tbody>
</table>

* **Address tree**: only used to derive and store a new address.
* **State tree**: used to reference the existing compressed account hash. Therefore not used by create. V2 combines the state tree and nullifier queue into a single account.
* **Output State tree**: used to store the new or updated compressed account hash. Burn does not produce output state.
* **Output Queue**: used to store compressed account hashes. A forester node updates the Merkle tree asynchronously.

</Tab>
</Tabs>

</Accordion>

<Tip>
In your instruction,
1. Put your program-specific accounts first
2. Append Packed accounts to end of the vector (recommended due to variable length)
</Tip>
<Tabs>
<Tab title="Typescript">

<Tabs>
<Tab title="Create">

```typescript
// 1. Initialize helper
const packedAccounts 
  = new PackedAccounts();

// 2. Add light system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts
const addressMerkleTreePubkeyIndex 
  = packedAccounts.insertOrGet(addressTree);
const addressQueuePubkeyIndex 
  = packedAccounts.insertOrGet(addressQueue);

const packedAddressTreeInfo = {
  rootIndex: proofRpcResult.rootIndices[0],
  addressMerkleTreePubkeyIndex,
  addressQueuePubkeyIndex,
};

// 4. Get index for output state tree
const stateTreeInfos = await rpc.getStateTreeInfos();
const outputStateTree = selectStateTreeInfo(stateTreeInfos).tree;
const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 5. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>

<Tab title="Update, Close, Reinit Burn">
```typescript
// 1. Initialize helper
const packedAccounts
  = new PackedAccounts();

// 2. Add system accounts
const systemAccountConfig
  = SystemAccountMetaConfig.new(programId);
packedAccounts.addSystemAccounts(systemAccountConfig);

// 3. Get indices for tree accounts 
const merkleTreePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.tree);
const queuePubkeyIndex
  = packedAccounts.insertOrGet(compressedAccount.treeInfo.queue);

const packedInputAccounts = {
  merkleTreePubkeyIndex,
  queuePubkeyIndex,
  leafIndex: proofRpcResult.leafIndices[0],
  rootIndex: proofRpcResult.rootIndices[0],
};

const outputStateTreeIndex
  = packedAccounts.insertOrGet(outputStateTree);

// 4. Convert to Account Metas
const { remainingAccounts }
  = packedAccounts.toAccountMetas();
```
</Tab>
</Tabs>

<Note>
* Create uses address tree and address queue from the new address derivation
* Update/Close/Reinit/Burn use state tree and nullifier queue from the existing compressed account's TreeInfo
* Create derives a new address (no existing account)
* Update/Close/Reinit/Burn reference the existing compressed account
</Note>
</Tab>

<Tab title="Rust">

<Tabs>
<Tab title="Create">

```rust
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_accounts
  = rpc_result.pack_tree_infos(&mut remaining_accounts);

// 4. Get index for output state tree
let output_state_tree_info = rpc.get_random_state_tree_info()?;
let output_state_tree_index
  = output_state_tree_info.pack_output_tree_index(&mut remaining_accounts)?;

// 5. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```
</Tab>

<Tab title="Update, Close, Reinit, Burn">

```rust
// 1. Initialize helper
let mut remaining_accounts = PackedAccounts::default();

// 2. Add system accounts
let config
  = SystemAccountMetaConfig::new(program_id);
  remaining_accounts.add_system_accounts(config)?;

// 3. Get indices for tree accounts
let packed_tree_accounts = rpc_result
    .pack_tree_infos(&mut remaining_accounts)
    .state_trees // includes output_state_tree_index
    .unwrap();

// 4. Convert to Account Metas
let (remaining_accounts_metas, _, _)
  = remaining_accounts.to_account_metas();
```

</Tab>
</Tabs>
<Note>
* Create packs address tree for the new address, then adds output state tree separately
* Update/Close/Reinit/Burn pack state tree that includes output tree automatically
</Note>
</Tab>

</Tabs>

</Step>

<Step>
## Instruction Data

Build your instruction data with the validity proof, tree account indices, and account data.

<Tabs>
<Tab title="Typescript">
<Tabs>
<Tab title="Create">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  addressTreeInfo: packedAddressTreeInfo,
  outputStateTreeIndex: outputStateTreeIndex,
  message,
};
```

1. Include `compressedProof` from Step 3 to **prove the address does not exist** in the address tree
2. Specify **Merkle trees to store address and account hash** from Step 4 where you packed accounts.
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
  newMessage,
};
```

1. Include `compressedProof` from **Step 3** to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree to store the updated compressed account hash.
3. Pass **current account data** and **new data**
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Close">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
  currentMessage: currentAccount.message,
};
```

1. Include `compressedProof` from **Step 3** to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree to store the **hash with zero values** for the closed account.
3. Pass **current account data**
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Reinit">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address,
    outputStateTreeIndex: outputStateTreeIndex
  },
};
```

1. Include `compressedProof` from **Step 3** to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packedStateTreeInfo` and the output state tree that will store the reinitialized account hash
3. Reinitialize creates an account with **default-initialized values**
* These values are `Pubkey` as all zeros, numbers as `0`, strings as empty.
* To set custom values, update the account in the same or a separate transaction.
<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>
</Tab>

<Tab title="Burn">

```typescript
const proof = {
  0: proofRpcResult.compressedProof,
};

const instructionData = {
  proof,
  accountMeta: {
    treeInfo: packedStateTreeInfo,
    address: compressedAccount.address
  },
  currentMessage: currentAccount.message,
};
```

1. Include `compressedProof` from **Step 3** to prove the **account hash exists** in the state tree
2. Specify the existing accounts address and its `packedStateTreeInfo`. You don't need to specify the output state tree, since burn permanently removes the account.
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>

<Tab title="Rust">
<Tabs>
<Tab title="Create">

```rust
let instruction_data = create::instruction::CreateAccount {
    proof: rpc_result.proof,
    address_tree_info: packed_accounts.address_trees[0],
    output_state_tree_index: output_state_tree_index,
    message,
}
.data();
```

1. Include `proof` from Step 3 to prove the **address does not exist** in the address tree
2. Specify **address tree and output state tree** from Step 4 where you packed accounts
3. Pass **initial account data**
</Tab>

<Tab title="Update">

```rust
let instruction_data = update::instruction::UpdateAccount {
    proof: rpc_result.proof,
    current_account,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    new_message,
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` from Step 3 to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree to store the updated compressed account hash
3. Pass **current account data** and **new data**

</Tab>

<Tab title="Close">

```rust
let instruction_data = close::instruction::CloseAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
    current_message,
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` from Step 3 to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree to store the **hash with zero values** for the closed account
3. Pass **current account data**

</Tab>

<Tab title="Reinit">

```rust
let instruction_data = reinit::instruction::ReinitAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMeta {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
        output_state_tree_index: packed_tree_accounts.output_tree_index,
    },
}
.data();
```

<Tip>
Use the state tree of the existing compressed account as output state tree.
</Tip>

1. Include `proof` from Step 3 to prove the **account hash exists** in the state tree
2. Specify the existing accounts address, its `packed_tree_infos` and the output state tree that will store the reinitialized account hash
3. Reinitialize creates an account with **default-initialized values**
* These values are `Pubkey` as all zeros, numbers as `0`, strings as empty.
* To set custom values, update the account in the same or a separate transaction.
</Tab>

<Tab title="Burn">

```rust
let instruction_data = burn::instruction::BurnAccount {
    proof: rpc_result.proof,
    account_meta: CompressedAccountMetaBurn {
        tree_info: packed_tree_accounts.packed_tree_infos[0],
        address: compressed_account.address.unwrap(),
    },
    current_message,
}
.data();
```

1. Include `proof` from Step 3 to prove the **account hash exists** in the state tree
2. Specify the existing accounts address and its `packed_tree_infos`. You don't need to specify the output state tree, since burn permanently removes the account
3. Pass **current account data**
</Tab>
</Tabs>
</Tab>
</Tabs>

<Warning>
* When creating or updating multiple accounts in a single transaction, use one output state tree. 
* Minimize the number of different trees per transaction to keep instruction data light.
</Warning>

</Step>

<Step>
## Instruction

Build the instruction with your `program_id`, `accounts`, and `data` from Step 5.

<Tip>
In `accounts`,
1. Put your program-specific accounts first
2. Append Packed accounts to end of the vector (recommended due to variable length)
</Tip>

```rust
let instruction = Instruction {
    program_id: program_id,
    accounts: [
        vec![AccountMeta::new(payer.pubkey(), true)],
        remaining_accounts,
    ]
    .concat(),
    data: instruction_data,
};
```

</Step>

<Step>
## Send Transaction

</Step>
</Steps>

# Full Code Examples

<Tabs>
<Tab title="Typescript">
```typescript expandable wrap
// create.ts
import * as anchor from "@coral-xyz/anchor";
import { Program, web3 } from "@coral-xyz/anchor";
import { Create } from "../target/types/create";
import idl from "../target/idl/create.json";
import {
  bn,
  CompressedAccountWithMerkleContext,
  confirmTx,
  createRpc,
  defaultStaticAccountsStruct,
  defaultTestStateTreeAccounts,
  deriveAddress,
  deriveAddressSeed,
  LightSystemProgram,
  PackedAccounts,
  Rpc,
  sleep,
  SystemAccountMetaConfig,
} from "@lightprotocol/stateless.js";
import * as assert from "assert";

const path = require("path");
const os = require("os");
require("dotenv").config();

const anchorWalletPath = path.join(os.homedir(), ".config/solana/id.json");
process.env.ANCHOR_WALLET = anchorWalletPath;

describe("test-anchor", () => {
  const program = anchor.workspace.Create as Program<Create>;
  const coder = new anchor.BorshCoder(idl as anchor.Idl);

  it("create compressed account", async () => {
    let signer = new web3.Keypair();
    let rpc = createRpc(
      "http://127.0.0.1:8899",
      "http://127.0.0.1:8784",
      "http://127.0.0.1:3001",
      {
        commitment: "confirmed",
      },
    );
    let lamports = web3.LAMPORTS_PER_SOL;
    await rpc.requestAirdrop(signer.publicKey, lamports);
    await sleep(2000);

    const outputStateTree = defaultTestStateTreeAccounts().merkleTree;
    const addressTree = defaultTestStateTreeAccounts().addressTree;
    const addressQueue = defaultTestStateTreeAccounts().addressQueue;

    const messageSeed = new TextEncoder().encode("message");
    const seed = deriveAddressSeed(
      [messageSeed, signer.publicKey.toBytes()],
      new web3.PublicKey(program.idl.address),
    );
    const address = deriveAddress(seed, addressTree);

    // Create compressed account with message
    const txId = await createCompressedAccount(
      rpc,
      addressTree,
      addressQueue,
      address,
      program,
      outputStateTree,
      signer,
      "Hello, compressed world!",
    );
    console.log("Transaction ID:", txId);

    // Wait for indexer to process the transaction
    const slot = await rpc.getSlot();
    await rpc.confirmTransactionIndexed(slot);

    let compressedAccount = await rpc.getCompressedAccount(bn(address.toBytes()));
    let myAccount = coder.types.decode(
      "MyCompressedAccount",
      compressedAccount.data.data,
    );

    console.log("Decoded data owner:", myAccount.owner.toBase58());
    console.log("Decoded data message:", myAccount.message);

    // Verify account data
    assert.ok(
      myAccount.owner.equals(signer.publicKey),
      "Owner should match signer public key"
    );
    assert.strictEqual(
      myAccount.message,
      "Hello, compressed world!",
      "Message should match the created message"
    );
  });
});

async function createCompressedAccount(
  rpc: Rpc,
  addressTree: anchor.web3.PublicKey,
  addressQueue: anchor.web3.PublicKey,
  address: anchor.web3.PublicKey,
  program: anchor.Program<Create>,
  outputStateTree: anchor.web3.PublicKey,
  signer: anchor.web3.Keypair,
  message: string,
) {
  const proofRpcResult = await rpc.getValidityProofV0(
    [],
    [
      {
        tree: addressTree,
        queue: addressQueue,
        address: bn(address.toBytes()),
      },
    ],
  );
  const systemAccountConfig = new SystemAccountMetaConfig(program.programId);
  let remainingAccounts = new PackedAccounts();
  remainingAccounts.addSystemAccounts(systemAccountConfig);

  const addressMerkleTreePubkeyIndex =
    remainingAccounts.insertOrGet(addressTree);
  const addressQueuePubkeyIndex = remainingAccounts.insertOrGet(addressQueue);
  const packedAddressTreeInfo = {
    rootIndex: proofRpcResult.rootIndices[0],
    addressMerkleTreePubkeyIndex,
    addressQueuePubkeyIndex,
  };
  const outputStateTreeIndex =
    remainingAccounts.insertOrGet(outputStateTree);
  let proof = {
    0: proofRpcResult.compressedProof,
  };
  const computeBudgetIx = web3.ComputeBudgetProgram.setComputeUnitLimit({
    units: 1000000,
  });
  let tx = await program.methods
    .createAccount(proof, packedAddressTreeInfo, outputStateTreeIndex, message)
    .accounts({
      signer: signer.publicKey,
    })
    .preInstructions([computeBudgetIx])
    .remainingAccounts(remainingAccounts.toAccountMetas().remainingAccounts)
    .signers([signer])
    .transaction();
  tx.recentBlockhash = (await rpc.getRecentBlockhash()).blockhash;
  tx.sign(signer);

  const sig = await rpc.sendTransaction(tx, [signer]);
  await confirmTx(rpc, sig);
  return sig;
}
```
</Tab>

<Tab title="Rust">
```rust expandable wrap
// test.rs
#![cfg(feature = "test-sbf")]

use anchor_lang::AnchorDeserialize;
use light_program_test::{
    program_test::LightProgramTest, AddressWithTree, Indexer, ProgramTestConfig, Rpc, RpcError,
};
use light_sdk::{
    address::v1::derive_address,
    instruction::{PackedAccounts, SystemAccountMetaConfig},
};
use create::MyCompressedAccount;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signature, Signer},
};

#[tokio::test]
async fn test_create() {
    let config = ProgramTestConfig::new(true, Some(vec![("create", create::ID)]));
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let address_tree_info = rpc.get_address_tree_v1();

    let (address, _) = derive_address(
        &[b"message", payer.pubkey().as_ref()],
        &address_tree_info.tree,
        &create::ID,
    );

    create_compressed_account(&mut rpc, &payer, &address, "Hello, compressed world!".to_string())
        .await
        .unwrap();

    let compressed_account = rpc
        .get_compressed_account(address, None)
        .await
        .unwrap()
        .value
        .unwrap();
    let data = &compressed_account.data.as_ref().unwrap().data;
    let account = MyCompressedAccount::deserialize(&mut &data[..]).unwrap();
    assert_eq!(account.owner, payer.pubkey());
    assert_eq!(account.message, "Hello, compressed world!");
}

async fn create_compressed_account(
    rpc: &mut LightProgramTest,
    payer: &Keypair,
    address: &[u8; 32],
    message: String,
) -> Result<Signature, RpcError> {
    let config = SystemAccountMetaConfig::new(create::ID);
    let mut remaining_accounts = PackedAccounts::default();
    remaining_accounts.add_system_accounts(config)?;

    let address_tree_info = rpc.get_address_tree_v1();

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: *address,
                tree: address_tree_info.tree,
            }],
            None,
        )
        .await?
        .value;
    let packed_accounts = rpc_result.pack_tree_infos(&mut remaining_accounts);

    let output_state_tree_index = rpc
        .get_random_state_tree_info()?
        .pack_output_tree_index(&mut remaining_accounts)?;

    let (remaining_accounts, _, _) = remaining_accounts.to_account_metas();

    let instruction = Instruction {
        program_id: create::ID,
        accounts: [
            vec![AccountMeta::new(payer.pubkey(), true)],
            remaining_accounts,
        ]
        .concat(),
        data: {
            use anchor_lang::InstructionData;
            create::instruction::CreateAccount {
                proof: rpc_result.proof,
                address_tree_info: packed_accounts.address_trees[0],
                output_state_tree_index: output_state_tree_index,
                message,
            }
            .data()
        },
    };

    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[payer])
        .await
}
```
</Tab>
</Tabs>

Find all [full code examples with Rust and Typescript tests here](https://github.com/Lightprotocol/program-examples/tree/add-basic-operations-examples/basic-operations/anchor) for the following instructions:
- **create** - Initialize a new compressed account
- **update** - Modify data of an existing compressed account
- **close** - Close a compressed account (it can be initialized again).
- **reinit** - Reinitialize a closed account
- **burn** - Permanently delete a compressed account (it cannot be initialized again).

<Warning>
For help with debugging, see the [Error Cheatsheet](https://www.zkcompression.com/resources/error-cheatsheet) and [AskDevin](https://deepwiki.com/Lightprotocol/light-protocol/3.1-javascripttypescript-sdks).
</Warning>

# Next Steps

<Card
  title=" Learn how to Create Compressed Accounts"
  icon="chevron-right"
  color="#0066ff"
  href="/c-token/ctoken-overview"
  horizontal
>
</Card>
