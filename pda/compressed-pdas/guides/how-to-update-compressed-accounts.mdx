---
title: Update Compressed Accounts
description: Guide to update compressed accounts in Solana programs with full code examples.
keywords: ["update compressed accounts", "modify compressed pda"]
---

import CompressedPdasProgramSetup from '/snippets/setup/compressed-pdas-program-setup.mdx';
import CompressedPdasSystemAccountsList from '/snippets/accounts-list/compressed-pdas-system-accounts-list.mdx';
import DevelopmentEnvironmentSetup from '/snippets/setup/development-environment-setup.mdx';
import AnchorProgram from '/snippets/code-snippets/update/anchor-program.mdx';
import NativeProgram from '/snippets/code-snippets/update/native-program.mdx';
import CpiUpdateAiPrompt from '/snippets/ai-prompts/cpi-programs/update.mdx';

Compressed accounts are updated via CPI to the Light System Program.

The update of a compressed account follows a UTXO pattern, unlike regular Solana accounts that overwrite data in place. Each update of a compressed account

* consumes the existing account hash and
* produces a new account hash with updated data.
* The existing account hash is nullified to prevent double spending.

<Note>
Find [full code examples at the end](/pda/compressed-pdas/guides/how-to-update-compressed-accounts#full-code-example) for Anchor and native Rust.
</Note>

# Implementation Guide

This guide will cover the components of a Solana program that updates compressed accounts.\
Here is the complete flow:

<div className="hidden dark:block">
<Frame>
  ![](/images/program-update-1.png)
</Frame>
</div>
<div className="block dark:hidden">
<Frame>
  ![](/images/program-update.png)
</Frame>
</div>

<Tabs>
<Tab title="Guide">
<Steps>
<Step>

### Program Setup

<Accordion title="Dependencies, Constants, Compressed Account">

<CompressedPdasProgramSetup />

</Accordion>
</Step>

<Step>

### Instruction Data

Define the instruction data with the following parameters:

<Tabs>
<Tab title="Anchor">
Anchor handles instruction deserialization automatically. Pass the parameters directly to the instruction function:

```rust
pub fn update_account<'info>(
    ctx: Context<'_, '_, '_, 'info, GenericAnchorAccounts<'info>>,
    proof: ValidityProof,
    current_account: MyCompressedAccount,
    account_meta: CompressedAccountMeta,
    new_message: String,
) -> Result<()>
```
</Tab>

<Tab title="Native Rust">
```rust
pub struct UpdateInstructionData {
    pub proof: ValidityProof,
    pub account_meta: CompressedAccountMeta,
    pub current_message: String,
    pub new_message: String,
}
```
</Tab>
</Tabs>

1. **Validity Proof**

* Define `proof` to include the proof that the account exists in the state tree.
* Clients fetch a validity proof with `getValidityProof()` from an RPC provider that supports ZK Compression (Helius, Triton, ...).

2. **Specify input state and output state tree (stores updated account hash)**

* Define `account_meta: CompressedAccountMeta` to reference the existing account and specify the state tree to store the updated account hash:
  * `tree_info: PackedStateTreeInfo`: References the existing account hash in the state tree.
  * `address`: The account's derived address.
  * `output_state_tree_index`: References the state tree account that will store the updated account hash.

<Info>
Clients fetch the current account with `getCompressedAccount()` and populate `CompressedAccountMeta` with the account's metadata.
</Info>

3. **Current account data**

* Define fields to include the current account data passed by the client.
* This depends on your program logic. This example includes `current_message` (or `current_account` in Anchor) and `new_message` fields.
  * `new_message` contains the new data that will replace the message field of the compressed account after the update.
</Step>

<Step>

### Update Compressed Account

Load the compressed account and update it with `LightAccount::new_mut()`.

<Note>
`new_mut()`:

* hashes the current account data as input state and
* lets your program define the output state.
</Note>

<Tabs>
<Tab title="Anchor">
```rust
let mut my_compressed_account = LightAccount::<MyCompressedAccount>::new_mut(
    &crate::ID,
    &account_meta,
    current_account,
)?;

my_compressed_account.message = new_message.clone();
```
</Tab>

<Tab title="Native Rust">
```rust
let mut my_compressed_account = LightAccount::<MyCompressedAccount>::new_mut(
    &ID,
    &instruction_data.account_meta,
    MyCompressedAccount {
        owner: *signer.key,
        message: instruction_data.current_message,
    },
)?;

my_compressed_account.account.message = instruction_data.new_message;
```
</Tab>
</Tabs>

**Pass these parameters to `new_mut()`:**

* `&program_id`: The program's ID that owns the compressed account.
* `&account_meta`: The `CompressedAccountMeta` from instruction data (_Step 2_) that identifies the existing account and specifies the output state tree.
* Include the curent account data.
  * Anchor: Pass `current_account` directly
  * Native: Construct `MyCompressedAccount` with data from `instruction_data`

**The SDK creates:**

* A `LightAccount` wrapper similar to Anchor's `Account`.
* `new_mut()` lets the program modify the output state. This example sets `message` to `new_message`.

<Info>
`new_mut()` only hashes the input state. The Light System Program verifies that input hash exists in a state tree and creates the output hash in _Step 4._
</Info>
</Step>

<Step>

### Light System Program CPI

Invoke the Light System Program to update the compressed account.

<Note>
The Light System Program

* validates the account exists in state tree,
* nullifies the existing account hash in the state tree, and
* appends the updated account hash to the state tree.
</Note>

<Tabs>
<Tab title="Anchor">
```rust
let light_cpi_accounts = CpiAccounts::new(
    ctx.accounts.signer.as_ref(),
    ctx.remaining_accounts,
    crate::LIGHT_CPI_SIGNER,
);

LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, proof)
    .with_light_account(my_compressed_account)?
    .invoke(light_cpi_accounts)?;
```

**Set up `CpiAccounts::new()`:**

`CpiAccounts::new()` parses accounts for the CPI call to Light System Program.

**Pass these parameters:**

* `ctx.accounts.signer.as_ref()`: the transaction signer
* `ctx.remaining_accounts`: Slice with `[system_accounts, ...packed_tree_accounts]`. The client builds this with `PackedAccounts` and passes it to the instruction.
* `&LIGHT_CPI_SIGNER`: Your program's CPI signer PDA defined in Constants.
</Tab>

<Tab title="Native Rust">
```rust
let signer = accounts.first();

let light_cpi_accounts = CpiAccounts::new(
    signer,
    &accounts[1..],
    LIGHT_CPI_SIGNER
);

LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, instruction_data.proof)
    .with_light_account(my_compressed_account)?
    .invoke(light_cpi_accounts)?;
```


**Set up `CpiAccounts::new()`:**

`CpiAccounts::new()` parses accounts for the CPI call to Light System Program.

**Pass these parameters:**

* `signer`: account that signs and pays for the transaction
* `&accounts[1..]`: Slice with `[system_accounts, ...packed_tree_accounts]`. The client builds this with `PackedAccounts`.
* `&LIGHT_CPI_SIGNER`: Your program's CPI signer PDA defined in Constants.
</Tab>
</Tabs>

<Accordion title="System Accounts List">

<CompressedPdasSystemAccountsList />

</Accordion>

**Build the CPI instruction**:

* `new_cpi()` initializes the CPI instruction with the `proof` to prove that the account exists in the specified state tree - _in the Instruction Data (Step 2)._
* `with_light_account` adds the `LightAccount` with the modified compressed account data _- defined in Step 3_
* `invoke(light_cpi_accounts)` calls the Light System Program with `CpiAccounts`.
</Step>
</Steps>
</Tab>
<Tab title="AI Prompt">
<CpiUpdateAiPrompt />
</Tab>
</Tabs>

# Full Code Example

The example programs below implement all steps from this guide.

<Accordion title="Setup">
<DevelopmentEnvironmentSetup />
</Accordion>

<Warning>
For help with debugging, see the [Error Cheatsheet](/resources/error-cheatsheet).
</Warning>

<Tabs>
<Tab title="Anchor">
<Info>
Find the source code [here](https://github.com/Lightprotocol/program-examples/tree/main/basic-operations/anchor/update).
</Info>

<AnchorProgram />
</Tab>

<Tab title="Native Rust">
<Info>
Find the source code [here](https://github.com/Lightprotocol/program-examples/tree/main/basic-operations/native/programs/update).
</Info>

<NativeProgram />
</Tab>
</Tabs>

# Next Steps

<CardGroup>
<Card
  title="Build a client for your program"
  icon="chevron-right"
  color="#0066ff"
  href="/pda/compressed-pdas/guides/client-guide"
  horizontal
/>
<Card
  title="Learn how to close compressed accounts"
  icon="chevron-right"
  color="#0066ff"
  href="/pda/compressed-pdas/guides/how-to-close-compressed-accounts"
  horizontal
/>
</CardGroup>
