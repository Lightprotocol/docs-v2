---
title: "Router Integration"
description: "Add support for rent-free AMMs on Solana."
---

1. Use `get_account_interface` instead of `get_account` to store `AccountInterface`.
2. Use the AMM's `LightProgram` trait to load inactive markets when needed.


## Step 1: Use `get_account_interface`

`get_account_interface` is a new RPC endpoint that returns a superset of
`get_account`. `AccountInterface` stores additional info in `Option<ColdContext>`
that you will need later.

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
<div>
<h4>Account</h4>
```rust
pub struct Account {
    pub lamports: u64,
    pub data: Vec<u8>,
    pub owner: Pubkey,
    pub executable: bool,
    pub rent_epoch: Epoch,
}
```
</div>
<div>
<h4>AccountInterface</h4>
```rust
pub struct AccountInterface {
   key: Pubkey,
   account: Account,
   cold: Option<ColdContext>
}
```
</div>
</div>


## Step 2: Use the LightProgram trait
All rent-free programs expose a `LightProgram` trait in their SDK.

Using this trait allows you to:

1. Check which accounts a given instruction references.
2. Build load specs for cold accounts needed by `create_load_instructions`.

```rust
// AMM SDK implements this.
pub trait LightProgram {
    type Variant: Pack<AccountMeta> + Clone + Debug;
    type Instruction;

    fn program_id() -> Pubkey;
    fn instruction_accounts(&self, ix: &Self::Instruction) -> Vec<Pubkey>;
    fn load_specs(&self, cold_accounts: &[AccountInterface]) -> Result<Vec<AccountSpec<Self::Variant>>, Box<dyn Error>>;
}
```

## Step 3: Load cold accounts when building Swap instructions
When building Swap instructions, prepend a `create_load_instructions` call.

This only adds latency if markets are cold.

```rust
// Check which accounts the swap references
let pubkeys = sdk.instruction_accounts(&AmmInstruction::Swap);

// Fetch their current state
let accounts = rpc.get_multiple_account_interfaces(pubkeys.iter().collect(), None).await?.value;
let cold: Vec<_> = accounts.into_iter().flatten().filter(|a| a.is_cold()).collect();

// If any are cold, build load instructions
if !cold.is_empty() {
    let specs = sdk.load_specs(&cold)?;
    let load_ixs = create_load_instructions(&specs, payer.pubkey(), config_pda, &rpc).await?;
    instructions.extend(load_ixs);
}

// add swap instruction...
```


## Full Example

### Dependencies

```toml
[dependencies]
light-client = {version = "0.18.0", features = ["v2"]}

# Example Program SDK that implements LightProgram (provided by AMM team)
example-amm-sdk = "0.1"
```

### Code

```rust expandable
use light_client::interface::{create_load_instructions, LightProgram};
use example_amm_sdk::{ExampleAmmSdk, AmmInstruction};

// 1. Fetch pool state (works for both hot and cold)
let pool_interface = rpc
    .get_account_interface(&pool_address, None)
    .await?
    .value
    .expect("pool should exist");

// 2. Construct SDK from pool data
let sdk = ExampleAmmSdk::new(pool_address, pool_interface.data())?;

// 3. Quote (works same for hot or cold -- data is always available)
let quote = sdk.quote(amount_in, min_out)?;

// 4. Build transaction
let mut ixs = vec![];

// Check which accounts the swap references and fetch them
let pubkeys = sdk.instruction_accounts(&AmmInstruction::Swap);
let accounts = rpc.get_multiple_account_interfaces(pubkeys.iter().collect(), None).await?.value;
let cold: Vec<_> = accounts.into_iter().flatten().filter(|a| a.is_cold()).collect();

// If any are cold, build load instructions
if !cold.is_empty() {
    let specs = sdk.load_specs(&cold)?;
    let load_ixs = create_load_instructions(&specs, payer.pubkey(), config_pda, &rpc).await?;
    ixs.extend(load_ixs);
}

// Add actual swap instruction
ixs.push(sdk.swap_ix(&swap_params)?);

// 5. Send
rpc.send_transaction(&ixs, &payer).await?;
```

### Key Types

| Type | Source | Purpose |
|------|--------|---------|
| `Rpc` trait | `light-client` | RPC client with `get_account_interface` methods |
| `AccountInterface` | `light-client` | Unified hot/cold account type |
| `LightProgram` | `light-client` | Trait that program SDKs implement |
| `AccountSpec` | `light-client` | Specifies account load requirements |

### Reference Implementation

| Resource | Link |
|----------|------|
| AMM Program | [cp-swap-reference](https://github.com/Lightprotocol/cp-swap-reference) |
| LightProgram Trait Impl | [CpSwapSdk](https://github.com/Lightprotocol/cp-swap-reference/blob/main/programs/cp-swap/tests/program.rs#L409) |
| Client Test | [program.rs](https://github.com/Lightprotocol/cp-swap-reference/blob/main/programs/cp-swap/tests/program.rs) |

---

## Hot vs Cold

| | Hot | Cold |
|---|-----|------|
| On-chain | Yes | Ledger (compressed) |
| Quote | Works | Works |
| Swap | Direct | Load first / Bundle |
| Latency | Normal | +0-200ms* |
| Tx size | Normal | +100-2400 bytes*|
| CU | Normal | +15k-400k CU*|

Latency, tx size, and CU depend on the number and type of cold accounts.

### When does a market go cold?
Accounts become "cold" after extended inactivity, causing their virtual rent balance to fall below a threshold. Once cold, they auto-compress onto the Solana ledger.

They remain cold until the first client loads them back into the hot state in-flight via `create_load_instructions`.

**In practice, touching cold markets is rare.** The common path ("hot") has no extra latency, tx size, or CU overhead.

---
## Error Handling

```rust
use light_client::error::LightClientError;

match rpc.get_account_interface(&pool_address, None).await {
    Ok(account) => {
        // Account is hot or cold
        // Proceed with quote and swap
    }
    Err(LightClientError::AccountNotFound) => {
        // Account does not exist
    }
}
```

## FAQ

<Accordion title="Do I need to change my swap instructions?">
No. In all cases, swap instructions stay the same.
If the market is active (hot), the transaction is identical to today (UX, CU, latency, txn size,...). 
If the market is inactive (cold), you additionally prepend `create_load_instructions`.
</Accordion>

<Accordion title="Can I quote cold markets?"> Yes. `get_account_interface` is a
superset of `get_account` and returns the full account state via the same `Account`
type, regardless of whether the account is hot or cold. Quoting works all the same. </Accordion>

<Accordion title="Do rent-free markets increase latency?"> 
  **Active markets (hot path)**: No additional latency.

  **Inactive markets (cold)**: Yes, loading accounts back into Solana's active state adds
  1-200ms depending on whether a validity proof is needed. If loading multiple
  cold accounts exceeds Solana's 1232 byte limit, use Jito bundles to maintain
  atomicity and reduce latency. Future updates will continue to reduce
  transaction size and CU usage for loading cold accounts. 
</Accordion>

<Accordion title="How long do accounts stay hot after loading?">
Accounts stay hot until they become inactive again. After extended inactivity (configurable by the program owner, e.g., 24h of no writes), their virtual rent balance falls below a threshold and foresters compress them back to cold state. Each write extends the "hot" period.
</Accordion>

<Accordion title="Does loading cold accounts exceed Solana's txn size limit?">

In some cases, yes. You can detect this at runtime by inspecting the Instructions returned by `create_load_instructions`. 

Note that the SDK deduplicates many of the account keys over the wire, so
instructions that may appear large in isolation will be incremental when
combined with other instructions, such as Swap and Deposit.

If load instructions + swap instructions exceed Solana's 1232 byte limit, send as a Jito bundle:


```rust expandable
use solana_sdk::{instruction::Instruction, pubkey::Pubkey, system_instruction};

const JITO_TIP_ACCOUNTS: &[&str] = &[
    "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
    "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
    "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
    "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
    "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
    "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
    "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
    "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
];

fn jito_tip_ix(payer: &Pubkey, tip_lamports: u64) -> Instruction {
    let tip_account = JITO_TIP_ACCOUNTS[rand::random::<usize>() % JITO_TIP_ACCOUNTS.len()]
        .parse::<Pubkey>().unwrap();
    system_instruction::transfer(payer, &tip_account, tip_lamports)
}

// Add tip to last transaction, serialize, send to Jito
let tip_ix = jito_tip_ix(&payer.pubkey(), 10_000); // 10k lamports
swap_ixs.push(tip_ix);

let bundle = vec![load_tx_base64, swap_tx_base64];
let resp = client
    .post("https://mainnet.block-engine.jito.wtf/api/v1/bundles")
    .json(&serde_json::json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "sendBundle",
        "params": [bundle, {"encoding": "base64"}]
    }))
    .send().await?;
```
</Accordion>

<Accordion title="Do RPC providers support these interface endpoints?">
Yes. The relevant RPC methods are supported by providers such as Helius and Triton and can also be self-hosted via the <a href="https://github.com/helius-labs/photon" target="_blank">open-source Photon indexer</a>, which is maintained by Helius Labs.
</Accordion>

<Accordion title="What if the indexer is down?"> 
Hot markets work all the same as long as Solana is up. Cold accounts cannot be loaded into hot state until your indexer or RPC provider recovers.
Note that compression is cryptographically verifiable, so integrity and safety are not dependent on the indexer or any other external service beyond the onchain protocol.
</Accordion>

<Accordion title="I stream account state via LaserStream. How does this change the flow?">
If you stream account state, you can detect cold transitions in real-time via a
transaction subscription (see [Streaming Token Accounts](/light-token/toolkits/for-streaming-tokens)).
On detection, async fetch `get_account_interface` for the cold account and cache
the `ColdContext` locally. When a swap request arrives, the ColdContext is already
cached -- `create_load_instructions` runs with zero additional latency.

The `LightProgram` trait and transaction building flow are the same
regardless of whether you stream or fetch per-request.
</Accordion>

---
<Callout type="info">
API is in Beta and subject to change.

Questions or need hands-on support? [Telegram](https://t.me/swen_light) | [email](mailto:support@lightprotocol.com) | [Discord](https://discord.com/invite/7cJ8BhAXhu)
</Callout>
