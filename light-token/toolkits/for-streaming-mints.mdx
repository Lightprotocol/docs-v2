---
title: "Toolkit for Streaming Light Mint Accounts"
sidebarTitle: "For Streaming Mints"
description: "Guide to stream light-mints and metadata using Laserstream."
keywords: ["streaming mints for token issuers", "bulk token minting for protocols", "rent free token mints on solana"]
---

| Event | Description |
|:------|:------------|
| **New mints** | Raw mint data |
| **Mint updates** | Supply changes, authority changes |
| **TokenMetadata** | Name, symbol, URI, additional_metadata |

<Note>
Find devnet examples [here](https://github.com/Lightprotocol/examples-light-token/tree/main/toolkits/streaming-tokens).
</Note>

## Setup

```toml Cargo.toml
[dependencies]
helius-laserstream = "0.1.5"
tokio = { version = "1", features = ["full"] }
futures = "0.3"
anyhow = "1"
dotenvy = "0.15"
bs58 = "0.5"
borsh = "0.10"

# Light Protocol dependencies (git until published to crates.io)
light-event = { git = "https://github.com/Lightprotocol/light-protocol" }
light-compressed-account = { git = "https://github.com/Lightprotocol/light-protocol", features = ["std"] }
light-token-interface = { git = "https://github.com/Lightprotocol/light-protocol" }
```

```rust
use borsh::BorshDeserialize;
use futures::StreamExt;
use helius_laserstream::solana::storage::confirmed_block::{CompiledInstruction, Message};
use helius_laserstream::{subscribe, LaserstreamConfig};
use light_compressed_account::Pubkey;
use light_event::parse::event_from_light_transaction;
use light_token_interface::state::{ExtensionStruct, Mint};

const LIGHT_SYSTEM_PROGRAM: &str = "SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7";

// Light Token Program ID bytes (cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m)
const LIGHT_TOKEN_PROGRAM_BYTES: [u8; 32] = [
    3, 89, 128, 47, 145, 178, 244, 191, 100, 152, 66, 240, 127, 251, 205, 1,
    168, 38, 248, 106, 170, 164, 111, 0, 118, 231, 126, 151, 147, 169, 169, 4,
];

const COMPRESSED_MINT_DISCRIMINATOR: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 1];
```

<Steps>

<Step>
### Connect to Laserstream

<Tabs>
<Tab title="Mainnet">

```rust
let config = LaserstreamConfig::new(
    "https://laserstream-mainnet-ewr.helius-rpc.com".to_string(),
    std::env::var("HELIUS_API_KEY")?,
);
```

</Tab>
<Tab title="Devnet">

```rust
let config = LaserstreamConfig::new(
    "https://laserstream-devnet-ewr.helius-rpc.com".to_string(),
    std::env::var("HELIUS_API_KEY")?,
);
```

</Tab>
</Tabs>

```rust
let request = helius_laserstream::grpc::SubscribeRequest {
    transactions: [(
        "light".to_string(),
        helius_laserstream::grpc::SubscribeRequestFilterTransactions {
            vote: Some(false),
            failed: Some(false),
            account_include: vec![LIGHT_SYSTEM_PROGRAM.to_string()],
            ..Default::default()
        },
    )]
    .into(),
    ..Default::default()
};

let (stream, _handle) = subscribe(config, request);
tokio::pin!(stream);

while let Some(update) = stream.next().await {
    // Process transactions...
}
```

</Step>

<Step>
### Parse Events

```rust
fn process_transaction(message: &Message, light_token_program_id: &Pubkey) -> anyhow::Result<()> {
    let account_keys: Vec<Pubkey> = message
        .account_keys
        .iter()
        .filter_map(|k| {
            if k.len() == 32 {
                let arr: [u8; 32] = k.as_slice().try_into().ok()?;
                Some(Pubkey::from(arr))
            } else {
                None
            }
        })
        .collect();

    let (program_ids, instruction_data, accounts_per_ix) =
        extract_light_transaction(&account_keys, &message.instructions);

    if let Some(batches) =
        event_from_light_transaction(&program_ids, &instruction_data, accounts_per_ix)?
    {
        for batch in &batches {
            let event = &batch.event;
            // Process outputs...
        }
    }

    Ok(())
}
```

</Step>

<Step>
### Extract Mints

```rust
let light_token_program_id = Pubkey::from(LIGHT_TOKEN_PROGRAM_BYTES);

for output in &event.output_compressed_accounts {
    // Filter by owner (Light Token Program)
    if output.compressed_account.owner != light_token_program_id {
        continue;
    }

    // Check for mint discriminator
    let data = match &output.compressed_account.data {
        Some(d) if d.discriminator == COMPRESSED_MINT_DISCRIMINATOR => &d.data,
        _ => continue,
    };

    // Deserialize mint
    if let Ok(mint) = Mint::deserialize(&mut data.as_slice()) {
        println!("Mint: {:?}", mint.metadata.mint);
    }
}
```

</Step>

<Step>
### Extract Token Metadata from Mint Extensions

```rust
fn extract_metadata(mint: &Mint) -> Option<(String, String, String)> {
    let extensions = mint.extensions.as_ref()?;

    for ext in extensions {
        if let ExtensionStruct::TokenMetadata(m) = ext {
            let name = String::from_utf8_lossy(&m.name).to_string();
            let symbol = String::from_utf8_lossy(&m.symbol).to_string();
            let uri = String::from_utf8_lossy(&m.uri).to_string();
            return Some((name, symbol, uri));
        }
    }
    None
}
```

```rust
if let Some((name, symbol, uri)) = extract_metadata(&mint) {
    println!("  Name: {}", name);
    println!("  Symbol: {}", symbol);
    println!("  URI: {}", uri);
}
```

</Step>

</Steps>

## Data Layouts

### Mint

```rust
#[repr(C)]
pub struct Mint {
    pub base: BaseMint,
    pub metadata: MintMetadata,
    pub reserved: [u8; 16],
    pub account_type: u8,
    pub compression: CompressionInfo,
    pub extensions: Option<Vec<ExtensionStruct>>,
}

/// SPL-compatible base mint structure
#[repr(C)]
pub struct BaseMint {
    pub mint_authority: Option<Pubkey>,
    pub supply: u64,
    pub decimals: u8,
    pub is_initialized: bool,
    pub freeze_authority: Option<Pubkey>,
}

/// Light Protocol metadata for compressed mints (67 bytes)
#[repr(C)]
pub struct MintMetadata {
    pub version: u8,
    pub mint_decompressed: bool,
    pub mint: Pubkey,
    pub mint_signer: [u8; 32],
    pub bump: u8,
}
```

### TokenMetadata

```rust
#[repr(C)]
pub struct TokenMetadata {
    pub update_authority: Pubkey,  // [0u8; 32] = immutable
    pub mint: Pubkey,
    pub name: Vec<u8>,
    pub symbol: Vec<u8>,
    pub uri: Vec<u8>,
    pub additional_metadata: Vec<AdditionalMetadata>,
}

pub struct AdditionalMetadata {
    pub key: Vec<u8>,
    pub value: Vec<u8>,
}
```

# Index Tokens

<Card
  title="Toolkit to stream light-token accounts"
  icon="chevron-right"
  color="#0066ff"
  href="/light-token/toolkits/for-streaming-tokens"
  horizontal
/>
