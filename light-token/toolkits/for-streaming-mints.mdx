---
title: "Streaming Mint Accounts"
sidebarTitle: "Mint Accounts"
description: "Stream light-mint accounts and metadata via Laserstream."
keywords: ["streaming mint accounts solana", "laserstream light mint", "grpc mint streaming"]
---

import FindClosedAccounts from '/snippets/code-snippets/streaming/find-closed-accounts.mdx';

| Event | Description |
|:------|:------------|
| **New mints** | Raw mint data |
| **Mint updates** | Supply changes, authority changes |
| **TokenMetadata** | Name, symbol, URI, additional_metadata |
| **Cold/hot transitions** | Mint compressed or decompressed |

<Note>
This guide is for teams building custom data pipelines (aggregators, market makers).
If you just need account lookups, use [`get_account_interface`](/light-token/defi/routers) instead.
</Note>

## Architecture

Light mints are Solana accounts owned by the Light Token Program. The streaming
setup requires two gRPC subscriptions:

| Subscription | Detects | How |
|:-------------|:--------|:----|
| Account sub (`owner: cToken...`, `account_type == 1`) | Hot state + cold-to-hot | Pubkey cache lookup |
| Transaction sub (`account_include: cToken...`) | Hot-to-cold | Balance heuristic (`pre > 0, post == 0`) |

The account subscription delivers all state changes while mints are hot.
The transaction subscription is needed to detect mints going cold
(`CompressAndCloseMint` changes the owner to System Program, which the account
subscription no longer matches).

## Setup

```toml Cargo.toml
[dependencies]
helius-laserstream = "0.1"
tokio = { version = "1", features = ["full"] }
futures = "0.3"
bs58 = "0.5"
borsh = "0.10"
light-token-interface = "0.3.0"
```

```rust
use borsh::BorshDeserialize;
use futures::StreamExt;
use helius_laserstream::grpc::subscribe_request_filter_accounts_filter::Filter;
use helius_laserstream::grpc::subscribe_request_filter_accounts_filter_memcmp::Data;
use helius_laserstream::grpc::{
    SubscribeRequestFilterAccounts, SubscribeRequestFilterAccountsFilter,
    SubscribeRequestFilterAccountsFilterMemcmp, SubscribeRequestFilterTransactions,
};
use helius_laserstream::{subscribe, LaserstreamConfig};
use light_token_interface::state::{ExtensionStruct, Mint};

const LIGHT_TOKEN_PROGRAM_ID: &str = "cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m";
const ACCOUNT_TYPE_OFFSET: u64 = 165;
```

<Steps>

<Step>
### Connect

<Tabs>
<Tab title="Mainnet">

```rust
let config = LaserstreamConfig::new(
    "https://laserstream-mainnet-ewr.helius-rpc.com".to_string(),
    std::env::var("HELIUS_API_KEY")?,
);
```

</Tab>
<Tab title="Devnet">

```rust
let config = LaserstreamConfig::new(
    "https://laserstream-devnet-ewr.helius-rpc.com".to_string(),
    std::env::var("HELIUS_API_KEY")?,
);
```

</Tab>
</Tabs>

</Step>

<Step>
### Subscribe

```rust
let mut request = helius_laserstream::grpc::SubscribeRequest::default();

// 1. Account sub: mint state tracking + cold-to-hot detection.
//    account_type == 1 (Mint) at byte offset 165.
request.accounts.insert(
    "light_mints".to_string(),
    SubscribeRequestFilterAccounts {
        owner: vec![LIGHT_TOKEN_PROGRAM_ID.to_string()],
        filters: vec![SubscribeRequestFilterAccountsFilter {
            filter: Some(Filter::Memcmp(SubscribeRequestFilterAccountsFilterMemcmp {
                offset: ACCOUNT_TYPE_OFFSET,
                data: Some(Data::Bytes(vec![1])),
            })),
        }],
        nonempty_txn_signature: Some(true),
        ..Default::default()
    },
);

// 2. Transaction sub: hot-to-cold detection.
request.transactions.insert(
    "light_token_txns".to_string(),
    SubscribeRequestFilterTransactions {
        vote: Some(false),
        failed: Some(false),
        account_include: vec![LIGHT_TOKEN_PROGRAM_ID.to_string()],
        ..Default::default()
    },
);

let (stream, _handle) = subscribe(config, request);
tokio::pin!(stream);
```

</Step>

<Step>
### Deserialize mint accounts

```rust
use helius_laserstream::grpc::subscribe_update::UpdateOneof;

Some(UpdateOneof::Account(account_update)) => {
    if let Some(account_info) = account_update.account {
        let pubkey: [u8; 32] = account_info.pubkey.as_slice().try_into().unwrap();

        match Mint::deserialize(&mut account_info.data.as_slice()) {
            Ok(mint) => {
                cold_cache.remove(&pubkey); // no longer cold
                cache.insert(pubkey, mint);
            }
            Err(e) => {
                eprintln!(
                    "Failed to deserialize mint {}: {}",
                    bs58::encode(&pubkey).into_string(),
                    e
                );
            }
        }
    }
}
```

</Step>

<Step>
### Detect mints going cold

<FindClosedAccounts />

</Step>

<Step>
### Extract TokenMetadata

```rust
fn extract_metadata(mint: &Mint) -> Option<(String, String, String)> {
    let extensions = mint.extensions.as_ref()?;

    for ext in extensions {
        if let ExtensionStruct::TokenMetadata(m) = ext {
            let name = String::from_utf8_lossy(&m.name).to_string();
            let symbol = String::from_utf8_lossy(&m.symbol).to_string();
            let uri = String::from_utf8_lossy(&m.uri).to_string();
            return Some((name, symbol, uri));
        }
    }
    None
}
```

</Step>

</Steps>

## Data Layouts

### Mint

```rust
#[repr(C)]
pub struct Mint {
    pub base: BaseMint,
    pub metadata: MintMetadata,
    pub reserved: [u8; 16],
    pub account_type: u8,
    pub compression: CompressionInfo,
    pub extensions: Option<Vec<ExtensionStruct>>,
}

#[repr(C)]
pub struct BaseMint {
    pub mint_authority: Option<Pubkey>,
    pub supply: u64,
    pub decimals: u8,
    pub is_initialized: bool,
    pub freeze_authority: Option<Pubkey>,
}

#[repr(C)]
pub struct MintMetadata {
    pub version: u8,
    pub mint_decompressed: bool,
    pub mint: Pubkey,
    pub mint_signer: [u8; 32],
    pub bump: u8,
}
```

### TokenMetadata

```rust
#[repr(C)]
pub struct TokenMetadata {
    pub update_authority: Pubkey,  // [0u8; 32] = immutable
    pub mint: Pubkey,
    pub name: Vec<u8>,
    pub symbol: Vec<u8>,
    pub uri: Vec<u8>,
    pub additional_metadata: Vec<AdditionalMetadata>,
}

pub struct AdditionalMetadata {
    pub key: Vec<u8>,
    pub value: Vec<u8>,
}
```

<Card
  title="Streaming Token Accounts"
  icon="chevron-right"
  color="#0066ff"
  href="/light-token/toolkits/for-streaming-tokens"
  horizontal
/>
