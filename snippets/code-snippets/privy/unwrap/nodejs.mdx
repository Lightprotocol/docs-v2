```typescript
import 'dotenv/config';
import {PrivyClient} from '@privy-io/node';
import {createRpc} from '@lightprotocol/stateless.js';
import {PublicKey, Transaction} from '@solana/web3.js';
import {getAssociatedTokenAddressSync} from '@solana/spl-token';
import {
  createUnwrapInstructions,
} from '@lightprotocol/compressed-token/unified';

const unwrapTokens = async (
  fromAddress: string,
  tokenMintAddress: string,
  amount: number,
  decimals: number = 9,
) => {
  const connection = createRpc(process.env.HELIUS_RPC_URL!);

  const privy = new PrivyClient({
    appId: process.env.PRIVY_APP_ID!,
    appSecret: process.env.PRIVY_APP_SECRET!,
  });

  const fromPubkey = new PublicKey(fromAddress);
  const mintPubkey = new PublicKey(tokenMintAddress);
  const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, decimals)));

  // Auto-detect token program (SPL vs Token 2022) from mint account owner
  const mintAccountInfo = await connection.getAccountInfo(mintPubkey);
  if (!mintAccountInfo) throw new Error(`Mint account ${tokenMintAddress} not found`);
  const tokenProgramId = mintAccountInfo.owner;

  // Destination: SPL/T22 associated token account
  const splAta = getAssociatedTokenAddressSync(mintPubkey, fromPubkey, false, tokenProgramId);

  // Returns TransactionInstruction[][].
  // Each inner array is one transaction.
  // Handles loading + unwrapping together.
  const instructions = await createUnwrapInstructions(
    connection, splAta, fromPubkey, mintPubkey, tokenAmount, fromPubkey,
  );

  // Sign and send each batch via Privy
  const walletId = process.env.TREASURY_WALLET_ID!;
  const authorizationKey = process.env.TREASURY_AUTHORIZATION_KEY!;
  const signatures: string[] = [];

  for (const ixs of instructions) {
    const tx = new Transaction().add(...ixs);
    const {blockhash} = await connection.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = fromPubkey;

    const {signed_transaction} = await privy.wallets().solana().signTransaction(
      walletId, {
        transaction: tx.serialize({requireAllSignatures: false}),
        authorization_context: {authorization_private_keys: [authorizationKey]},
      },
    ) as any;

    const sig = await connection.sendRawTransaction(
      Buffer.from(signed_transaction, 'base64'),
      {skipPreflight: false, preflightCommitment: 'confirmed'},
    );
    await connection.confirmTransaction(sig, 'confirmed');
    signatures.push(sig);
  }

  return signatures[signatures.length - 1];
};

export default unwrapTokens;

```
