<CodeGroup>
```rust lib.rs
#![allow(unexpected_cfgs, deprecated)]

use anchor_lang::prelude::*;
use light_token::instruction::{
    CreateMintCpi, CreateMintParams, SystemAccountInfos, DEFAULT_RENT_PAYMENT, DEFAULT_WRITE_TOP_UP,
};
use light_token::{CompressedProof, ExtensionInstructionData, TokenMetadataInstructionData};

declare_id!("A1rJEoepgKYWZYZ8KVFpxgeeRGwBrU7xk8S39srjVkUX");

/// Token metadata parameters for creating a mint with metadata.
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TokenMetadataParams {
    pub name: Vec<u8>,
    pub symbol: Vec<u8>,
    pub uri: Vec<u8>,
    pub update_authority: Option<Pubkey>,
}

#[program]
pub mod light_token_anchor_create_mint {
    use super::*;

    pub fn create_mint(
        ctx: Context<CreateMintAccounts>,
        decimals: u8,
        address_merkle_tree_root_index: u16,
        compression_address: [u8; 32],
        proof: CompressedProof,
        freeze_authority: Option<Pubkey>,
        bump: u8,
        rent_payment: Option<u8>,
        write_top_up: Option<u32>,
        metadata: Option<TokenMetadataParams>,
    ) -> Result<()> {
        let mint = light_token::instruction::find_mint_address(ctx.accounts.mint_seed.key).0;

        let extensions = metadata.map(|m| {
            vec![ExtensionInstructionData::TokenMetadata(
                TokenMetadataInstructionData {
                    update_authority: m
                        .update_authority
                        .map(|p| p.to_bytes().into()),
                    name: m.name,
                    symbol: m.symbol,
                    uri: m.uri,
                    additional_metadata: None,
                },
            )]
        });

        let params = CreateMintParams {
            decimals,
            address_merkle_tree_root_index,
            mint_authority: *ctx.accounts.authority.key,
            proof,
            compression_address,
            mint,
            bump,
            freeze_authority,
            extensions,
            rent_payment: rent_payment.unwrap_or(DEFAULT_RENT_PAYMENT),
            write_top_up: write_top_up.unwrap_or(DEFAULT_WRITE_TOP_UP),
        };

        let system_accounts = SystemAccountInfos {
            light_system_program: ctx.accounts.light_system_program.to_account_info(),
            cpi_authority_pda: ctx.accounts.cpi_authority_pda.to_account_info(),
            registered_program_pda: ctx.accounts.registered_program_pda.to_account_info(),
            account_compression_authority: ctx.accounts.account_compression_authority.to_account_info(),
            account_compression_program: ctx.accounts.account_compression_program.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
        };

        CreateMintCpi {
            mint_seed: ctx.accounts.mint_seed.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
            payer: ctx.accounts.payer.to_account_info(),
            address_tree: ctx.accounts.address_tree.to_account_info(),
            output_queue: ctx.accounts.output_queue.to_account_info(),
            compressible_config: ctx.accounts.compressible_config.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            rent_sponsor: ctx.accounts.rent_sponsor.to_account_info(),
            system_accounts,
            cpi_context: None,
            cpi_context_account: None,
            params,
        }
        .invoke()?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMintAccounts<'info> {
    /// CHECK: Light token program for CPI
    pub light_token_program: AccountInfo<'info>,
    pub mint_seed: Signer<'info>,
    /// CHECK: Validated by light-token CPI
    pub authority: AccountInfo<'info>,
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub address_tree: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub output_queue: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub light_system_program: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub cpi_authority_pda: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub registered_program_pda: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub account_compression_authority: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub account_compression_program: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: Validated by light-token CPI - use light_token::token::config_pda()
    pub compressible_config: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI - derived from find_mint_address(mint_seed)
    #[account(mut)]
    pub mint: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI - use light_token::token::rent_sponsor_pda()
    #[account(mut)]
    pub rent_sponsor: AccountInfo<'info>,
}
```

```rust test.rs
use anchor_lang::{InstructionData, ToAccountMetas};
use light_program_test::{Indexer, LightProgramTest, ProgramTestConfig, Rpc};
use light_token_anchor_create_mint::{accounts, instruction::CreateMint, ID};
use light_token::instruction::{
    config_pda, derive_mint_compressed_address, find_mint_address, rent_sponsor_pda,
    SystemAccounts, LIGHT_TOKEN_PROGRAM_ID, DEFAULT_RENT_PAYMENT, DEFAULT_WRITE_TOP_UP,
};
use anchor_lang::system_program;
use solana_sdk::{
    instruction::Instruction,
    signature::Keypair,
    signer::Signer,
};

#[tokio::test]
async fn test_create_mint() {
    let config =
        ProgramTestConfig::new_v2(true, Some(vec![("light_token_anchor_create_mint", ID)]));
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let mint_seed = Keypair::new();
    let mint_authority = payer.pubkey();
    let decimals = 9u8;

    let address_tree = rpc.get_address_tree_v2();
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);

    let (mint_pda, bump) = find_mint_address(&mint_seed.pubkey());

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![light_client::indexer::AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    let system_accounts = SystemAccounts::default();

    // Call the anchor program to create mint
    let ix = Instruction {
        program_id: ID,
        accounts: accounts::CreateMintAccounts {
            light_token_program: LIGHT_TOKEN_PROGRAM_ID,
            mint_seed: mint_seed.pubkey(),
            authority: mint_authority,
            payer: payer.pubkey(),
            address_tree: address_tree.tree,
            output_queue,
            light_system_program: system_accounts.light_system_program,
            cpi_authority_pda: system_accounts.cpi_authority_pda,
            registered_program_pda: system_accounts.registered_program_pda,
            account_compression_authority: system_accounts.account_compression_authority,
            account_compression_program: system_accounts.account_compression_program,
            system_program: system_program::ID,
            compressible_config: config_pda(),
            mint: mint_pda,
            rent_sponsor: rent_sponsor_pda(),
        }
        .to_account_metas(Some(true)),
        data: CreateMint {
            decimals,
            address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
            compression_address: compression_address.into(),
            proof: rpc_result.proof.0.unwrap(),
            freeze_authority: None,
            bump,
            rent_payment: Some(DEFAULT_RENT_PAYMENT),
            write_top_up: Some(DEFAULT_WRITE_TOP_UP),
            metadata: None,
        }
        .data(),
    };

    let sig = rpc
        .create_and_send_transaction(&[ix], &payer.pubkey(), &[&payer, &mint_seed])
        .await
        .unwrap();

    let compressed_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value;

    assert!(compressed_account.is_some(), "Light-mint should exist");
    println!("Tx: {}", sig);
}
```
</CodeGroup>
