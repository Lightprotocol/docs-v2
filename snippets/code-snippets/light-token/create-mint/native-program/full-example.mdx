<CodeGroup>
```rust instruction.rs
use super::authority_seeds;
use borsh::BorshDeserialize;
use light_compressible::CreateAccountsProof;
use light_token::instruction::{
    CreateMintCpi, CreateMintParams, SystemAccountInfos,
};
use light_token::instruction::{
    ExtensionInstructionData, TokenMetadataInstructionData,
};
use solana_program::{
    account_info::AccountInfo, entrypoint::ProgramResult,
    program_error::ProgramError, pubkey::Pubkey,
};

#[derive(BorshDeserialize)]
struct CreateMintData {
    decimals: u8,
    mint_authority: Pubkey,
    create_accounts_proof: CreateAccountsProof,
    compression_address: [u8; 32],
    mint: Pubkey,
    bump: u8,
    freeze_authority: Option<Pubkey>,
    rent_payment: u8,
    write_top_up: u32,
    metadata_name: Option<Vec<u8>>,
    metadata_symbol: Option<Vec<u8>>,
    metadata_uri: Option<Vec<u8>>,
}

pub fn create_mint_invoke(
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    let [mint_seed, authority, payer, address_tree, output_queue, compressible_config, mint, rent_sponsor, light_system_program, cpi_authority_pda, registered_program_pda, account_compression_authority, account_compression_program, system_program, _token_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    let ix_data = CreateMintData::deserialize(&mut &data[..])
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Build token metadata extension if metadata fields are provided
    let extensions = match (
        &ix_data.metadata_name,
        &ix_data.metadata_symbol,
        &ix_data.metadata_uri,
    ) {
        (Some(name), Some(symbol), Some(uri)) => {
            Some(vec![ExtensionInstructionData::TokenMetadata(
                TokenMetadataInstructionData {
                    update_authority: Some(
                        ix_data.mint_authority.to_bytes().into(),
                    ),
                    name: name.clone(),
                    symbol: symbol.clone(),
                    uri: uri.clone(),
                    additional_metadata: None,
                },
            )])
        }
        _ => None,
    };

    // Create mint. rent_payment: ~24h rent/unit, write_top_up: ~3h rent/write
    let params = CreateMintParams {
        decimals: ix_data.decimals,
        address_merkle_tree_root_index: ix_data
            .create_accounts_proof
            .address_tree_info
            .root_index,
        mint_authority: ix_data.mint_authority,
        proof: ix_data.create_accounts_proof.proof.0.unwrap_or_default(),
        compression_address: ix_data.compression_address,
        mint: ix_data.mint,
        bump: ix_data.bump,
        freeze_authority: ix_data.freeze_authority,
        extensions,
        rent_payment: ix_data.rent_payment,
        write_top_up: ix_data.write_top_up,
    };

    let system_accounts = SystemAccountInfos {
        light_system_program: light_system_program.clone(),
        cpi_authority_pda: cpi_authority_pda.clone(),
        registered_program_pda: registered_program_pda.clone(),
        account_compression_authority: account_compression_authority.clone(),
        account_compression_program: account_compression_program.clone(),
        system_program: system_program.clone(),
    };

    CreateMintCpi::new(
        mint_seed.clone(),
        authority.clone(),
        payer.clone(),
        address_tree.clone(),
        output_queue.clone(),
        compressible_config.clone(),
        mint.clone(),
        rent_sponsor.clone(),
        system_accounts,
        params,
    )
    .invoke()
}

#[derive(BorshDeserialize)]
struct CreateMintSignedData {
    decimals: u8,
    create_accounts_proof: CreateAccountsProof,
    compression_address: [u8; 32],
    mint: Pubkey,
    bump: u8,
    freeze_authority: Option<Pubkey>,
    rent_payment: u8,
    write_top_up: u32,
    authority_bump: u8,
    metadata_name: Option<Vec<u8>>,
    metadata_symbol: Option<Vec<u8>>,
    metadata_uri: Option<Vec<u8>>,
}

pub fn create_mint_invoke_signed(
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    let [mint_seed, authority, payer, address_tree, output_queue, compressible_config, mint, rent_sponsor, light_system_program, cpi_authority_pda, registered_program_pda, account_compression_authority, account_compression_program, system_program, _token_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    let ix_data = CreateMintSignedData::deserialize(&mut &data[..])
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    let signer_seeds = authority_seeds!(ix_data.authority_bump);

    // Build token metadata extension if metadata fields are provided
    let extensions = match (
        &ix_data.metadata_name,
        &ix_data.metadata_symbol,
        &ix_data.metadata_uri,
    ) {
        (Some(name), Some(symbol), Some(uri)) => {
            Some(vec![ExtensionInstructionData::TokenMetadata(
                TokenMetadataInstructionData {
                    update_authority: Some(authority.key.to_bytes().into()),
                    name: name.clone(),
                    symbol: symbol.clone(),
                    uri: uri.clone(),
                    additional_metadata: None,
                },
            )])
        }
        _ => None,
    };

    let params = CreateMintParams {
        decimals: ix_data.decimals,
        address_merkle_tree_root_index: ix_data
            .create_accounts_proof
            .address_tree_info
            .root_index,
        mint_authority: *authority.key,
        proof: ix_data.create_accounts_proof.proof.0.unwrap_or_default(),
        compression_address: ix_data.compression_address,
        mint: ix_data.mint,
        bump: ix_data.bump,
        freeze_authority: ix_data.freeze_authority,
        extensions,
        rent_payment: ix_data.rent_payment,
        write_top_up: ix_data.write_top_up,
    };

    let system_accounts = SystemAccountInfos {
        light_system_program: light_system_program.clone(),
        cpi_authority_pda: cpi_authority_pda.clone(),
        registered_program_pda: registered_program_pda.clone(),
        account_compression_authority: account_compression_authority.clone(),
        account_compression_program: account_compression_program.clone(),
        system_program: system_program.clone(),
    };

    CreateMintCpi::new(
        mint_seed.clone(),
        authority.clone(),
        payer.clone(),
        address_tree.clone(),
        output_queue.clone(),
        compressible_config.clone(),
        mint.clone(),
        rent_sponsor.clone(),
        system_accounts,
        params,
    )
    .invoke_signed(&[signer_seeds])
}
```

```rust test.rs
mod shared;

use borsh::BorshSerialize;
use light_client::{
    indexer::{AddressWithTree, Indexer},
    rpc::Rpc,
};
use light_compressed_account::instruction_data::{
    compressed_proof::ValidityProof, data::PackedAddressTreeInfo,
};
use light_compressible::CreateAccountsProof;
use light_token::instruction::{
    config_pda, derive_mint_compressed_address, find_mint_address,
    rent_sponsor_pda, SystemAccounts, LIGHT_TOKEN_PROGRAM_ID,
};
use shared::{create_test_rpc, get_authority_pda, PROGRAM_ID};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::Keypair,
    signer::Signer,
};

#[tokio::test(flavor = "multi_thread")]
async fn create_mint_cpi() {
    let mut rpc = create_test_rpc().await;

    let payer = rpc.get_payer().insecure_clone();
    let mint_seed = Keypair::new();
    let decimals = 9u8;

    // Get address tree to store compressed address for when mint turns inactive
    // We must create a compressed address at creation to ensure the mint does not exist yet
    let address_tree = rpc.get_address_tree_v2();
    // Get state tree to store mint when inactive
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    // Derive mint addresses
    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);
    let (mint, bump) = find_mint_address(&mint_seed.pubkey());

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    // Build instruction data
    #[derive(BorshSerialize)]
    struct CreateMintDataTest {
        decimals: u8,
        mint_authority: Pubkey,
        create_accounts_proof: CreateAccountsProof,
        compression_address: [u8; 32],
        mint: Pubkey,
        bump: u8,
        freeze_authority: Option<Pubkey>,
        rent_payment: u8,
        write_top_up: u32,
        metadata_name: Option<Vec<u8>>,
        metadata_symbol: Option<Vec<u8>>,
        metadata_uri: Option<Vec<u8>>,
    }

    let create_accounts_proof = CreateAccountsProof {
        proof: ValidityProof(rpc_result.proof.0),
        address_tree_info: PackedAddressTreeInfo {
            address_merkle_tree_pubkey_index: 0,
            address_queue_pubkey_index: 0,
            root_index: rpc_result.addresses[0].root_index,
        },
        output_state_tree_index: 0,
        state_tree_index: None,
    };

    let test_data = CreateMintDataTest {
        decimals,
        mint_authority: payer.pubkey(),
        create_accounts_proof,
        compression_address,
        mint,
        bump,
        freeze_authority: None,
        rent_payment: 16,
        write_top_up: 766,
        metadata_name: Some(b"Example Token".to_vec()),
        metadata_symbol: Some(b"EXT".to_vec()),
        metadata_uri: Some(b"https://example.com/metadata.json".to_vec()),
    };

    let mut data = vec![0u8];
    data.extend(test_data.try_to_vec().unwrap());

    let system_accounts = SystemAccounts::default();

    // Build and send instruction (mint_seed must sign)
    let ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(mint_seed.pubkey(), true),
            AccountMeta::new_readonly(payer.pubkey(), true),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new(address_tree.tree, false),
            AccountMeta::new(output_queue, false),
            AccountMeta::new_readonly(config_pda(), false),
            AccountMeta::new(mint, false),
            AccountMeta::new(rent_sponsor_pda(), false),
            AccountMeta::new_readonly(
                system_accounts.light_system_program,
                false,
            ),
            AccountMeta::new_readonly(system_accounts.cpi_authority_pda, false),
            AccountMeta::new_readonly(
                system_accounts.registered_program_pda,
                false,
            ),
            AccountMeta::new_readonly(
                system_accounts.account_compression_authority,
                false,
            ),
            AccountMeta::new_readonly(
                system_accounts.account_compression_program,
                false,
            ),
            AccountMeta::new_readonly(system_accounts.system_program, false),
            AccountMeta::new_readonly(LIGHT_TOKEN_PROGRAM_ID, false),
        ],
        data,
    };

    rpc.create_and_send_transaction(
        &[ix],
        &payer.pubkey(),
        &[&payer, &mint_seed],
    )
    .await
    .unwrap();

    let mint_account = rpc.get_account(mint).await.unwrap();
    assert!(mint_account.is_some());
}

#[tokio::test(flavor = "multi_thread")]
async fn create_mint_signed_cpi() {
    let mut rpc = create_test_rpc().await;

    let payer = rpc.get_payer().insecure_clone();
    let mint_seed = Keypair::new();
    let decimals = 9u8;

    let (pda_authority, authority_bump) = get_authority_pda();

    // Get address tree to store compressed address for when mint turns inactive
    // We must create a compressed address at creation to ensure the mint does not exist yet
    let address_tree = rpc.get_address_tree_v2();
    // Get state tree to store mint when inactive
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    // Derive mint addresses
    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);
    let (mint, bump) = find_mint_address(&mint_seed.pubkey());

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    // Build instruction data
    #[derive(BorshSerialize)]
    struct CreateMintSignedDataTest {
        decimals: u8,
        create_accounts_proof: CreateAccountsProof,
        compression_address: [u8; 32],
        mint: Pubkey,
        bump: u8,
        freeze_authority: Option<Pubkey>,
        rent_payment: u8,
        write_top_up: u32,
        authority_bump: u8,
        metadata_name: Option<Vec<u8>>,
        metadata_symbol: Option<Vec<u8>>,
        metadata_uri: Option<Vec<u8>>,
    }

    let create_accounts_proof = CreateAccountsProof {
        proof: ValidityProof(rpc_result.proof.0),
        address_tree_info: PackedAddressTreeInfo {
            address_merkle_tree_pubkey_index: 0,
            address_queue_pubkey_index: 0,
            root_index: rpc_result.addresses[0].root_index,
        },
        output_state_tree_index: 0,
        state_tree_index: None,
    };

    let test_data = CreateMintSignedDataTest {
        decimals,
        create_accounts_proof,
        compression_address,
        mint,
        bump,
        freeze_authority: None,
        rent_payment: 16,
        write_top_up: 766,
        authority_bump,
        metadata_name: Some(b"Example Token".to_vec()),
        metadata_symbol: Some(b"EXT".to_vec()),
        metadata_uri: Some(b"https://example.com/metadata.json".to_vec()),
    };

    let mut data = vec![19u8];
    data.extend(test_data.try_to_vec().unwrap());

    let system_accounts = SystemAccounts::default();

    // Build and send instruction (mint_seed must sign)
    let ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(mint_seed.pubkey(), true),
            AccountMeta::new(pda_authority, false),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new(address_tree.tree, false),
            AccountMeta::new(output_queue, false),
            AccountMeta::new_readonly(config_pda(), false),
            AccountMeta::new(mint, false),
            AccountMeta::new(rent_sponsor_pda(), false),
            AccountMeta::new_readonly(
                system_accounts.light_system_program,
                false,
            ),
            AccountMeta::new_readonly(system_accounts.cpi_authority_pda, false),
            AccountMeta::new_readonly(
                system_accounts.registered_program_pda,
                false,
            ),
            AccountMeta::new_readonly(
                system_accounts.account_compression_authority,
                false,
            ),
            AccountMeta::new_readonly(
                system_accounts.account_compression_program,
                false,
            ),
            AccountMeta::new_readonly(system_accounts.system_program, false),
            AccountMeta::new_readonly(LIGHT_TOKEN_PROGRAM_ID, false),
        ],
        data,
    };

    rpc.create_and_send_transaction(
        &[ix],
        &payer.pubkey(),
        &[&payer, &mint_seed],
    )
    .await
    .unwrap();

    let mint_account = rpc.get_account(mint).await.unwrap();
    assert!(mint_account.is_some());
}
```
</CodeGroup>
