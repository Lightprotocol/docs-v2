```rust
use light_client::{
    indexer::{AddressWithTree, Indexer},
    rpc::Rpc,
};
use light_program_test::{LightProgramTest, ProgramTestConfig};
use light_token_sdk::token::{
    derive_mint_compressed_address, find_mint_address, CreateMint, CreateMintParams,
};
use light_token_interface::{
    instructions::extensions::{
        token_metadata::TokenMetadataInstructionData, ExtensionInstructionData,
    },
    state::AdditionalMetadata,
};
use solana_sdk::{signature::Keypair, signer::Signer};

#[tokio::test(flavor = "multi_thread")]
async fn create_mint() {
    let mut rpc = LightProgramTest::new(ProgramTestConfig::new_v2(false, None))
        .await
        .unwrap();

    let payer = rpc.get_payer().insecure_clone();
    let mint_seed = Keypair::new();
    let decimals = 9u8;

    // Get address tree to store compressed address for when mint turns inactive
    // We must create a compressed address at creation to ensure the mint does not exist yet
    let address_tree = rpc.get_address_tree_v2();
    // Get state tree to store mint when inactive
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    // Derive mint addresses
    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);
    let mint = find_mint_address(&mint_seed.pubkey()).0; // on-chain Mint PDA

    // Fetch validity proof to proof address does not exist yet
    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    // Build CreateMintParams with token metadata extension
    let params = CreateMintParams {
        decimals,
        address_merkle_tree_root_index: rpc_result.addresses[0].root_index, // stores mint compressed address
        mint_authority: payer.pubkey(),
        proof: rpc_result.proof.0.unwrap(),
        compression_address, // address for compression when mint turns inactive
        mint,
        bump: find_mint_address(&mint_seed.pubkey()).1,
        freeze_authority: None,
        extensions: Some(vec![ExtensionInstructionData::TokenMetadata(
            TokenMetadataInstructionData {
                update_authority: Some(payer.pubkey().to_bytes().into()),
                name: b"Example Token".to_vec(),
                symbol: b"EXT".to_vec(),
                uri: b"https://example.com/metadata.json".to_vec(),
                additional_metadata: Some(vec![AdditionalMetadata {
                    key: b"type".to_vec(),
                    value: b"example".to_vec(),
                }]),
            },
        )]),
        rent_payment: 16,   // ~24 hours rent
        write_top_up: 766,  // ~3 hours rent per write
    };

    // Build and send instruction (mint_seed must sign)
    let instruction = CreateMint::new(
        params,
        mint_seed.pubkey(),
        payer.pubkey(),
        address_tree.tree,
        output_queue,
    )
    .instruction()
    .unwrap();

    let sig = rpc
        .create_and_send_transaction(&[instruction], &payer.pubkey(), &[&payer, &mint_seed])
        .await
        .unwrap();

    println!("Mint: {}", mint);
    println!("Tx: {}", sig);

    let mint_account = rpc.get_account(mint).await.unwrap();
    assert!(mint_account.is_some(), "Solana mint account should exist");
}
```
