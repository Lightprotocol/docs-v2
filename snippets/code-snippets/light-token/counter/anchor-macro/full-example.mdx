<Tabs>
<Tab title="Program">

```rust lib.rs expandable
use anchor_lang::prelude::*;
use light_account::{
    CompressionInfo, LightAccount, LightAccounts, CreateAccountsProof,
    derive_light_cpi_signer, light_program, CpiSigner,
};

declare_id!("YourProgramId11111111111111111111111111111111");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("YourProgramId11111111111111111111111111111111");

pub const COUNTER_SEED: &[u8] = b"counter";

#[derive(Default, Debug, InitSpace, LightAccount)]
#[account]
pub struct Counter {
    pub compression_info: CompressionInfo,
    pub owner: Pubkey,
    pub count: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct CreateCounterParams {
    pub create_accounts_proof: CreateAccountsProof,
    pub count: u64,
}

#[light_program]
#[program]
pub mod counter {
    use super::*;

    pub fn create_counter<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateCounter<'info>>,
        params: CreateCounterParams,
    ) -> Result<()> {
        ctx.accounts.counter.owner = ctx.accounts.owner.key();
        ctx.accounts.counter.count = params.count;
        Ok(())
    }

    /// Standard Anchor — no Light-specific changes.
    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        ctx.accounts.counter.count = ctx.accounts.counter.count.checked_add(1).unwrap();
        Ok(())
    }

    /// Standard Anchor — no Light-specific changes.
    pub fn close_counter(_ctx: Context<CloseCounter>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts, LightAccounts)]
#[instruction(params: CreateCounterParams)]
pub struct CreateCounter<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    /// CHECK: Read-only, used for PDA derivation.
    pub owner: AccountInfo<'info>,

    /// CHECK: Validated by Light Protocol CPI.
    pub compression_config: AccountInfo<'info>,

    /// CHECK: PDA rent sponsor for compression rent reimbursement.
    #[account(mut)]
    pub pda_rent_sponsor: AccountInfo<'info>,

    #[account(
        init,
        payer = fee_payer,
        space = 8 + <Counter as anchor_lang::Space>::INIT_SPACE,
        seeds = [COUNTER_SEED, owner.key().as_ref()],
        bump,
    )]
    #[light_account(init)]
    pub counter: Account<'info, Counter>,

    pub system_program: Program<'info, System>,
}

/// Standard Anchor
#[derive(Accounts)]
pub struct Increment<'info> {
    pub owner: Signer<'info>,

    #[account(
        mut,
        seeds = [COUNTER_SEED, owner.key().as_ref()],
        bump,
        has_one = owner,
    )]
    pub counter: Account<'info, Counter>,
}

/// Standard Anchor close
#[derive(Accounts)]
pub struct CloseCounter<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    pub owner: Signer<'info>,

    #[account(
        mut,
        close = fee_payer,
        seeds = [COUNTER_SEED, owner.key().as_ref()],
        bump,
        has_one = owner,
    )]
    pub counter: Account<'info, Counter>,
}
```

</Tab>
<Tab title="Client">

```rust counter.rs expandable
//! Light-PDA lifecycle test: create → increment → close.

use anchor_lang::{InstructionData, ToAccountMetas};
use light_client::interface::{
    get_create_accounts_proof, CreateAccountsProofInput, InitializeRentFreeConfig,
};
use light_program_test::{
    program_test::{setup_mock_program_data, LightProgramTest},
    ProgramTestConfig, Rpc,
};
use light_token::instruction::RENT_SPONSOR;
use solana_instruction::Instruction;
use solana_keypair::Keypair;
use solana_pubkey::Pubkey;
use solana_signer::Signer;

const PROGRAM_ID: Pubkey = counter::ID;

/// Setup: create test RPC and initialize rent-free config for the counter program.
async fn setup() -> (LightProgramTest, Keypair, Pubkey) {
    let config = ProgramTestConfig::new_v2(true, Some(vec![("counter", PROGRAM_ID)]));
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let program_data_pda = setup_mock_program_data(&mut rpc, &payer, &PROGRAM_ID);

    // Register this program for rent-free accounts. One-time setup per program.
    let (init_config_ix, compression_config) = InitializeRentFreeConfig::new(
        &PROGRAM_ID,
        &payer.pubkey(),
        &program_data_pda,
        RENT_SPONSOR,
        payer.pubkey(),
    )
    .build();

    rpc.create_and_send_transaction(&[init_config_ix], &payer.pubkey(), &[&payer])
        .await
        .expect("initialize rent-free config");

    (rpc, payer, compression_config)
}

#[tokio::test]
async fn test_counter_lifecycle() {
    let (mut rpc, payer, compression_config) = setup().await;

    // ── Create ───────────────────────────────────────────────────────────
    let (counter_pda, _) = Pubkey::find_program_address(
        &[counter::COUNTER_SEED, payer.pubkey().as_ref()],
        &PROGRAM_ID,
    );

    let proof_result = get_create_accounts_proof(
        &rpc,
        &PROGRAM_ID,
        vec![CreateAccountsProofInput::pda(counter_pda)],
    )
    .await
    .unwrap();

    let create_accounts = counter::accounts::CreateCounter {
        fee_payer: payer.pubkey(),
        owner: payer.pubkey(),
        compression_config,
        counter: counter_pda,
        system_program: solana_sdk::system_program::ID,
    };

    let create_data = counter::instruction::CreateCounter {
        params: counter::CreateCounterParams {
            create_accounts_proof: proof_result.create_accounts_proof,
            count: 0,
        },
    };

    let create_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: [
            create_accounts.to_account_metas(None),
            proof_result.remaining_accounts,
        ]
        .concat(),
        data: create_data.data(),
    };

    rpc.create_and_send_transaction(&[create_ix], &payer.pubkey(), &[&payer])
        .await
        .expect("create_counter");

    // Verify initial state.
    let account = rpc.get_account(counter_pda).await.unwrap().unwrap();
    let ctr: counter::Counter =
        anchor_lang::AccountDeserialize::try_deserialize(&mut account.data.as_slice()).unwrap();
    assert_eq!(ctr.count, 0);
    assert_eq!(ctr.owner, payer.pubkey());

    // ── Increment (standard Anchor) ────────────────────────────
    let inc_accounts = counter::accounts::Increment {
        owner: payer.pubkey(),
        counter: counter_pda,
    };
    let inc_data = counter::instruction::Increment {};
    let inc_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: inc_accounts.to_account_metas(None),
        data: inc_data.data(),
    };

    rpc.create_and_send_transaction(&[inc_ix], &payer.pubkey(), &[&payer])
        .await
        .expect("increment");

    let account = rpc.get_account(counter_pda).await.unwrap().unwrap();
    let ctr: counter::Counter =
        anchor_lang::AccountDeserialize::try_deserialize(&mut account.data.as_slice()).unwrap();
    assert_eq!(ctr.count, 1);

    // ── Close (standard Anchor) ────────────────────────────────
    let close_accounts = counter::accounts::CloseCounter {
        fee_payer: payer.pubkey(),
        owner: payer.pubkey(),
        counter: counter_pda,
    };
    let close_data = counter::instruction::CloseCounter {};
    let close_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: close_accounts.to_account_metas(None),
        data: close_data.data(),
    };

    rpc.create_and_send_transaction(&[close_ix], &payer.pubkey(), &[&payer])
        .await
        .expect("close_counter");

    // Account should no longer exist.
    let account = rpc.get_account(counter_pda).await.unwrap();
    assert!(account.is_none(), "counter should be closed");
}
```

</Tab>
</Tabs>
