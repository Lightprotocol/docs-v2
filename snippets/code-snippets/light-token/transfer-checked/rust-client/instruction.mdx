```rust
use borsh::BorshDeserialize;
use light_client::rpc::Rpc;
use light_token::instruction::{
    get_associated_token_address, CreateAssociatedTokenAccount, TransferChecked,
};
use rust_client::{setup, SetupContext};
use solana_sdk::{signature::Keypair, signer::Signer};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup creates mint and ATA with tokens
    let SetupContext {
        mut rpc,
        payer,
        mint,
        ata,
        decimals,
        ..
    } = setup().await;

    let transfer_amount = 400_000u64;

    // Create recipient ATA
    let recipient = Keypair::new();
    let recipient_ata = get_associated_token_address(&recipient.pubkey(), &mint);

    let create_ata_ix = CreateAssociatedTokenAccount::new(payer.pubkey(), recipient.pubkey(), mint)
        .instruction()?;

    rpc.create_and_send_transaction(&[create_ata_ix], &payer.pubkey(), &[&payer])
        .await?;

    // TransferChecked validates decimals match the mint's decimals
    // Only use for Light->Light transfers.
    // Use TransferInterface for all other transfers (Light, SPL or Token-2022).
    let transfer_ix = TransferChecked {
        source: ata,
        mint,
        destination: recipient_ata,
        amount: transfer_amount,
        decimals,
        authority: payer.pubkey(),
        max_top_up: None,
        fee_payer: None,
    }
    .instruction()?;

    let sig = rpc
        .create_and_send_transaction(&[transfer_ix], &payer.pubkey(), &[&payer])
        .await?;

    let data = rpc
        .get_account(recipient_ata)
        .await?
        .ok_or("Account not found")?;
    let token = light_token_interface::state::Token::deserialize(&mut &data.data[..])?;
    println!("Balance: {} Tx: {sig}", token.amount);

    Ok(())
}
```
