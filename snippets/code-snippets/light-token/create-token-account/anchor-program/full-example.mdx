<CodeGroup>
```rust lib.rs
#![allow(unexpected_cfgs, deprecated)]

use anchor_lang::prelude::*;
use light_token::instruction::CreateTokenAccountCpi;

declare_id!("zXK1CnWj4WFfFHCArxxr4sh3Qqx2p3oui8ahqpjArgS");

#[program]
pub mod light_token_anchor_create_token_account {
    use super::*;

    pub fn create_token_account(ctx: Context<CreateTokenAccountAccounts>, owner: Pubkey) -> Result<()> {
        CreateTokenAccountCpi {
            payer: ctx.accounts.payer.to_account_info(),
            account: ctx.accounts.account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            owner,
        }
        .rent_free(
            ctx.accounts.compressible_config.to_account_info(),
            ctx.accounts.rent_sponsor.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            &ctx.accounts.light_token_program.key(),
        )
        .invoke()?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateTokenAccountAccounts<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub account: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub mint: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub compressible_config: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub rent_sponsor: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: Light token program for CPI
    pub light_token_program: AccountInfo<'info>,
}
```

```rust test.rs
use anchor_lang::InstructionData;
use light_client::indexer::AddressWithTree;
use light_program_test::{Indexer, LightProgramTest, ProgramTestConfig, Rpc};
use light_token_anchor_create_token_account::{instruction::CreateTokenAccount, ID};
use light_token::instruction::{
    CreateMint, CreateMintParams, config_pda, derive_mint_compressed_address,
    find_mint_address, rent_sponsor_pda, LIGHT_TOKEN_PROGRAM_ID,
};
use anchor_lang::system_program;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::Keypair,
    signer::Signer,
};

#[tokio::test]
async fn test_create_token_account() {
    let config = ProgramTestConfig::new_v2(
        true,
        Some(vec![("light_token_anchor_create_token_account", ID)]),
    );
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    // Create a mint first
    let mint_seed = Keypair::new();
    let mint_authority = payer.pubkey();
    let decimals = 9u8;

    let address_tree = rpc.get_address_tree_v2();
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);
    let (mint_pda, bump) = find_mint_address(&mint_seed.pubkey());

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    let params = CreateMintParams {
        decimals,
        address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
        mint_authority,
        proof: rpc_result.proof.0.unwrap(),
        compression_address,
        mint: mint_pda,
        bump,
        freeze_authority: None,
        extensions: None,
        rent_payment: 16,   // ~24 hours rent
        write_top_up: 766,  // ~3 hours rent per write
    };

    let create_mint_ix = CreateMint::new(
        params,
        mint_seed.pubkey(),
        payer.pubkey(),
        address_tree.tree,
        output_queue,
    )
    .instruction()
    .unwrap();

    rpc.create_and_send_transaction(&[create_mint_ix], &payer.pubkey(), &[&payer, &mint_seed])
        .await
        .unwrap();

    // You can use light, spl, t22 mints to create a light token account.
    // Create a token account
    let token_account = Keypair::new();
    let owner = payer.pubkey();
    let compressible_config = config_pda();
    let rent_sponsor = rent_sponsor_pda();

    let ix = Instruction {
        program_id: ID,
        accounts: vec![
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new(token_account.pubkey(), true),
            AccountMeta::new_readonly(mint_pda, false),
            AccountMeta::new_readonly(compressible_config, false),
            AccountMeta::new(rent_sponsor, false),
            AccountMeta::new_readonly(system_program::ID, false),
            AccountMeta::new_readonly(LIGHT_TOKEN_PROGRAM_ID, false),
        ],
        data: CreateTokenAccount { owner }.data(),
    };

    let sig = rpc
        .create_and_send_transaction(&[ix], &payer.pubkey(), &[&payer, &token_account])
        .await
        .unwrap();

    println!("Tx: {}", sig);
}
```
</CodeGroup>
