<CodeGroup>
```rust lib.rs
#![allow(deprecated)]

use anchor_lang::prelude::*;
use light_compressible::CreateAccountsProof;
use light_sdk::derive_light_cpi_signer;
use light_sdk_macros::{light_program, LightAccounts};
use light_sdk_types::{CpiSigner, LIGHT_TOKEN_PROGRAM_ID};
use light_token::instruction::{COMPRESSIBLE_CONFIG_V1, RENT_SPONSOR as LIGHT_TOKEN_RENT_SPONSOR};

declare_id!("CLsn9MTFv97oMTsujRoQAw1u2rSm2HnKtGuWUbbc8Jfn");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("CLsn9MTFv97oMTsujRoQAw1u2rSm2HnKtGuWUbbc8Jfn");

#[light_program]
#[program]
pub mod light_token_macro_create_associated_token_account {
    use super::*;

    #[allow(unused_variables)]
    pub fn create_associated_token_account<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateAssociatedTokenAccount<'info>>,
        params: CreateAssociatedTokenAccountParams,
    ) -> Result<()> {
        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct CreateAssociatedTokenAccountParams {
    pub create_accounts_proof: CreateAccountsProof,
    pub associated_token_account_bump: u8,
}

#[derive(Accounts, LightAccounts)]
#[instruction(params: CreateAssociatedTokenAccountParams)]
pub struct CreateAssociatedTokenAccount<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    /// CHECK: Token mint for the associated token account
    pub associated_token_account_mint: AccountInfo<'info>,

    /// CHECK: Owner of the associated token account
    pub associated_token_account_owner: AccountInfo<'info>,

    /// CHECK: Validated by light_account macro
    #[account(mut)]
    #[light_account(init, associated_token::authority = associated_token_account_owner, associated_token::mint = associated_token_account_mint, associated_token::bump = params.associated_token_account_bump)]
    pub associated_token_account: UncheckedAccount<'info>,

    /// CHECK: Validated by address constraint
    #[account(address = COMPRESSIBLE_CONFIG_V1)]
    pub light_token_compressible_config: AccountInfo<'info>,

    /// CHECK: Validated by address constraint
    #[account(mut, address = LIGHT_TOKEN_RENT_SPONSOR)]
    pub light_token_rent_sponsor: AccountInfo<'info>,

    /// CHECK: Light Token program for CPI
    #[account(address = LIGHT_TOKEN_PROGRAM_ID.into())]
    pub light_token_program: AccountInfo<'info>,

    pub system_program: Program<'info, System>,
}
```

```rust test.rs
use anchor_lang::{InstructionData, ToAccountMetas};
use light_client::interface::{get_create_accounts_proof, InitializeRentFreeConfig};
use light_program_test::{
    program_test::{setup_mock_program_data, LightProgramTest},
    ProgramTestConfig, Rpc,
};
use light_sdk_types::LIGHT_TOKEN_PROGRAM_ID;
use light_token::instruction::{COMPRESSIBLE_CONFIG_V1, RENT_SPONSOR};
use solana_instruction::Instruction;
use solana_signer::Signer;
use test_utils::create_mint;

/// Test creating a Light Protocol associated token account using the macro.
#[tokio::test]
async fn test_create_associated_token_account() {
    use light_token_macro_create_associated_token_account::CreateAssociatedTokenAccountParams;

    let program_id = light_token_macro_create_associated_token_account::ID;
    let mut config =
        ProgramTestConfig::new_v2(true, Some(vec![("light_token_macro_create_associated_token_account", program_id)]));
    config = config.with_light_protocol_events();

    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let program_data_pda = setup_mock_program_data(&mut rpc, &payer, &program_id);

    let (init_config_ix, _config_pda) = InitializeRentFreeConfig::new(
        &program_id,
        &payer.pubkey(),
        &program_data_pda,
        RENT_SPONSOR,
        payer.pubkey(),
    )
    .build();

    rpc.create_and_send_transaction(&[init_config_ix], &payer.pubkey(), &[&payer])
        .await
        .expect("Initialize config should succeed");

    let (mint, _mint_seed) = create_mint(&mut rpc, &payer, None).await;

    // The associated token account owner will be the payer
    let associated_token_account_owner = payer.pubkey();

    // Derive the associated token account address using Light Token SDK's derivation
    let (associated_token_account, associated_token_account_bump) = light_token::instruction::derive_token_ata(&associated_token_account_owner, &mint);

    // Get proof (no PDA accounts for associated token account-only instruction)
    let proof_result = get_create_accounts_proof(&rpc, &program_id, vec![])
        .await
        .unwrap();

    // Build instruction
    let accounts = light_token_macro_create_associated_token_account::accounts::CreateAssociatedTokenAccount {
        fee_payer: payer.pubkey(),
        associated_token_account_mint: mint,
        associated_token_account_owner,
        associated_token_account,
        light_token_compressible_config: COMPRESSIBLE_CONFIG_V1,
        light_token_rent_sponsor: RENT_SPONSOR,
        light_token_program: LIGHT_TOKEN_PROGRAM_ID.into(),
        system_program: solana_sdk::system_program::ID,
    };

    let instruction_data = light_token_macro_create_associated_token_account::instruction::CreateAssociatedTokenAccount {
        params: CreateAssociatedTokenAccountParams {
            create_accounts_proof: proof_result.create_accounts_proof,
            associated_token_account_bump,
        },
    };

    let instruction = Instruction {
        program_id,
        accounts: [
            accounts.to_account_metas(None),
            proof_result.remaining_accounts,
        ]
        .concat(),
        data: instruction_data.data(),
    };

    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[&payer])
        .await
        .expect("CreateAssociatedTokenAccount instruction should succeed");

    // Verify associated token account exists on-chain
    let associated_token_account_data = rpc
        .get_account(associated_token_account)
        .await
        .unwrap()
        .expect("Associated token account should exist on-chain");

    // Parse and verify token data
    use light_token_interface::state::Token;
    let token: Token = borsh::BorshDeserialize::deserialize(&mut &associated_token_account_data.data[..])
        .expect("Failed to deserialize Token");

    // Verify owner
    assert_eq!(token.owner, associated_token_account_owner.to_bytes(), "Associated token account owner should match");

    // Verify mint
    assert_eq!(token.mint, mint.to_bytes(), "Associated token account mint should match");

    // Verify initial amount is 0
    assert_eq!(token.amount, 0, "Associated token account amount should be 0 initially");
}
```
</CodeGroup>
