<CodeGroup>
```rust lib.rs
#![allow(unexpected_cfgs, deprecated)]

use anchor_lang::prelude::*;
use light_token::instruction::CreateAssociatedAccountCpi;

declare_id!("35MukgdfpNUbPMhTmEk63ECV8vjgpNVFRH9nP8ovMN58");

#[program]
pub mod light_token_anchor_create_ata {
    use super::*;

    pub fn create_ata(ctx: Context<CreateAtaAccounts>, bump: u8, idempotent: bool) -> Result<()> {
        let cpi = CreateAssociatedAccountCpi {
            payer: ctx.accounts.payer.to_account_info(),
            owner: ctx.accounts.owner.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            ata: ctx.accounts.associated_token_account.to_account_info(),
            bump,
        };

        if idempotent {
            cpi.idempotent().rent_free(
                ctx.accounts.compressible_config.to_account_info(),
                ctx.accounts.rent_sponsor.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            )
        } else {
            cpi.rent_free(
                ctx.accounts.compressible_config.to_account_info(),
                ctx.accounts.rent_sponsor.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            )
        }
        .invoke()?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateAtaAccounts<'info> {
    /// CHECK: Light token program for CPI
    pub light_token_program: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub owner: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    pub mint: AccountInfo<'info>,
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub associated_token_account: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: Validated by light-token CPI
    pub compressible_config: AccountInfo<'info>,
    /// CHECK: Validated by light-token CPI
    #[account(mut)]
    pub rent_sponsor: AccountInfo<'info>,
}
```

```rust test.rs
use anchor_lang::{InstructionData, ToAccountMetas};
use light_client::indexer::AddressWithTree;
use light_program_test::{Indexer, LightProgramTest, ProgramTestConfig, Rpc};
use light_token_anchor_create_ata::{accounts, instruction::CreateAta, ID};
use light_token::instruction::{
    CreateMint, CreateMintParams, config_pda, derive_mint_compressed_address, derive_token_ata,
    find_mint_address, rent_sponsor_pda, LIGHT_TOKEN_PROGRAM_ID,
};
use anchor_lang::system_program;
use solana_sdk::{
    instruction::Instruction,
    signature::Keypair,
    signer::Signer,
};

#[tokio::test]
async fn test_create_ata() {
    let config =
        ProgramTestConfig::new_v2(true, Some(vec![("light_token_anchor_create_ata", ID)]));
    let mut rpc = LightProgramTest::new(config).await.unwrap();
    let payer = rpc.get_payer().insecure_clone();

    let mint_seed = Keypair::new();
    let mint_authority = payer.pubkey();
    let decimals = 9u8;

    let address_tree = rpc.get_address_tree_v2();
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    let compression_address =
        derive_mint_compressed_address(&mint_seed.pubkey(), &address_tree.tree);
    let (mint_pda, bump) = find_mint_address(&mint_seed.pubkey());

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    let params = CreateMintParams {
        decimals,
        address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
        mint_authority,
        proof: rpc_result.proof.0.unwrap(),
        compression_address,
        mint: mint_pda,
        bump,
        freeze_authority: None,
        extensions: None,
        rent_payment: 16,   // ~24 hours rent
        write_top_up: 766,  // ~3 hours rent per write
    };

    let create_mint_ix = CreateMint::new(
        params,
        mint_seed.pubkey(),
        payer.pubkey(),
        address_tree.tree,
        output_queue,
    )
    .instruction()
    .unwrap();

    rpc.create_and_send_transaction(&[create_mint_ix], &payer.pubkey(), &[&payer, &mint_seed])
        .await
        .unwrap();

    // You can use light, spl, t22 mints to create a light token ATA.
    // Derive ATA address and bump
    let (ata, ata_bump) = derive_token_ata(&payer.pubkey(), &mint_pda);

    // Call the anchor program to create ATA
    let compressible_config = config_pda();
    let rent_sponsor = rent_sponsor_pda();

    let ix = Instruction {
        program_id: ID,
        accounts: accounts::CreateAtaAccounts {
            light_token_program: LIGHT_TOKEN_PROGRAM_ID,
            owner: payer.pubkey(),
            mint: mint_pda,
            payer: payer.pubkey(),
            associated_token_account: ata,
            system_program: system_program::ID,
            compressible_config,
            rent_sponsor,
        }
        .to_account_metas(Some(true)),
        data: CreateAta {
            bump: ata_bump,
            idempotent: false,
        }
        .data(),
    };

    let sig = rpc.create_and_send_transaction(&[ix], &payer.pubkey(), &[&payer])
        .await
        .unwrap();

    println!("Tx: {}", sig);
}
```
</CodeGroup>
