<CodeGroup>
```rust instruction.rs
use super::authority_seeds;
use light_token::instruction::CreateAssociatedAccountCpi;
use solana_program::{
    account_info::AccountInfo, entrypoint::ProgramResult,
    program_error::ProgramError,
};

pub fn create_ata_invoke(
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    let [owner, mint, payer, associated_token_account, system_program, compressible_config, rent_sponsor, _token_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if data.is_empty() {
        return Err(ProgramError::InvalidInstructionData);
    }

    let bump = data[0];
    let idempotent = data.get(1).copied().unwrap_or(0) != 0;

    // Create associated token account. Works with light, spl, t22 mints
    let cpi = CreateAssociatedAccountCpi {
        payer: payer.clone(),
        owner: owner.clone(),
        mint: mint.clone(),
        ata: associated_token_account.clone(),
        bump,
    };

    if idempotent {
        cpi.idempotent().rent_free(
            compressible_config.clone(),
            rent_sponsor.clone(),
            system_program.clone(),
        )
    } else {
        cpi.rent_free(
            compressible_config.clone(),
            rent_sponsor.clone(),
            system_program.clone(),
        )
    }
    .invoke()
}

pub fn create_ata_invoke_signed(
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    let [owner, mint, payer, associated_token_account, system_program, compressible_config, rent_sponsor, _token_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if data.len() < 3 {
        return Err(ProgramError::InvalidInstructionData);
    }

    let bump = data[0];
    let idempotent = data[1] != 0;
    let authority_bump = data[2];
    let signer_seeds = authority_seeds!(authority_bump);

    let cpi = CreateAssociatedAccountCpi {
        payer: payer.clone(),
        owner: owner.clone(),
        mint: mint.clone(),
        ata: associated_token_account.clone(),
        bump,
    };

    if idempotent {
        cpi.idempotent().rent_free(
            compressible_config.clone(),
            rent_sponsor.clone(),
            system_program.clone(),
        )
    } else {
        cpi.rent_free(
            compressible_config.clone(),
            rent_sponsor.clone(),
            system_program.clone(),
        )
    }
    .invoke_signed(&[signer_seeds])
}
```

```rust test.rs
mod shared;

use light_client::rpc::Rpc;
use light_token::instruction::derive_token_ata;
use shared::{
    build_create_ata_cpi_ix, build_create_ata_signed_cpi_ix, create_test_rpc,
    get_authority_pda, setup_mint_with_tokens,
};
use solana_sdk::signer::Signer;

#[tokio::test(flavor = "multi_thread")]
async fn create_ata_cpi() {
    // Works with light, spl, or t22 mints
    let mut rpc = create_test_rpc().await;
    let payer = rpc.get_payer().insecure_clone();

    let (mint, _) = setup_mint_with_tokens(
        &mut rpc,
        &payer,
        payer.pubkey(),
        None,
        9,
        vec![],
    )
    .await;

    let owner = payer.pubkey();
    let (ata, bump) = derive_token_ata(&owner, &mint);

    let ix = build_create_ata_cpi_ix(owner, mint, payer.pubkey(), ata, bump);

    rpc.create_and_send_transaction(&[ix], &payer.pubkey(), &[&payer])
        .await
        .unwrap();

    let account = rpc.get_account(ata).await.unwrap();
    assert!(account.is_some());
}

#[tokio::test(flavor = "multi_thread")]
async fn create_ata_signed_cpi() {
    let mut rpc = create_test_rpc().await;
    let payer = rpc.get_payer().insecure_clone();

    let (pda_owner, authority_bump) = get_authority_pda();

    let (mint, _) = setup_mint_with_tokens(
        &mut rpc,
        &payer,
        payer.pubkey(),
        None,
        9,
        vec![],
    )
    .await;

    let (ata, ata_bump) = derive_token_ata(&pda_owner, &mint);

    let ix = build_create_ata_signed_cpi_ix(
        pda_owner,
        mint,
        payer.pubkey(),
        ata,
        ata_bump,
        authority_bump,
    );

    rpc.create_and_send_transaction(&[ix], &payer.pubkey(), &[&payer])
        .await
        .unwrap();

    let account = rpc.get_account(ata).await.unwrap();
    assert!(account.is_some());
}
```
</CodeGroup>
