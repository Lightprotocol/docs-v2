---
title: Create cToken Accounts
description: Program guide to create cToken accounts with step-by-step implementation and full code examples.
---

import CTokenCreateAccountsList from '/snippets/ctoken-create-accounts-list.mdx';
import CTokenProtocolPDAs from '/snippets/ctoken-protocol-pdas.mdx';
import CompressibleVsSolanaRent from '/snippets/compressible-vs-solana-rent.mdx';
import { CompressibleRentCalculator } from '/snippets/compressible-rent-calculator.jsx';
import CTokenConfigureRent from '/snippets/ctoken-configure-rent.mdx';

## Key Points

cToken accounts are Solana accounts and created via CPI to the cToken Program.

1. cToken accounts hold token balances similar to SPL Token accounts.
2. cToken accounts are compressible, which means
    * The rent-exemption to create the Solana account is sponsored by Light Protocol.
    * At creation, the account creator pays <Tooltip tip="1 epoch â‰ˆ 13,500 slots at 400ms per slot">24h / ~16 epochs</Tooltip> worth of <Tooltip tip="Rent for 260-byte cToken account per epoch: 360 bytes. Learn more in the [core concepts to compressible rent](/compressed-token-program/c-token-program#compressible-extension).">rent by default (~11,000 lamports)</Tooltip>.
    * The account gets compressed when the lamports balance does not cover rent for the current epoch (388 lamports) and the protocol reclaims the rent.
    * When a compressed cToken account is written to, the account gets decompressed with the same state.
3. To continously fund the account with rent, the transaction payer tops-up the lamports balance, when the account's lamports balance falls below two epochs of rent (766 lamports).
    * The top-up is configured to 766 lamports by default to cover rent for another ~3h / 2 epochs.
4. The account creation and writes to decompress cost additional <Tooltip tip="Covers transaction cost to compress accounts (10,000) and protocol incentive (1,000). Transaction cost might vary.">11,000 lamports for compression & protocol incentive</Tooltip>.

<Info>
Learn the [core concepts to the cToken Program here](/compressed-token-program/c-token-program).
</Info>

<Note>
Find [full code examples at the end](#full-code-example).
</Note>

# Implementation Guide

<Steps>
<Step>

### Rent Config Accounts

<CTokenConfigureRent />

</Step>
<Step>

### Build Account Infos and CPI the cToken Program

1. Pass the required accounts
2. Include rent config from `compressible_params`
3. Use `invoke` or `invoke_signed`:
    * When a CPI doesn't require PDA signers, the `invoke` function is used. 
    * When a CPI requires a PDA signer, the `invoke_signed` function is used. It takes the signer seeds used for deriving signer PDAs.

<Tabs>
<Tab title="invoke (External signer)">

```rust
use light_compressed_token_sdk::ctoken::CreateCTokenAccountInfos;

CreateCTokenAccountInfos {
    payer: payer.clone(),
    account: account.clone(),
    mint: mint.clone(),
    owner: data.owner,
    compressible: Some(compressible_params),
}
.invoke()?;
```
<CTokenCreateAccountsList />

</Tab>
<Tab title="invoke_signed (PDA is signer)">

```rust
use light_compressed_token_sdk::ctoken::CreateCTokenAccountInfos;

let account_infos = CreateCTokenAccountInfos {
    payer: payer.clone(),
    account: account.clone(),
    mint: mint.clone(),
    owner: data.owner,
    compressible: Some(compressible_params),
};

let signer_seeds: &[&[u8]] = &[TOKEN_ACCOUNT_SEED, &[bump]];
account_infos.invoke_signed(&[signer_seeds])?;
```

</Tab>
</Tabs>

</Step>
</Steps>

# Full Code Example

<Info>
Find the source code [here](https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-ctoken-test/src/create_token_account.rs).
</Info>

```rust expandable
use borsh::{BorshDeserialize, BorshSerialize};
use light_compressed_token_sdk::ctoken::{CompressibleParamsInfos, CreateCTokenAccountInfos};
use solana_program::{account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey};

use crate::{ID, TOKEN_ACCOUNT_SEED};

/// Instruction data for create token account
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CreateTokenAccountData {
    pub owner: Pubkey,
    pub pre_pay_num_epochs: u8,
    pub lamports_per_write: u32,
}

/// Handler for creating a compressible token account (invoke)
///
/// Uses the builder pattern from the ctoken module. This demonstrates how to:
/// 1. Build the account infos struct with compressible params
/// 2. Call the invoke() method which handles instruction building and CPI
///
/// Account order:
/// - accounts[0]: payer (signer)
/// - accounts[1]: account to create (signer)
/// - accounts[2]: mint
/// - accounts[3]: compressible_config
/// - accounts[4]: system_program
/// - accounts[5]: rent_sponsor
pub fn process_create_token_account_invoke(
    accounts: &[AccountInfo],
    data: CreateTokenAccountData,
) -> Result<(), ProgramError> {
    if accounts.len() < 6 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Build the compressible params using constructor
    let compressible_params = CompressibleParamsInfos::new(
        data.pre_pay_num_epochs,
        data.lamports_per_write,
        accounts[3].clone(),
        accounts[5].clone(),
        accounts[4].clone(),
    );

    // Build the account infos struct
    CreateCTokenAccountInfos {
        payer: accounts[0].clone(),
        account: accounts[1].clone(),
        mint: accounts[2].clone(),
        owner: data.owner,
        compressible: Some(compressible_params),
    }
    .invoke()?;

    Ok(())
}

/// Handler for creating a compressible token account with PDA ownership (invoke_signed)
///
/// Account order:
/// - accounts[0]: payer (signer)
/// - accounts[1]: account to create (PDA, will be derived and verified)
/// - accounts[2]: mint
/// - accounts[3]: compressible_config
/// - accounts[4]: system_program
/// - accounts[5]: rent_sponsor
pub fn process_create_token_account_invoke_signed(
    accounts: &[AccountInfo],
    data: CreateTokenAccountData,
) -> Result<(), ProgramError> {
    if accounts.len() < 6 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    // Derive the PDA for the token account
    let (pda, bump) = Pubkey::find_program_address(&[TOKEN_ACCOUNT_SEED], &ID);

    // Verify the account to create is the PDA
    if &pda != accounts[1].key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Build the compressible params using constructor
    let compressible_params = CompressibleParamsInfos::new(
        data.pre_pay_num_epochs,
        data.lamports_per_write,
        accounts[3].clone(),
        accounts[5].clone(),
        accounts[4].clone(),
    );

    // Build the account infos struct
    let account_infos = CreateCTokenAccountInfos {
        payer: accounts[0].clone(),
        account: accounts[1].clone(),
        mint: accounts[2].clone(),
        owner: data.owner,
        compressible: Some(compressible_params),
    };

    // Invoke with PDA signing
    let signer_seeds: &[&[u8]] = &[TOKEN_ACCOUNT_SEED, &[bump]];
    account_infos.invoke_signed(&[signer_seeds])?;

    Ok(())
}
```

# Next Steps

Learn how to mint cTokens to cToken accounts.

<CardGroup>
<Card
  title="Client Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/client-guide"
  horizontal
/>
<Card
  title="Program Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/program-mint-to-cToken"
  horizontal
/>
</CardGroup>
