---
title: Mint c-Tokens
description: Program guide to mint c-Tokens to a c-Mint via CPI to the Compressed Token Program with step-by-step implementation and full code examples.
---

import CMintSystemAccountsList from '/snippets/accounts-list/cmint-system-accounts-list.mdx';
import CMintToCTokenAccountsList from '/snippets/accounts-list/cmint-to-ctoken-accounts-list.mdx';
import CTokenClientPrerequisites from '/snippets/ctoken-guides/ctoken-client-prerequisites.mdx';
import ClientCustomRentConfig from '/snippets/ctoken-guides/client-custom-rent-config.mdx';


1. c-Tokens increase the supply of a c-Mint.
2. The destination c-Token accounts must exist to receive the minted c-Tokens.
3. Only the mint authority can mint new c-Tokens.

# Get Started

<Tabs>
<Tab title="Rust Client">

The example mints c-Tokens to existing c-Token accounts.
1. Prerequisite: The example creates a test c-Mint and destination c-Token account.
2. Get c-Mint account infos and prove it exists <Tooltip tip="c-Mints are compressed accounts. Compressed accounts are stored in state Merkle trees. Only the root hash is stored on chain - every transaction that accesses the c-Mint includes a validity proof to verify the compressed state.">with a validity proof</Tooltip>..
3. Set the amount of tokens you will mint and the mint authority. Only the mint authority can mint new c-Tokens.
4. Build the instruction with `MintToCToken::new()` and send the transaction.
```rust
use light_ctoken_sdk::ctoken::MintToCToken;

let instruction = MintToCToken::new(
    params,
    payer.pubkey(),
    state_tree,
    output_queue,
    input_queue,
    vec![recipient_account.pubkey()],
)
.instruction()?;
```

<Steps>
<Step>
### Prerequisites

<CTokenClientPrerequisites />

</Step>

<Step>
### Mint c-Tokens

```rust
use borsh::BorshDeserialize;
use light_client::indexer::{AddressWithTree, Indexer};
use light_client::rpc::Rpc;
use light_ctoken_sdk::ctoken::{
    CompressibleParams, CreateCMint, CreateCMintParams, CreateCTokenAccount, MintToCToken,
    MintToCTokenParams,
};
use light_ctoken_interface::instructions::mint_action::CompressedMintWithContext;
use light_ctoken_interface::state::{CToken, CompressedMint};
use light_program_test::{LightProgramTest, ProgramTestConfig};
use solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer};


#[tokio::test(flavor = "multi_thread")]
async fn test_mint_to_ctoken_client() {
    // Step 1: Setup test environment
    let mut rpc = LightProgramTest::new(ProgramTestConfig::new_v2(false, None))
        .await
        .unwrap();

    let payer = rpc.get_payer().insecure_clone();
    let mint_authority = payer.pubkey();

    // Step 2: Create compressed mint (prerequisite)
    let (mint, compression_address) = create_compressed_mint(&mut rpc, &payer, 9).await;

    // Step 3: Create ctoken account (prerequisite)
    let ctoken_account = Keypair::new();
    let owner = payer.pubkey();
    let create_account_ix = CreateCTokenAccount::new(
        payer.pubkey(),
        ctoken_account.pubkey(),
        mint,
        owner,
        CompressibleParams::default(),
    )
    .instruction()
    .unwrap();

    rpc.create_and_send_transaction(
        &[create_account_ix],
        &payer.pubkey(),
        &[&payer, &ctoken_account],
    )
    .await
    .unwrap();

    // Step 4: Get compressed mint account to build CompressedMintWithContext
    let compressed_mint_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value
        .expect("Compressed mint should exist");

    // Step 5: Get validity proof for the mint operation
    let rpc_result = rpc
        .get_validity_proof(vec![compressed_mint_account.hash], vec![], None)
        .await
        .unwrap()
        .value;

    // Step 6: Deserialize compressed mint data
    let compressed_mint = CompressedMint::deserialize(
        &mut compressed_mint_account.data.unwrap().data.as_slice(),
    )
    .unwrap();

    // Step 7: Build CompressedMintWithContext
    let compressed_mint_with_context = CompressedMintWithContext {
        address: compression_address,
        leaf_index: compressed_mint_account.leaf_index,
        prove_by_index: true,
        root_index: rpc_result.accounts[0]
            .root_index
            .root_index()
            .unwrap_or_default(),
        mint: compressed_mint.try_into().unwrap(),
    };

    let amount = 1_000_000_000u64; // 1 token with 9 decimals

    // Step 8: Build mint params
    let params = MintToCTokenParams::new(
        compressed_mint_with_context,
        amount,
        mint_authority,
        rpc_result.proof,
    );

    // Step 9: Build instruction using SDK builder
    let instruction = MintToCToken::new(
        params,
        payer.pubkey(),
        compressed_mint_account.tree_info.tree,
        compressed_mint_account.tree_info.queue,
        compressed_mint_account.tree_info.queue,
        vec![ctoken_account.pubkey()],
    )
    .instruction()
    .unwrap();

    // Step 10: Send transaction
    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[&payer])
        .await
        .unwrap();

    // Step 11: Verify tokens were minted
    let ctoken_account_data = rpc
        .get_account(ctoken_account.pubkey())
        .await
        .unwrap()
        .unwrap();

    let ctoken_state = CToken::deserialize(&mut &ctoken_account_data.data[..]).unwrap();
    assert_eq!(ctoken_state.amount, amount, "Token amount should match");
    assert_eq!(ctoken_state.mint, mint.to_bytes(), "Mint should match");
    assert_eq!(ctoken_state.owner, owner.to_bytes(), "Owner should match");
}
pub async fn create_compressed_mint<R: Rpc + Indexer>(
    rpc: &mut R,
    payer: &Keypair,
    decimals: u8,
) -> (Pubkey, [u8; 32]) {
    let mint_signer = Keypair::new();
    let address_tree = rpc.get_address_tree_v2();
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    // Derive compression address
    let compression_address = light_ctoken_sdk::ctoken::derive_compressed_mint_address(
        &mint_signer.pubkey(),
        &address_tree.tree,
    );

    let mint_pda =
        light_ctoken_sdk::ctoken::find_spl_mint_address(&mint_signer.pubkey()).0;

    // Get validity proof for the address to proof it does not exist in the address tree
    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    // Build params
    let params = CreateCMintParams {
        decimals,
        address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
        mint_authority: payer.pubkey(),
        proof: rpc_result.proof.0.unwrap(),
        compression_address,
        mint: mint_pda,
        freeze_authority: None,
        extensions: None,
    };

    // Create instruction
    let create_cmint = CreateCMint::new(
        params,
        mint_signer.pubkey(),
        payer.pubkey(),
        address_tree.tree,
        output_queue,
    );
    let instruction = create_cmint.instruction().unwrap();

    // Send transaction
    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[payer, &mint_signer])
        .await
        .unwrap();

    (mint_pda, compression_address)
}
```
</Step>
</Steps>
</Tab>

<Tab title="Program Guide">

<Note>
Find [a full code example at the end](#full-code-example).
</Note>

<Steps>
<Step>

### Configure Mint Parameters
Include your mint, the amount of tokens to be minted and the pubkey of the mint authority. 
The client passes a validity proof that <Tooltip tip="c-Mints are compressed accounts. Compressed accounts are stored in state Merkle trees. Only the root hash is stored on chain - every transaction that accesses the c-Mint includes a validity proof to verify the compressed state.">proves the c-Mint exists</Tooltip>.

```rust
use light_ctoken_sdk::ctoken::MintToCTokenParams;

let mint_params = MintToCTokenParams::new(
    data.compressed_mint_inputs,
    data.amount,
    data.mint_authority,
    data.proof,
);
```


</Step>

<Step>

### System Accounts

Compressed accounts like c-Mints require system accounts like the Light System Program account for interactions and proof verification. 
The client includes them in the instruction.

<Accordion title="System Accounts List">
<CMintSystemAccountsList />
</Accordion>

```rust
use light_ctoken_sdk::ctoken::SystemAccountInfos;

let system_accounts = SystemAccountInfos {
    light_system_program: light_system_program.clone(),
    cpi_authority_pda: cpi_authority_pda.clone(),
    registered_program_pda: registered_program_pda.clone(),
    account_compression_authority: account_compression_authority.clone(),
    account_compression_program: account_compression_program.clone(),
    system_program: system_program.clone(),
};
```

</Step>

<Step>

### Build Account Infos and CPI the c-Token Program

1. Pass the required accounts, including the destination c-Token accounts.
2. Include `mint_params` and `system_accounts` from the previous steps
3. Use `invoke` or `invoke_signed`, when a CPI requires a PDA signer.
<Tabs>
<Tab title="invoke (External Signer)">

```rust
use light_ctoken_sdk::ctoken::MintToCTokenInfos;

MintToCTokenInfos {
    authority: authority.clone(),
    payer: payer.clone(),
    state_tree: state_tree.clone(),
    input_queue: input_queue.clone(),
    output_queue: output_queue.clone(),
    ctoken_accounts,
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    mint_params,
}
.invoke()?;
```

</Tab>
<Tab title="invoke_signed (PDA Authority)">

```rust
use light_ctoken_sdk::ctoken::MintToCTokenInfos;

let account_infos = MintToCTokenInfos {
    authority: authority.clone(),
    payer: payer.clone(),
    state_tree: state_tree.clone(),
    input_queue: input_queue.clone(),
    output_queue: output_queue.clone(),
    ctoken_accounts,
    system_accounts,
    cpi_context: None,
    cpi_context_account: None,
    mint_params,
};

let signer_seeds: &[&[u8]] = &[MINT_AUTHORITY_SEED, &[bump]];
account_infos.invoke_signed(&[signer_seeds])?;
```

</Tab>
</Tabs>

<Accordion title="Accounts List">
<CMintToCTokenAccountsList />
</Accordion>

</Step>
</Steps>

# Full Code Example

<Info>
Find the source code [here](https://github.com/Lightprotocol/light-protocol/blob/main/sdk-tests/sdk-ctoken-test/src/mint_to_ctoken.rs).
</Info>

```rust expandable
// Tests for MintToCTokenInfos (MintToCtoken instruction)

mod shared;

use borsh::{BorshDeserialize, BorshSerialize};
use light_client::{indexer::Indexer, rpc::Rpc};
use light_ctoken_sdk::{
    compressed_token::mint_action::MintActionMetaConfig, ctoken::CTOKEN_PROGRAM_ID,
};
use light_program_test::{LightProgramTest, ProgramTestConfig};
use native_ctoken_examples::{
    CreateCmintData, CreateTokenAccountData, MintToCTokenData, ID, MINT_AUTHORITY_SEED,
    MINT_SIGNER_SEED,
};
use shared::setup_create_compressed_mint;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::Keypair,
    signer::Signer,
};

/// Test minting tokens to a ctoken account using MintToCTokenInfos::invoke()
#[tokio::test]
async fn test_mint_to_ctoken() {
    let mut rpc = LightProgramTest::new(ProgramTestConfig::new_v2(
        false,
        Some(vec![("native_ctoken_examples", ID)]),
    ))
    .await
    .unwrap();

    let payer = rpc.get_payer().insecure_clone();
    let mint_authority = payer.pubkey();

    // Setup: Create compressed mint directly (not via wrapper program)
    let (mint_pda, compression_address, _) =
        setup_create_compressed_mint(&mut rpc, &payer, mint_authority, 9, vec![]).await;

    let ctoken_account = Keypair::new();
    let owner = payer.pubkey();
    // Create a ctoken account to mint tokens to via wrapper program
    {
        let create_token_account_data = CreateTokenAccountData {
            owner,
            pre_pay_num_epochs: 2,
            lamports_per_write: 1,
        };
        let instruction_data =
            [vec![2u8], create_token_account_data.try_to_vec().unwrap()].concat();

        use light_ctoken_sdk::ctoken::{config_pda, rent_sponsor_pda};
        let config = config_pda();
        let rent_sponsor = rent_sponsor_pda();

        let instruction = Instruction {
            program_id: ID,
            accounts: vec![
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new(ctoken_account.pubkey(), true),
                AccountMeta::new_readonly(mint_pda, false),
                AccountMeta::new_readonly(config, false),
                AccountMeta::new_readonly(Pubkey::default(), false), // system_program
                AccountMeta::new(rent_sponsor, false),
                AccountMeta::new_readonly(CTOKEN_PROGRAM_ID, false), // token_program
            ],
            data: instruction_data,
        };

        rpc.create_and_send_transaction(
            &[instruction],
            &payer.pubkey(),
            &[&payer, &ctoken_account],
        )
        .await
        .unwrap();
    }

    // Get the compressed mint account to build CompressedMintWithContext
    let compressed_mint_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value
        .expect("Compressed mint should exist");

    // Deserialize the compressed mint data
    use light_ctoken_interface::state::CompressedMint;
    let compressed_mint =
        CompressedMint::deserialize(&mut compressed_mint_account.data.unwrap().data.as_slice())
            .unwrap();

    let amount = 1_000_000_000u64; // 1 token with 9 decimals

    // Mint ctokens with test program.
    {
        // Get validity proof for the mint operation
        let rpc_result = rpc
            .get_validity_proof(vec![compressed_mint_account.hash], vec![], None)
            .await
            .unwrap()
            .value;

        // Build CompressedMintWithContext from the compressed account
        let compressed_mint_with_context =
            light_ctoken_interface::instructions::mint_action::CompressedMintWithContext {
                address: compression_address,
                leaf_index: compressed_mint_account.leaf_index,
                prove_by_index: true,
                root_index: rpc_result.accounts[0]
                    .root_index
                    .root_index()
                    .unwrap_or_default(), // Will be updated with validity proof
                mint: compressed_mint.try_into().unwrap(),
            };
        // Build instruction data for wrapper program
        let mint_to_data = MintToCTokenData {
            compressed_mint_inputs: compressed_mint_with_context.clone(),
            amount,
            mint_authority,
            proof: rpc_result.proof,
        };
        let wrapper_instruction_data = [vec![1u8], mint_to_data.try_to_vec().unwrap()].concat();

        // Build wrapper instruction with compressed token program as first account
        let compressed_token_program_id =
            Pubkey::new_from_array(light_ctoken_interface::COMPRESSED_TOKEN_PROGRAM_ID);

        let mut wrapper_accounts = vec![AccountMeta::new_readonly(
            compressed_token_program_id,
            false,
        )];
        let account_metas = MintActionMetaConfig::new(
            payer.pubkey(),
            mint_authority,
            compressed_mint_account.tree_info.tree,
            compressed_mint_account.tree_info.queue,
            compressed_mint_account.tree_info.queue,
        )
        .with_ctoken_accounts(vec![ctoken_account.pubkey()])
        .to_account_metas();
        wrapper_accounts.extend(account_metas);

        let instruction = Instruction {
            program_id: ID,
            accounts: wrapper_accounts,
            data: wrapper_instruction_data,
        };

        rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[&payer])
            .await
            .unwrap();
    }

    // Verify tokens were minted to the ctoken account
    let ctoken_account_data = rpc
        .get_account(ctoken_account.pubkey())
        .await
        .unwrap()
        .unwrap();

    // Parse the account data to verify balance
    use light_ctoken_interface::state::CToken;
    let account_state = CToken::deserialize(&mut &ctoken_account_data.data[..]).unwrap();
    assert_eq!(account_state.amount, amount, "Token amount should match");
    assert_eq!(
        account_state.mint.to_bytes(),
        mint_pda.to_bytes(),
        "Mint should match"
    );
    assert_eq!(
        account_state.owner.to_bytes(),
        owner.to_bytes(),
        "Owner should match"
    );
}

/// Test minting tokens with PDA mint authority using MintToCTokenInfos::invoke_signed()
///
/// This test uses the wrapper program to:
/// 1. Create a compressed mint with PDA authority (discriminator 14 - CreateCmintWithPdaAuthority)
/// 2. Mint tokens using PDA authority (discriminator 13 - MintToCtokenInvokeSigned)
#[tokio::test]
async fn test_mint_to_ctoken_invoke_signed() {
    let mut rpc = LightProgramTest::new(ProgramTestConfig::new_v2(
        false,
        Some(vec![("native_ctoken_examples", ID)]),
    ))
    .await
    .unwrap();

    let payer = rpc.get_payer().insecure_clone();

    // Derive both PDAs from our wrapper program
    let (mint_signer_pda, _) = Pubkey::find_program_address(&[MINT_SIGNER_SEED], &ID);
    let (mint_authority_pda, _) = Pubkey::find_program_address(&[MINT_AUTHORITY_SEED], &ID);

    let decimals = 9u8;
    let address_tree = rpc.get_address_tree_v2();
    let output_queue = rpc.get_random_state_tree_info().unwrap().queue;

    // Derive compression address using the PDA mint_signer
    let compression_address = light_ctoken_sdk::ctoken::derive_compressed_mint_address(
        &mint_signer_pda,
        &address_tree.tree,
    );

    let mint_pda = light_ctoken_sdk::ctoken::find_spl_mint_address(&mint_signer_pda).0;

    let rpc_result = rpc
        .get_validity_proof(
            vec![],
            vec![light_client::indexer::AddressWithTree {
                address: compression_address,
                tree: address_tree.tree,
            }],
            None,
        )
        .await
        .unwrap()
        .value;

    let compressed_token_program_id =
        Pubkey::new_from_array(light_ctoken_interface::COMPRESSED_TOKEN_PROGRAM_ID);
    let default_pubkeys = light_ctoken_sdk::utils::CTokenDefaultAccounts::default();

    // Step 1: Create compressed mint with PDA authority using wrapper program (discriminator 14)
    {
        let create_cmint_data = CreateCmintData {
            decimals,
            address_merkle_tree_root_index: rpc_result.addresses[0].root_index,
            mint_authority: mint_authority_pda, // Will be overridden by the handler
            proof: rpc_result.proof.0.unwrap(),
            compression_address,
            mint: mint_pda,
            freeze_authority: None,
            extensions: None,
        };
        // Discriminator 14 = CreateCmintWithPdaAuthority
        let wrapper_instruction_data =
            [vec![14u8], create_cmint_data.try_to_vec().unwrap()].concat();

        // Account order for CreateCmintWithPdaAuthority:
        // [0] compressed_token_program, [1] light_system_program, [2] mint_signer (PDA),
        // [3] authority (PDA), [4] fee_payer, [5] cpi_authority_pda, [6] registered_program_pda,
        // [7] account_compression_authority, [8] account_compression_program, [9] system_program,
        // [10] output_queue, [11] address_tree
        let wrapper_accounts = vec![
            AccountMeta::new_readonly(compressed_token_program_id, false),
            AccountMeta::new_readonly(default_pubkeys.light_system_program, false),
            AccountMeta::new_readonly(mint_signer_pda, false), // PDA - program signs
            AccountMeta::new(mint_authority_pda, false),       // writable PDA - program signs
            AccountMeta::new(payer.pubkey(), true),            // fee_payer
            AccountMeta::new_readonly(default_pubkeys.cpi_authority_pda, false),
            AccountMeta::new_readonly(default_pubkeys.registered_program_pda, false),
            AccountMeta::new_readonly(default_pubkeys.account_compression_authority, false),
            AccountMeta::new_readonly(default_pubkeys.account_compression_program, false),
            AccountMeta::new_readonly(default_pubkeys.system_program, false),
            AccountMeta::new(output_queue, false),
            AccountMeta::new(address_tree.tree, false),
        ];

        let create_mint_ix = Instruction {
            program_id: ID,
            accounts: wrapper_accounts,
            data: wrapper_instruction_data,
        };

        rpc.create_and_send_transaction(&[create_mint_ix], &payer.pubkey(), &[&payer])
            .await
            .unwrap();
    }

    let ctoken_account = Keypair::new();
    let owner = payer.pubkey();

    // Create a ctoken account to mint tokens to via wrapper program
    {
        let create_token_account_data = CreateTokenAccountData {
            owner,
            pre_pay_num_epochs: 2,
            lamports_per_write: 1,
        };
        let instruction_data =
            [vec![2u8], create_token_account_data.try_to_vec().unwrap()].concat();

        use light_ctoken_sdk::ctoken::{config_pda, rent_sponsor_pda};
        let config = config_pda();
        let rent_sponsor = rent_sponsor_pda();

        let instruction = Instruction {
            program_id: ID,
            accounts: vec![
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new(ctoken_account.pubkey(), true),
                AccountMeta::new_readonly(mint_pda, false),
                AccountMeta::new_readonly(config, false),
                AccountMeta::new_readonly(Pubkey::default(), false), // system_program
                AccountMeta::new(rent_sponsor, false),
                AccountMeta::new_readonly(CTOKEN_PROGRAM_ID, false),
            ],
            data: instruction_data,
        };

        rpc.create_and_send_transaction(
            &[instruction],
            &payer.pubkey(),
            &[&payer, &ctoken_account],
        )
        .await
        .unwrap();
    }

    // Get the compressed mint account to build CompressedMintWithContext
    let compressed_mint_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value
        .expect("Compressed mint should exist");

    // Deserialize the compressed mint data
    use light_ctoken_interface::state::CompressedMint;
    let compressed_mint =
        CompressedMint::deserialize(&mut compressed_mint_account.data.unwrap().data.as_slice())
            .unwrap();

    let amount = 1_000_000_000u64; // 1 token with 9 decimals

    // Mint ctokens with PDA authority via invoke_signed
    {
        // Get validity proof for the mint operation
        let rpc_result = rpc
            .get_validity_proof(vec![compressed_mint_account.hash], vec![], None)
            .await
            .unwrap()
            .value;

        // Build CompressedMintWithContext from the compressed account
        let compressed_mint_with_context =
            light_ctoken_interface::instructions::mint_action::CompressedMintWithContext {
                address: compression_address,
                leaf_index: compressed_mint_account.leaf_index,
                prove_by_index: true,
                root_index: rpc_result.accounts[0]
                    .root_index
                    .root_index()
                    .unwrap_or_default(),
                mint: compressed_mint.try_into().unwrap(),
            };

        // Build instruction data for wrapper program
        let mint_to_data = MintToCTokenData {
            compressed_mint_inputs: compressed_mint_with_context.clone(),
            amount,
            mint_authority: mint_authority_pda,
            proof: rpc_result.proof,
        };
        // Discriminator 13 = MintToCtokenInvokeSigned
        let wrapper_instruction_data = [vec![13u8], mint_to_data.try_to_vec().unwrap()].concat();

        // Build accounts manually since SDK marks authority as signer, but we need it as non-signer
        // for invoke_signed (the wrapper program signs via CPI)
        let compressed_token_program_id =
            Pubkey::new_from_array(light_ctoken_interface::COMPRESSED_TOKEN_PROGRAM_ID);
        let default_pubkeys = light_ctoken_sdk::utils::CTokenDefaultAccounts::default();

        let wrapper_accounts = vec![
            AccountMeta::new_readonly(compressed_token_program_id, false),
            AccountMeta::new_readonly(default_pubkeys.light_system_program, false),
            // authority NOT marked as signer - program will sign via invoke_signed
            AccountMeta::new_readonly(mint_authority_pda, false),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new_readonly(default_pubkeys.cpi_authority_pda, false),
            AccountMeta::new_readonly(default_pubkeys.registered_program_pda, false),
            AccountMeta::new_readonly(default_pubkeys.account_compression_authority, false),
            AccountMeta::new_readonly(default_pubkeys.account_compression_program, false),
            AccountMeta::new_readonly(default_pubkeys.system_program, false),
            AccountMeta::new(compressed_mint_account.tree_info.queue, false), // output_queue
            AccountMeta::new(compressed_mint_account.tree_info.tree, false),  // state_tree
            AccountMeta::new(compressed_mint_account.tree_info.queue, false), // input_queue
            AccountMeta::new(ctoken_account.pubkey(), false),                 // ctoken_account
        ];
        let instruction = Instruction {
            program_id: ID,
            accounts: wrapper_accounts,
            data: wrapper_instruction_data,
        };

        // Note: only payer signs, the mint_authority PDA is signed by the program via invoke_signed
        rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[&payer])
            .await
            .unwrap();
    }

    // Verify tokens were minted to the ctoken account
    let ctoken_account_data = rpc
        .get_account(ctoken_account.pubkey())
        .await
        .unwrap()
        .unwrap();

    // Parse the account data to verify balance
    use light_ctoken_interface::state::CToken;
    let account_state = CToken::deserialize(&mut &ctoken_account_data.data[..]).unwrap();
    assert_eq!(account_state.amount, amount, "Token amount should match");
    assert_eq!(
        account_state.mint.to_bytes(),
        mint_pda.to_bytes(),
        "Mint should match"
    );
    assert_eq!(
        account_state.owner.to_bytes(),
        owner.to_bytes(),
        "Owner should match"
    );
}
```
</Tab>
</Tabs>

# Next Steps

<CardGroup>
<Card
  title="Client Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/create-ctoken"
  horizontal
>
  Mint c-Tokens
</Card>
<Card
  title="Program Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/transfer-interface"
  horizontal
>
  Transfer Interface c-Token
</Card>
</CardGroup>