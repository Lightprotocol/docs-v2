---
title: Mint c-Tokens
description: Client guide to mint compressed tokens to c-Token accounts with step-by-step implementation and full code examples.
---

<Tabs>
<Tab title="Rust">

```rust mint_to_ctoken.rs
use borsh::BorshDeserialize;
use light_compressed_token_sdk::ctoken::{MintToCToken, MintToCTokenParams};
use light_ctoken_types::{
    instructions::mint_action::CompressedMintWithContext,
    state::CompressedMint,
};
use light_client::{indexer::Indexer, rpc::Rpc};
use solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer};

async fn mint_to_ctoken(
    rpc: &mut (impl Rpc + Indexer),
    payer: &Keypair,
    mint_authority: Pubkey,
    compression_address: [u8; 32],
    ata_pubkeys: Vec<Pubkey>,
    amounts: Vec<u64>,
) {
    // Get the compressed mint account
    let compressed_mint_account = rpc
        .get_compressed_account(compression_address, None)
        .await
        .unwrap()
        .value
        .expect("Compressed mint should exist");

    // Deserialize the compressed mint
    let compressed_mint =
        CompressedMint::deserialize(&mut compressed_mint_account.data.unwrap().data.as_slice())
            .unwrap();

    // Get validity proof for the mint operation
    let rpc_result = rpc
        .get_validity_proof(vec![compressed_mint_account.hash], vec![], None)
        .await
        .unwrap()
        .value;

    // Build CompressedMintWithContext
    let compressed_mint_with_context = CompressedMintWithContext {
        address: compression_address,
        leaf_index: compressed_mint_account.leaf_index,
        prove_by_index: true,
        root_index: rpc_result.accounts[0]
            .root_index
            .root_index()
            .unwrap_or_default(),
        mint: compressed_mint.try_into().unwrap(),
    };

    // Build mint params with first recipient
    let mut mint_params = MintToCTokenParams::new(
        compressed_mint_with_context,
        amounts[0],
        mint_authority,
        rpc_result.proof,
    );
    mint_params.mint_to_actions[0].account_index = 0;

    // Add remaining recipients
    for (idx, amount) in amounts.iter().enumerate().skip(1) {
        mint_params = mint_params.add_mint_to_action(idx as u8, *amount);
    }

    // Build MintToCToken instruction
    let mint_to_ctoken = MintToCToken::new(
        mint_params,
        payer.pubkey(),
        compressed_mint_account.tree_info.tree,
        compressed_mint_account.tree_info.queue,
        compressed_mint_account.tree_info.queue,
        ata_pubkeys.clone(),
    );
    let instruction = mint_to_ctoken.instruction().unwrap();

    // Send transaction
    rpc.create_and_send_transaction(&[instruction], &payer.pubkey(), &[payer])
        .await
        .unwrap();

    println!("Tokens minted to c-Token ATAs!");
    for (ata, amount) in ata_pubkeys.iter().zip(amounts.iter()) {
        println!("  {} -> {} tokens", ata, amount);
    }
}
```

</Tab>
<Tab title="TypeScript">

```typescript mint_to_ctoken.ts
// TODO: Add TypeScript example
```

</Tab>
</Tabs>

# Next Steps

<CardGroup>
<Card
  title="Program Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/program-guides/program-mint-to-c-Token"
  horizontal
>
  Mint c-Tokens
</Card>
<Card
  title="Client Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/compressed-token-program/ctoken/client-guides/client-transfer-interface"
  horizontal
>
  Transfer Interface
</Card>
</CardGroup>
