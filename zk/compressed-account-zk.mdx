---
title: Compressed Accounts for ZK Applications
description: ZK applications use Poseidon Hashes instead of SHA-256 to store state in compressed accounts compatible with zero-knowledge circuits.
keywords: ["compressed accounts zk", "poseidon hashing solana", "groth16 solana", "privacy solana"]
---

import ZkAppPrompt from "/snippets/ai-prompts/zk-app.mdx";
import MerkleProofCircuit from '/snippets/code-snippets/zk/merkle-proof/circuit.mdx';
import MerkleProofProgram from '/snippets/code-snippets/zk/merkle-proof/program.mdx';
import MerkleProofRustClient from '/snippets/code-snippets/zk/merkle-proof/rust-client.mdx';
import MerkleProofTypescriptClient from '/snippets/code-snippets/zk/merkle-proof/typescript-client.mdx';

* Compressed and regular Solana accounts share the same functionality and are fully composable.
* The account state is hashed with Poseidon and stored as a commitment in the state Merkle tree.
* RPCs that support ZK Compression (Helius, Triton) index state changes.

<Info>
Each tab below includes a full code example. See the full implementation at [program-examples/zk/zk-merkle-proof](https://github.com/Lightprotocol/program-examples/tree/main/zk/zk-merkle-proof).
</Info>

## Implementation guide

<Tabs>
<Tab title="Program">
<Steps>
<Step>

### Dependencies

Add dependencies to your program.

```toml
[dependencies]
anchor-lang = "0.31.1"
borsh = "0.10.4"
light-sdk = { version = "0.17.1", features = ["anchor", "poseidon", "merkle-tree", "v2"] }
light-hasher = "5.0.0"
light-sdk-types = { version = "0.17.1", features = ["v2"] }
```

* `light-sdk` with `poseidon` feature enables ZK-friendly hashing.
* `light-hasher` provides Poseidon hash functions.

</Step>

<Step>

### Constants

Set program address, CPI signer, and include the verifying key from your circuit setup.

```rust
declare_id!("MPzkYomvQc4VQPwMr6bFduyWRQZVCh5CofgDC4dFqJp");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("MPzkYomvQc4VQPwMr6bFduyWRQZVCh5CofgDC4dFqJp");

pub const ZK_ACCOUNT: &[u8] = b"zk_account";

// Generated from circom trusted setup (.zkey file)
pub mod verifying_key;
```

</Step>

<Step>

### Compressed account


```rust
#[derive(Clone, Debug, Default, BorshSerialize, BorshDeserialize, LightDiscriminator, LightHasher)]
pub struct ZkAccount {
    pub data_hash: ZkDataHash,
}
```

**ZK-specific differences from regular compressed accounts:**

* Derive `LightHasher` for Poseidon hashing (instead of default SHA-256).

**Custom types need `ToByteArray`:**

```rust
#[derive(Clone, Debug, Default, BorshSerialize, BorshDeserialize)]
pub struct ZkDataHash(pub [u8; 32]);

impl ToByteArray for ZkDataHash {
    const NUM_FIELDS: usize = 1;
    fn to_byte_array(&self) -> std::result::Result<[u8; 32], HasherError> {
        Ok(self.0)
    }
}
```

</Step>

<Step>

### Instruction data

Define the instruction parameters.

```rust
pub fn create_account<'info>(
    ctx: Context<'_, '_, '_, 'info, CreateAccountAccounts<'info>>,
    proof: ValidityProof,
    address_tree_info: PackedAddressTreeInfo,
    output_state_tree_index: u8,
    data_hash: [u8; 32],
) -> Result<()>
```

1. `proof`: Proves the address does not exist yet.
2. `address_tree_info`: References the address tree for deriving the address.
3. `output_state_tree_index`: References the state tree for storing the account hash.
4. `data_hash`: The Poseidon hash of the data to store.

</Step>

<Step>

### Derive address

Derive the address as a persistent unique identifier.

```rust
let address_tree_pubkey = address_tree_info
    .get_tree_pubkey(&light_cpi_accounts)
    .map_err(|_| ProgramError::InvalidAccountData)?;

let (address, address_seed) = derive_address(
    &[ZK_ACCOUNT, &data_hash],
    &address_tree_pubkey,
    &crate::ID,
);
```

</Step>

<Step>

### Address tree check

Ensure global uniqueness by verifying the address tree pubkey.

```rust
if address_tree_pubkey.to_bytes() != light_sdk::constants::ADDRESS_TREE_V2 {
    msg!("Invalid address tree");
    return Err(ProgramError::InvalidAccountData.into());
}
```

</Step>

<Step>

### Initialize compressed account


```rust
let mut account = LightAccountPoseidon::<ZkAccount>::new_init(
    &crate::ID,
    Some(address),
    output_state_tree_index,
);

account.data_hash = ZkDataHash(data_hash);
```


</Step>

<Step>

### Light System Program CPI


```rust
let light_cpi_accounts = CpiAccounts::new(
    ctx.accounts.signer.as_ref(),
    ctx.remaining_accounts,
    crate::LIGHT_CPI_SIGNER,
);

LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, proof)
    .with_light_account_poseidon(account)?
    .with_new_addresses(&[address_tree_info.into_new_address_params_packed(address_seed)])
    .invoke(light_cpi_accounts)?;
```
</Step>
</Steps>

## Full code example

<Tabs>
<Tab title="Program">
<MerkleProofProgram />
</Tab>
<Tab title="Rust client">
<MerkleProofRustClient />
</Tab>
<Tab title="TypeScript client">
<MerkleProofTypescriptClient />
</Tab>
<Tab title="Circuit Example">
<MerkleProofCircuit />
</Tab>
<Tab title="Get started with AI">
<ZkAppPrompt />
</Tab>
</Tabs>
</Tab>

<Tab title="Client">

ZK clients follow the same pattern as [regular compressed account clients](/client-library/client-guide), with additional steps for generating Groth16 proofs.

## Key points

1. **Derive a new address** or **fetch compressed account** for on-chain verification.
2. **Fetch validity proof** from the RPC that verifies a new address does not exist in the address tree.
3. **Pack accounts** with the SDKs helper. Instructions require <Tooltip tip="The system program enforces the compressed account layout with ownership and sum checks and verifies the validity of your input state. It is also invoked to create/write to compressed accounts and PDAs.">Light System Program</Tooltip> and <Tooltip tip="Merkle tree accounts are the accounts of state tree and address trees that store compressed account hashes and addresses.">Merkle tree accounts</Tooltip>. `PackedAccounts` converts their pubkeys to `u8` indices pointing to accounts in the instruction.
4. **Build the instruction** with the current account data, new data, packed accounts and validity proof.
5. **Generate ZK proof** with snarkjs to generate a Groth16 proof client-side that verifies account state without revealing the Merkle path.
6. **Build the instruction** with the proof, packed accounts, and account data.

## Get started

<Steps>
<Step>

### Setup

<Tabs>
<Tab title="TypeScript">

#### 1. Installation

```bash
npm install \
    @lightprotocol/stateless.js@0.22.1-alpha.1 \
    @solana/web3.js \
    snarkjs \
    circomlibjs \
    @noble/hashes
```

| ZK Dependencies | Purpose |
|---------|---------|
| `snarkjs` | Groth16 proof generation |
| `circomlibjs` | Poseidon hasher for computing account hashes |
| `@noble/hashes` | Keccak-256 for BN254 field hashing |

#### 2. Build circuit 

```bash
# Compile circuit
circom circuits/merkle_proof.circom --r1cs --wasm --sym -o build

# Trusted setup
snarkjs groth16 setup build/merkle_proof.r1cs pot12_final.ptau build/merkle_proof_0000.zkey
snarkjs zkey contribute build/merkle_proof_0000.zkey build/merkle_proof_final.zkey
```

| File | Purpose |
|------|---------|
| `merkle_proof.wasm` | Compiled circuit for witness generation |
| `merkle_proof_final.zkey` | Proving key from trusted setup |

</Tab>
</Tabs>

</Step>

<Step>

### ZK proof

For ZK verification, generate the proof client-side instead of fetching from RPC.

**Step 1: Fetch Merkle proof from indexer**

```typescript
const account = await rpc.getCompressedAccount(bn(address.toBytes()));
const merkleProofs = await rpc.getMultipleCompressedAccountProofs([account.hash]);
```

**Step 2: Hash inputs to BN254 field**

```typescript
function hashToBn254Field(data: Uint8Array): Uint8Array {
  const hash = keccak_256(data);
  hash[0] = hash[0] & 0x1f;  // < 2^254
  return hash;
}

const ownerHashed = hashToBn254Field(programId.toBytes());
const merkleTreeHashed = hashToBn254Field(merkleTreePubkey.toBytes());
```

**Step 3: Compute account hash (Poseidon)**

```typescript
const LAMPORTS_OFFSET = 36893488147419103232n;
const accountHash = poseidon([
  ownerHashed,
  leafIndex,
  merkleTreeHashed,
  address,
  discriminator + LAMPORTS_OFFSET,
  dataHash
]);
```

**Step 4: Prepare circuit inputs**

```typescript
const inputs = {
  // Public inputs (verified on-chain)
  owner_hashed: toFieldString(ownerHashed),
  merkle_tree_hashed: toFieldString(merkleTreeHashed),
  discriminator: toFieldString(discriminator),
  data_hash: toFieldString(dataHash),
  expectedRoot: toFieldString(merkleRoot),

  // Private inputs (hidden in proof)
  leaf_index: leafIndex.toString(),
  account_leaf_index: accountLeafIndex.toString(),
  address: toFieldString(address),
  pathElements: pathElements.map(toFieldString),
};
```

**Step 5: Generate Groth16 proof**

```typescript
const { proof } = await snarkjs.groth16.fullProve(
  inputs,
  "build/merkle_proof_js/merkle_proof.wasm",
  "build/merkle_proof_final.zkey"
);
```

**Step 6: Compress proof for on-chain**

```typescript
const compressedProof = parseProofToCompressed(proof);
// Returns: { a: 32 bytes, b: 64 bytes, c: 32 bytes }
```

</Step>

<Step>

### Instruction data

<Tabs>
<Tab title="Create (same as regular)">

```typescript
const instructionData = {
  proof: { 0: proofResult.compressedProof },
  addressTreeInfo: {
    addressMerkleTreePubkeyIndex: addressMerkleTreeIndex,
    addressQueuePubkeyIndex: addressMerkleTreeIndex,
    rootIndex: proofResult.rootIndices[0],
  },
  outputStateTreeIndex,
  dataHash: Array.from(dataHash),
};
```

</Tab>

<Tab title="ZK verify">

```typescript
const instructionData = {
  inputRootIndex: merkleProof.rootIndex,
  zkProof: compressedProof,  // { a: [...], b: [...], c: [...] }
  dataHash: Array.from(dataHash),
};
```

The compressed proof format:
- `a`: 32 bytes (G1 X coordinate + sign bit)
- `b`: 64 bytes (G2 X coordinates + sign bit)
- `c`: 32 bytes (G1 X coordinate + sign bit)

</Tab>
</Tabs>

</Step>

<Step>

### Instruction

Build the instruction with Anchor.

```typescript
const instruction = await program.methods
  .createAccount(
    proof,
    addressTreeInfo,
    outputStateTreeIndex,
    systemStart,
    Array.from(dataHash)
  )
  .accounts({ signer: signer.publicKey })
  .remainingAccounts(remainingAccounts)
  .instruction();
```

</Step>

<Step>

### Send transaction

```typescript
const tx = new web3.Transaction().add(computeBudgetIx, instruction);
tx.recentBlockhash = (await rpc.getLatestBlockhash()).blockhash;
tx.feePayer = signer.publicKey;
tx.sign(signer);

const sig = await rpc.sendTransaction(tx, [signer]);
```

</Step>
</Steps>

## Full code example

<Tabs>
<Tab title="Program">
<MerkleProofProgram />
</Tab>
<Tab title="Rust client">
<MerkleProofRustClient />
</Tab>
<Tab title="TypeScript client">
<MerkleProofTypescriptClient />
</Tab>
<Tab title="Circuit example">
<MerkleProofCircuit />
</Tab>
<Tab title="Get started with AI">
<ZkAppPrompt />
</Tab>
</Tabs>
</Tab>

<Tab title="Circuit Example">
This is an example circuit to include compressed accounts.

<MerkleProofCircuit />

## Full code example

<Tabs>
<Tab title="Program">
<MerkleProofProgram />
</Tab>
<Tab title="Rust client">
<MerkleProofRustClient />
</Tab>
<Tab title="TypeScript client">
<MerkleProofTypescriptClient />
</Tab>
</Tabs>
</Tab>

<Tab title="Get started with AI">
For AI assistance with your ZK App, copy this prompt and add your design ideas:

<ZkAppPrompt />

## Full code example

<Tabs>
<Tab title="Program">
<MerkleProofProgram />
</Tab>
<Tab title="Rust client">
<MerkleProofRustClient />
</Tab>
<Tab title="TypeScript client">
<MerkleProofTypescriptClient />
</Tab>
<Tab title="Circuit Example">
<MerkleProofCircuit />
</Tab>
</Tabs>
</Tab>
</Tabs>

## Next steps

<Card
  title="Nullifier Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/zk/nullifiers"
  horizontal
/>