---
title: "Compressed Token Support"
description: "Implementation guide for adding native compressed token support to Privy"
---

import SdkInstall from '/snippets/versions/sdk-install-0.22.1-alpha.1.mdx';

## Overview



|       | Solana Token Account   | Compressed Token Account      |
| :------------- | :--------------------- | :---------------------- |
| **Creation** | 	~2,000,000 lamports          | **5,000** lamports     |
| **Update** | 	Transaction fee          | Transaction fee+<br/>**5,300** lamports     |

Compressed tokens are SPL tokens stored in Merkle trees. 
The Merkle tree root hash is stored in an on-chain account and verified with each transaction.

### In this guide
**What needs to implemented:**
1. Balance display for compressed tokens
2. Transaction building for compressed token transfers
3. Decompression to regular SPL (for offramps)

**What doesn't change:**
- Wallet creation (compressed tokens use the same public key)
- Transactions (standard Solana transaction format)

<Accordion title="Supplementary Resources">
Documentation: https://zkcompression.com

GitHub: https://github.com/Lightprotocol/lightprotocol

SDK Reference:
- [compressed-token](https://lightprotocol.github.io/light-protocol/compressed-token/index.html)
- [stateless.js](https://lightprotocol.github.io/light-protocol/stateless.js/index.html)
</Accordion>
<Accordion title="Add MCP">
* The zkcompression.com/mcp gives context to the documentation.
* We recommend to use Deepwiki for advanced AI assistance with your development.

<Tabs>
<Tab title="Claude Code">

```bash
claude mcp add -s user -t http deepwiki https://mcp.deepwiki.com/mcp
claude mcp add -s user -t http zkcompression https://www.zkcompression.com/mcp
```
</Tab>
<Tab title="Codex">

```bash
codex mcp add zkcompression -- npx -y mcp-remote@latest https://www.zkcompression.com/mcp
codex mcp add deepwiki -- npx -y mcp-remote@latest https://mcp.deepwiki.com/mcp
```

</Tab>
<Tab title="Most Clients (Windsurf, Cursor, ...)">
```json
{
  "mcpServers": {
    "deepwiki": {
      "serverUrl": "https://mcp.deepwiki.com/sse"
    },
    "zkcompression": {
      "command": "npx",
      "args": ["-y", "mcp-remote@latest", "https://www.zkcompression.com/mcp"]
    }
  }
}
```
</Tab>
</Tabs>

<Card
  title="Full AI Tools Guide"
  icon="chevron-right"
  color="#0066ff"
  href="/learn/ai-tools-guide"
  horizontal
>
</Card>
</Accordion>

## Setup

<Steps>
<Step title="Installation">

<SdkInstall />

</Step>
<Step title="RPC Configuration">

Use a ZK Compression-enabled RPC endpoint. The same endpoint serves both standard Solana methods and compressed token methods.

**Supported providers:**
- Helius: `https://mainnet.helius-rpc.com?api-key=YOUR_KEY`
- Triton: `https://your-endpoint.triton.one`

```typescript
import { createRpc, Rpc } from '@lightprotocol/stateless.js';

const RPC_ENDPOINT = 'https://mainnet.helius-rpc.com?api-key=YOUR_KEY';
const connection: Rpc = createRpc(RPC_ENDPOINT, RPC_ENDPOINT);
```

</Step>
<Step title="Get Started">
</Step>
</Steps>

## Display Compressed Token Balances

To display compressed token balances, call `getCompressedTokenBalancesByOwnerV2` with the wallet's public key.
For the user nothing changes in the UI by default.

### RPC Method

```typescript
const balances = await connection.getCompressedTokenBalancesByOwnerV2(ownerPublicKey);
```

### Response Structure

```typescript
{
  value: {
    items: [
      {
        mint: PublicKey,      // SPL mint address (e.g., USDC)
        balance: BN | string, // Token balance (may be hex string)
      }
    ]
  }
}
```

### Implementation Example

```typescript
import { createRpc, Rpc } from '@lightprotocol/stateless.js';
import { PublicKey } from '@solana/web3.js';

const USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');

async function getCompressedBalance(
  connection: Rpc,
  owner: PublicKey,
  mint: PublicKey
): Promise<number> {
  const balances = await connection.getCompressedTokenBalancesByOwnerV2(owner);

  const tokenBalance = balances.value.items.find(
    (item) => item.mint.toString() === mint.toString()
  );

  if (!tokenBalance) return 0;

  // Handle both number and hex string formats
  const rawBalance = typeof tokenBalance.balance === 'string'
    ? parseInt(tokenBalance.balance, 16)
    : tokenBalance.balance;

  // Get decimals from mint account (USDC = 6)
  const mintInfo = await connection.getAccountInfo(mint);
  const decimals = mintInfo?.data[44] ?? 6;

  return rawBalance / Math.pow(10, decimals);
}
```

## Send Compressed Tokens

### Flow

```
1. Fetch compressed accounts for sender
2. Select accounts that cover transfer amount
3. Get validity proof for selected accounts (generated by your RPC)
4. Build transfer instruction
5. Sign and send transaction
```

### Implementation

```typescript
import { createRpc, Rpc, bn } from '@lightprotocol/stateless.js';
import {
  CompressedTokenProgram,
  selectMinCompressedTokenAccountsForTransfer,
} from '@lightprotocol/compressed-token';
import { ComputeBudgetProgram, PublicKey, Transaction } from '@solana/web3.js';

async function buildCompressedTransfer(
  connection: Rpc,
  sender: PublicKey,
  recipient: PublicKey,
  mint: PublicKey,
  amount: number,  // In token units (e.g., 10 USDC)
  decimals: number // Token decimals (e.g., 6 for USDC)
): Promise<Transaction> {
  const tokenAmount = bn(amount * Math.pow(10, decimals));

  // 1. Fetch sender's compressed token accounts
  const compressedAccounts = await connection.getCompressedTokenAccountsByOwner(
    sender,
    { mint }
  );

  if (compressedAccounts.items.length === 0) {
    throw new Error('No compressed tokens found for this mint');
  }

  // 2. Select accounts that cover the transfer amount
  const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(
    compressedAccounts.items,
    tokenAmount
  );

  // 3. Get validity proof for the selected accounts
  const proof = await connection.getValidityProof(
    inputAccounts.map((account) => account.compressedAccount.hash)
  );

  // 4. Build transfer instruction
  const transferIx = await CompressedTokenProgram.transfer({
    payer: sender,
    inputCompressedTokenAccounts: inputAccounts,
    toAddress: recipient,
    amount: tokenAmount,
    recentInputStateRootIndices: proof.rootIndices,
    recentValidityProof: proof.compressedProof,
  });

  // 5. Build transaction
  const { blockhash } = await connection.getLatestBlockhash();
  const transaction = new Transaction();
  transaction.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }));
  transaction.add(transferIx);
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = sender;

  return transaction;
}
```

### Key Points

- **Validity proofs are time-sensitive**: Fetch a fresh proof immediately before sending. Stale proofs cause transaction failures.
- **Multiple input accounts**: A single transfer may consume multiple compressed accounts if the sender's balance is fragmented.
- **Compute budget**: Compressed token transfers require ~300,000 compute units.

## Decompress to SPL (Offramp)

Decompression converts compressed tokens back to regular SPL tokens. This is required for:
- CEX withdrawals (exchanges only accept SPL tokens)
- DeFi protocols that don't support compressed tokens
- Any integration requiring standard token accounts

### Flow

```
1. Fetch compressed accounts for sender
2. Select accounts that cover amount
3. Get validity proof
4. Get token pool info for decompression
5. Build decompress instruction
6. Sign and send transaction
```

### Implementation

```typescript
import { createRpc, Rpc, bn } from '@lightprotocol/stateless.js';
import {
  CompressedTokenProgram,
  selectMinCompressedTokenAccountsForTransfer,
  getTokenPoolInfos,
  selectTokenPoolInfosForDecompression,
} from '@lightprotocol/compressed-token';
import { ComputeBudgetProgram, PublicKey, Transaction } from '@solana/web3.js';
import { getAssociatedTokenAddress } from '@solana/spl-token';

async function buildDecompressTransaction(
  connection: Rpc,
  payer: PublicKey,
  destinationOwner: PublicKey,  // Owner of the destination SPL token account
  mint: PublicKey,
  amount: number,
  decimals: number
): Promise<Transaction> {
  const rawAmount = amount * Math.pow(10, decimals);
  const tokenAmount = bn(rawAmount);

  // 1. Get destination ATA (where SPL tokens will be sent)
  const destinationAta = await getAssociatedTokenAddress(mint, destinationOwner);

  // 2. Fetch compressed accounts
  const compressedAccounts = await connection.getCompressedTokenAccountsByOwner(
    payer,
    { mint }
  );

  if (compressedAccounts.items.length === 0) {
    throw new Error('No compressed tokens found');
  }

  // 3. Select accounts for the amount
  const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(
    compressedAccounts.items,
    tokenAmount
  );

  // 4. Get validity proof
  const proof = await connection.getValidityProof(
    inputAccounts.map((account) => account.compressedAccount.hash)
  );

  // 5. Get token pool info for decompression
  const tokenPoolInfos = await getTokenPoolInfos(connection, mint);
  const selectedTokenPoolInfos = selectTokenPoolInfosForDecompression(
    tokenPoolInfos,
    rawAmount
  );

  // 6. Build decompress instruction
  const decompressIx = await CompressedTokenProgram.decompress({
    payer,
    inputCompressedTokenAccounts: inputAccounts,
    toAddress: destinationAta,
    amount: rawAmount,
    tokenPoolInfos: selectedTokenPoolInfos,
    recentInputStateRootIndices: proof.rootIndices,
    recentValidityProof: proof.compressedProof,
  });

  // 7. Build transaction
  const { blockhash } = await connection.getLatestBlockhash();
  const transaction = new Transaction();
  transaction.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }));
  transaction.add(decompressIx);
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = payer;

  return transaction;
}
```

## Error Handling

| Error | Cause | Solution |
|-------|-------|----------|
| `No compressed tokens found` | Wallet has no compressed tokens for this mint | Check mint address, verify wallet has compressed (not SPL) tokens |
| `Proof verification failed` | Stale validity proof | Fetch fresh proof immediately before transaction |
| `Insufficient balance` | Selected accounts don't cover amount | Check total balance before building transaction |

## Resources

- [ZK Compression Docs](https://www.zkcompression.com)
- [Helius RPC](https://docs.helius.dev)
- [Light Protocol GitHub](https://github.com/Lightprotocol/light-protocol)
